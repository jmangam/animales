"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_ionic_core_dist_esm_ion-modal_entry_js"],{

/***/ 9273:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/index-c4b11676.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": () => (/* binding */ printRequiredElementError),
/* harmony export */   "b": () => (/* binding */ printIonError),
/* harmony export */   "p": () => (/* binding */ printIonWarning)
/* harmony export */ });
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */

/**
 * Logs a warning to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 */
const printIonWarning = (message, ...params) => {
  return console.warn(`[Ionic Warning]: ${message}`, ...params);
};
/*
 * Logs an error to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 * @param params - Additional arguments to supply to the console.error.
 */


const printIonError = (message, ...params) => {
  return console.error(`[Ionic Error]: ${message}`, ...params);
};
/**
 * Prints an error informing developers that an implementation requires an element to be used
 * within a specific selector.
 *
 * @param el The web component element this is requiring the element.
 * @param targetSelectors The selector or selectors that were not found.
 */


const printRequiredElementError = (el, ...targetSelectors) => {
  return console.error(`<${el.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(' or ')}.`);
};



/***/ }),

/***/ 8737:
/*!**************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/ion-modal.entry.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ion_modal": () => (/* binding */ Modal)
/* harmony export */ });
/* harmony import */ var C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 1670);
/* harmony import */ var _index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-8e692445.js */ 1559);
/* harmony import */ var _ionic_global_c95cf239_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ionic-global-c95cf239.js */ 8607);
/* harmony import */ var _index_5d0c8232_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index-5d0c8232.js */ 3081);
/* harmony import */ var _framework_delegate_897f849d_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./framework-delegate-897f849d.js */ 3701);
/* harmony import */ var _helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers-3b390e48.js */ 9234);
/* harmony import */ var _keyboard_4d5544a0_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keyboard-4d5544a0.js */ 6524);
/* harmony import */ var _index_c4b11676_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./index-c4b11676.js */ 9273);
/* harmony import */ var _overlays_87c7c7cb_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./overlays-87c7c7cb.js */ 2752);
/* harmony import */ var _theme_7670341c_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./theme-7670341c.js */ 320);
/* harmony import */ var _index_e6cecce9_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./index-e6cecce9.js */ 9287);
/* harmony import */ var _animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./animation-2c50d24d.js */ 631);
/* harmony import */ var _cubic_bezier_c313947a_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cubic-bezier-c313947a.js */ 1077);
/* harmony import */ var _index_f8d8aa5a_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./index-f8d8aa5a.js */ 9286);
/* harmony import */ var _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./index-33ffec25.js */ 2286);
/* harmony import */ var _hardware_back_button_490df115_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hardware-back-button-490df115.js */ 159);
/* harmony import */ var _gesture_controller_17060b7c_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./gesture-controller-17060b7c.js */ 6379);


/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
















var Style;

(function (Style) {
  Style["Dark"] = "DARK";
  Style["Light"] = "LIGHT";
  Style["Default"] = "DEFAULT";
})(Style || (Style = {}));

const StatusBar = {
  getEngine() {
    var _a;

    return ((_a = _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w === null || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w === void 0 ? void 0 : _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w.Capacitor) === null || _a === void 0 ? void 0 : _a.isPluginAvailable('StatusBar')) && (_index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w === null || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w === void 0 ? void 0 : _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w.Capacitor.Plugins.StatusBar);
  },

  supportsDefaultStatusBarStyle() {
    var _a;
    /**
     * The 'DEFAULT' status bar style was added
     * to the @capacitor/status-bar plugin in Capacitor 3.
     * PluginHeaders is only supported in Capacitor 3+,
     * so we can use this to detect Capacitor 3.
     */


    return !!((_a = _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w === null || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w === void 0 ? void 0 : _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w.Capacitor) === null || _a === void 0 ? void 0 : _a.PluginHeaders);
  },

  setStyle(options) {
    const engine = this.getEngine();

    if (!engine) {
      return;
    }

    engine.setStyle(options);
  }

};
/**
 * Use y = mx + b to
 * figure out the backdrop value
 * at a particular x coordinate. This
 * is useful when the backdrop does
 * not begin to fade in until after
 * the 0 breakpoint.
 */

const getBackdropValueForSheet = (x, backdropBreakpoint) => {
  /**
   * We will use these points:
   * (backdropBreakpoint, 0)
   * (maxBreakpoint, 1)
   * We know that at the beginning breakpoint,
   * the backdrop will be hidden. We also
   * know that at the maxBreakpoint, the backdrop
   * must be fully visible. maxBreakpoint should
   * always be 1 even if the maximum value
   * of the breakpoints array is not 1 since
   * the animation runs from a progress of 0
   * to a progress of 1.
   * m = (y2 - y1) / (x2 - x1)
   *
   * This is simplified from:
   * m = (1 - 0) / (maxBreakpoint - backdropBreakpoint)
   *
   * If the backdropBreakpoint is 1, we return 0 as the
   * backdrop is completely hidden.
   *
   */
  if (backdropBreakpoint === 1) {
    return 0;
  }

  const slope = 1 / (1 - backdropBreakpoint);
  /**
   * From here, compute b which is
   * the backdrop opacity if the offset
   * is 0. If the backdrop does not
   * begin to fade in until after the
   * 0 breakpoint, this b value will be
   * negative. This is fine as we never pass
   * b directly into the animation keyframes.
   * b = y - mx
   * Use a known point: (backdropBreakpoint, 0)
   * This is simplified from:
   * b = 0 - (backdropBreakpoint * slope)
   */

  const b = -(backdropBreakpoint * slope);
  /**
   * Finally, we can now determine the
   * backdrop offset given an arbitrary
   * gesture offset.
   */

  return x * slope + b;
};
/**
 * The tablet/desktop card modal activates
 * when the window width is >= 768.
 * At that point, the presenting element
 * is not transformed, so we do not need to
 * adjust the status bar color.
 *
 * Note: We check supportsDefaultStatusBarStyle so that
 * Capacitor <= 2 users do not get their status bar
 * stuck in an inconsistent state due to a lack of
 * support for Style.Default.
 */


const setCardStatusBarDark = () => {
  if (!_index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {
    return;
  }

  StatusBar.setStyle({
    style: Style.Dark
  });
};

const setCardStatusBarDefault = () => {
  if (!_index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w || _index_33ffec25_js__WEBPACK_IMPORTED_MODULE_14__.w.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {
    return;
  }

  StatusBar.setStyle({
    style: Style.Default
  });
};

const handleCanDismiss = /*#__PURE__*/function () {
  var _ref = (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (el, animation) {
    /**
     * If canDismiss is not a function
     * then we can return early. If canDismiss is `true`,
     * then canDismissBlocksGesture is `false` as canDismiss
     * will never interrupt the gesture. As a result,
     * this code block is never reached. If canDismiss is `false`,
     * then we never dismiss.
     */
    if (typeof el.canDismiss !== 'function') {
      return;
    }
    /**
     * Run the canDismiss callback.
     * If the function returns `true`,
     * then we can proceed with dismiss.
     */


    const shouldDismiss = yield el.canDismiss();

    if (!shouldDismiss) {
      return;
    }
    /**
     * If canDismiss resolved after the snap
     * back animation finished, we can
     * dismiss immediately.
     *
     * If canDismiss resolved before the snap
     * back animation finished, we need to
     * wait until the snap back animation is
     * done before dismissing.
     */


    if (animation.isRunning()) {
      animation.onFinish(() => {
        el.dismiss(undefined, 'handler');
      }, {
        oneTimeCallback: true
      });
    } else {
      el.dismiss(undefined, 'handler');
    }
  });

  return function handleCanDismiss(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * This function lets us simulate a realistic spring-like animation
 * when swiping down on the modal.
 * There are two forces that we need to use to compute the spring physics:
 *
 * 1. Stiffness, k: This is a measure of resistance applied a spring.
 * 2. Dampening, c: This value has the effect of reducing or preventing oscillation.
 *
 * Using these two values, we can calculate the Spring Force and the Dampening Force
 * to compute the total force applied to a spring.
 *
 * Spring Force: This force pulls a spring back into its equilibrium position.
 * Hooke's Law tells us that that spring force (FS) = kX.
 * k is the stiffness of a spring, and X is the displacement of the spring from its
 * equilibrium position. In this case, it is the amount by which the free end
 * of a spring was displaced (stretched/pushed) from its "relaxed" position.
 *
 * Dampening Force: This force slows down motion. Without it, a spring would oscillate forever.
 * The dampening force, FD, can be found via this formula: FD = -cv
 * where c the dampening value and v is velocity.
 *
 * Therefore, the resulting force that is exerted on the block is:
 * F = FS + FD = -kX - cv
 *
 * Newton's 2nd Law tells us that F = ma:
 * ma = -kX - cv.
 *
 * For Ionic's purposes, we can assume that m = 1:
 * a = -kX - cv
 *
 * Imagine a block attached to the end of a spring. At equilibrium
 * the block is at position x = 1.
 * Pressing on the block moves it to position x = 0;
 * So, to calculate the displacement, we need to take the
 * current position and subtract the previous position from it.
 * X = x - x0 = 0 - 1 = -1.
 *
 * For Ionic's purposes, we are only pushing on the spring modal
 * so we have a max position of 1.
 * As a result, we can expand displacement to this formula:
 * X = x - 1
 *
 * a = -k(x - 1) - cv
 *
 * We can represent the motion of something as a function of time: f(t) = x.
 * The derivative of position gives us the velocity: f'(t)
 * The derivative of the velocity gives us the acceleration: f''(t)
 *
 * We can substitute the formula above with these values:
 *
 * f"(t) = -k * (f(t) - 1) - c * f'(t)
 *
 * This is called a differential equation.
 *
 * We know that at t = 0, we are at x = 0 because the modal does not move: f(0) = 0
 * This means our velocity is also zero: f'(0) = 0.
 *
 * We can cheat a bit and plug the formula into Wolfram Alpha.
 * However, we need to pick stiffness and dampening values:
 * k = 0.57
 * c = 15
 *
 * I picked these as they are fairly close to native iOS's spring effect
 * with the modal.
 *
 * What we plug in is this: f(0) = 0; f'(0) = 0; f''(t) = -0.57(f(t) - 1) - 15f'(t)
 *
 * The result is a formula that lets us calculate the acceleration
 * for a given time t.
 * Note: This is the approximate form of the solution. Wolfram Alpha will
 * give you a complex differential equation too.
 */


const calculateSpringStep = t => {
  return 0.00255275 * 2.71828 ** (-14.9619 * t) - 1.00255 * 2.71828 ** (-0.0380968 * t) + 1;
}; // Defaults for the card swipe animation


const SwipeToCloseDefaults = {
  MIN_PRESENTING_SCALE: 0.93
};

const createSwipeToCloseGesture = (el, animation, onDismiss) => {
  /**
   * The step value at which a card modal
   * is eligible for dismissing via gesture.
   */
  const DISMISS_THRESHOLD = 0.5;
  const height = el.offsetHeight;
  let isOpen = false;
  let canDismissBlocksGesture = false;
  let contentEl = null;
  let scrollEl = null;
  const canDismissMaxStep = 0.2;
  let initialScrollY = true;
  let lastStep = 0;

  const getScrollY = () => {
    if (contentEl && (0,_index_5d0c8232_js__WEBPACK_IMPORTED_MODULE_3__.i)(contentEl)) {
      return contentEl.scrollY;
      /**
       * Custom scroll containers are intended to be
       * used with virtual scrolling, so we assume
       * there is scrolling in this case.
       */
    } else {
      return true;
    }
  };

  const canStart = detail => {
    const target = detail.event.target;

    if (target === null || !target.closest) {
      return true;
    }
    /**
     * If we are swiping on the content,
     * swiping should only be possible if
     * the content is scrolled all the way
     * to the top so that we do not interfere
     * with scrolling.
     *
     * We cannot assume that the `ion-content`
     * target will remain consistent between
     * swipes. For example, when using
     * ion-nav within a card modal it is
     * possible to swipe, push a view, and then
     * swipe again. The target content will not
     * be the same between swipes.
     */


    contentEl = (0,_index_5d0c8232_js__WEBPACK_IMPORTED_MODULE_3__.f)(target);

    if (contentEl) {
      /**
       * The card should never swipe to close
       * on the content with a refresher.
       * Note: We cannot solve this by making the
       * swipeToClose gesture have a higher priority
       * than the refresher gesture as the iOS native
       * refresh gesture uses a scroll listener in
       * addition to a gesture.
       *
       * Note: Do not use getScrollElement here
       * because we need this to be a synchronous
       * operation, and getScrollElement is
       * asynchronous.
       */
      if ((0,_index_5d0c8232_js__WEBPACK_IMPORTED_MODULE_3__.i)(contentEl)) {
        const root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.g)(contentEl);
        scrollEl = root.querySelector('.inner-scroll');
      } else {
        scrollEl = contentEl;
      }

      const hasRefresherInContent = !!contentEl.querySelector('ion-refresher');
      return !hasRefresherInContent && scrollEl.scrollTop === 0;
    }
    /**
     * Card should be swipeable on all
     * parts of the modal except for the footer.
     */


    const footer = target.closest('ion-footer');

    if (footer === null) {
      return true;
    }

    return false;
  };

  const onStart = detail => {
    const {
      deltaY
    } = detail;
    /**
     * Get the initial scrollY value so
     * that we can correctly reset the scrollY
     * prop when the gesture ends.
     */

    initialScrollY = getScrollY();
    /**
     * If canDismiss is anything other than `true`
     * then users should be able to swipe down
     * until a threshold is hit. At that point,
     * the card modal should not proceed any further.
     * TODO (FW-937)
     * Remove undefined check
     */

    canDismissBlocksGesture = el.canDismiss !== undefined && el.canDismiss !== true;
    /**
     * If we are pulling down, then
     * it is possible we are pulling on the
     * content. We do not want scrolling to
     * happen at the same time as the gesture.
     */

    if (deltaY > 0 && contentEl) {
      (0,_index_5d0c8232_js__WEBPACK_IMPORTED_MODULE_3__.d)(contentEl);
    }

    animation.progressStart(true, isOpen ? 1 : 0);
  };

  const onMove = detail => {
    const {
      deltaY
    } = detail;
    /**
     * If we are pulling down, then
     * it is possible we are pulling on the
     * content. We do not want scrolling to
     * happen at the same time as the gesture.
     */

    if (deltaY > 0 && contentEl) {
      (0,_index_5d0c8232_js__WEBPACK_IMPORTED_MODULE_3__.d)(contentEl);
    }
    /**
     * If we are swiping on the content
     * then the swipe gesture should only
     * happen if we are pulling down.
     *
     * However, if we pull up and
     * then down such that the scroll position
     * returns to 0, we should be able to swipe
     * the card.
     */


    const step = detail.deltaY / height;
    /**
     * Check if user is swiping down and
     * if we have a canDismiss value that
     * should block the gesture from
     * proceeding,
     */

    const isAttempingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    /**
     * If we are blocking the gesture from dismissing,
     * set the max step value so that the sheet cannot be
     * completely hidden.
     */

    const maxStep = isAttempingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    /**
     * If we are blocking the gesture from
     * dismissing, calculate the spring modifier value
     * this will be added to the starting breakpoint
     * value to give the gesture a spring-like feeling.
     * Note that the starting breakpoint is always 0,
     * so we omit adding 0 to the result.
     */

    const processedStep = isAttempingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    const clampedStep = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.l)(0.0001, processedStep, maxStep);
    animation.progressStep(clampedStep);
    /**
     * When swiping down half way, the status bar style
     * should be reset to its default value.
     *
     * We track lastStep so that we do not fire these
     * functions on every onMove, only when the user has
     * crossed a certain threshold.
     */

    if (clampedStep >= DISMISS_THRESHOLD && lastStep < DISMISS_THRESHOLD) {
      setCardStatusBarDefault();
      /**
       * However, if we swipe back up, then the
       * status bar style should be set to have light
       * text on a dark background.
       */
    } else if (clampedStep < DISMISS_THRESHOLD && lastStep >= DISMISS_THRESHOLD) {
      setCardStatusBarDark();
    }

    lastStep = clampedStep;
  };

  const onEnd = detail => {
    const velocity = detail.velocityY;
    const step = detail.deltaY / height;
    const isAttempingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    const maxStep = isAttempingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttempingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    const clampedStep = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.l)(0.0001, processedStep, maxStep);
    const threshold = (detail.deltaY + velocity * 1000) / height;
    /**
     * If canDismiss blocks
     * the swipe gesture, then the
     * animation can never complete until
     * canDismiss is checked.
     */

    const shouldComplete = !isAttempingDismissWithCanDismiss && threshold >= DISMISS_THRESHOLD;
    let newStepValue = shouldComplete ? -0.001 : 0.001;

    if (!shouldComplete) {
      animation.easing('cubic-bezier(1, 0, 0.68, 0.28)');
      newStepValue += (0,_cubic_bezier_c313947a_js__WEBPACK_IMPORTED_MODULE_12__.g)([0, 0], [1, 0], [0.68, 0.28], [1, 1], clampedStep)[0];
    } else {
      animation.easing('cubic-bezier(0.32, 0.72, 0, 1)');
      newStepValue += (0,_cubic_bezier_c313947a_js__WEBPACK_IMPORTED_MODULE_12__.g)([0, 0], [0.32, 0.72], [0, 1], [1, 1], clampedStep)[0];
    }

    const duration = shouldComplete ? computeDuration(step * height, velocity) : computeDuration((1 - clampedStep) * height, velocity);
    isOpen = shouldComplete;
    gesture.enable(false);

    if (contentEl) {
      (0,_index_5d0c8232_js__WEBPACK_IMPORTED_MODULE_3__.r)(contentEl, initialScrollY);
    }

    animation.onFinish(() => {
      if (!shouldComplete) {
        gesture.enable(true);
      }
    }).progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);
    /**
     * If the canDismiss value blocked the gesture
     * from proceeding, then we should ignore whatever
     * shouldComplete is. Whether or not the modal
     * animation should complete is now determined by
     * canDismiss.
     *
     * If the user swiped >25% of the way
     * to the max step, then we should
     * check canDismiss. 25% was chosen
     * to avoid accidental swipes.
     */

    if (isAttempingDismissWithCanDismiss && clampedStep > maxStep / 4) {
      handleCanDismiss(el, animation);
    } else if (shouldComplete) {
      onDismiss();
    }
  };

  const gesture = (0,_index_f8d8aa5a_js__WEBPACK_IMPORTED_MODULE_13__.createGesture)({
    el,
    gestureName: 'modalSwipeToClose',
    gesturePriority: 39,
    direction: 'y',
    threshold: 10,
    canStart,
    onStart,
    onMove,
    onEnd
  });
  return gesture;
};

const computeDuration = (remaining, velocity) => {
  return (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.l)(400, remaining / Math.abs(velocity * 1.1), 500);
};

const createSheetEnterAnimation = opts => {
  const {
    currentBreakpoint,
    backdropBreakpoint
  } = opts;
  /**
   * If the backdropBreakpoint is undefined, then the backdrop
   * should always fade in. If the backdropBreakpoint came before the
   * current breakpoint, then the backdrop should be fading in.
   */

  const shouldShowBackdrop = backdropBreakpoint === undefined || backdropBreakpoint < currentBreakpoint;
  const initialBackdrop = shouldShowBackdrop ? `calc(var(--backdrop-opacity) * ${currentBreakpoint})` : '0';
  const backdropAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)('backdropAnimation').fromTo('opacity', 0, initialBackdrop);

  if (shouldShowBackdrop) {
    backdropAnimation.beforeStyles({
      'pointer-events': 'none'
    }).afterClearStyles(['pointer-events']);
  }

  const wrapperAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)('wrapperAnimation').keyframes([{
    offset: 0,
    opacity: 1,
    transform: 'translateY(100%)'
  }, {
    offset: 1,
    opacity: 1,
    transform: `translateY(${100 - currentBreakpoint * 100}%)`
  }]);
  return {
    wrapperAnimation,
    backdropAnimation
  };
};

const createSheetLeaveAnimation = opts => {
  const {
    currentBreakpoint,
    backdropBreakpoint
  } = opts;
  /**
   * Backdrop does not always fade in from 0 to 1 if backdropBreakpoint
   * is defined, so we need to account for that offset by figuring out
   * what the current backdrop value should be.
   */

  const backdropValue = `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint)})`;
  const defaultBackdrop = [{
    offset: 0,
    opacity: backdropValue
  }, {
    offset: 1,
    opacity: 0
  }];
  const customBackdrop = [{
    offset: 0,
    opacity: backdropValue
  }, {
    offset: backdropBreakpoint,
    opacity: 0
  }, {
    offset: 1,
    opacity: 0
  }];
  const backdropAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)('backdropAnimation').keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);
  const wrapperAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)('wrapperAnimation').keyframes([{
    offset: 0,
    opacity: 1,
    transform: `translateY(${100 - currentBreakpoint * 100}%)`
  }, {
    offset: 1,
    opacity: 1,
    transform: `translateY(100%)`
  }]);
  return {
    wrapperAnimation,
    backdropAnimation
  };
};

const createEnterAnimation$1 = () => {
  const backdropAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({
    'pointer-events': 'none'
  }).afterClearStyles(['pointer-events']);
  const wrapperAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().fromTo('transform', 'translateY(100vh)', 'translateY(0vh)');
  return {
    backdropAnimation,
    wrapperAnimation
  };
};
/**
 * iOS Modal Enter Animation for the Card presentation style
 */


const iosEnterAnimation = (baseEl, opts) => {
  const {
    presentingEl,
    currentBreakpoint
  } = opts;
  const root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.g)(baseEl);
  const {
    wrapperAnimation,
    backdropAnimation
  } = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation$1();
  backdropAnimation.addElement(root.querySelector('ion-backdrop'));
  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({
    opacity: 1
  });
  const baseAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)('entering-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(500).addAnimation(wrapperAnimation);

  if (presentingEl) {
    const isMobile = window.innerWidth < 768;
    const hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;
    const presentingElRoot = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.g)(presentingEl);
    const presentingAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().beforeStyles({
      transform: 'translateY(0)',
      'transform-origin': 'top center',
      overflow: 'hidden'
    });
    const bodyEl = document.body;

    if (isMobile) {
      /**
       * Fallback for browsers that does not support `max()` (ex: Firefox)
       * No need to worry about statusbar padding since engines like Gecko
       * are not used as the engine for standalone Cordova/Capacitor apps
       */
      const transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';
      const modalTransform = hasCardModal ? '-10px' : transformOffset;
      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;
      presentingAnimation.afterStyles({
        transform: finalTransform
      }).beforeAddWrite(() => bodyEl.style.setProperty('background-color', 'black')).addElement(presentingEl).keyframes([{
        offset: 0,
        filter: 'contrast(1)',
        transform: 'translateY(0px) scale(1)',
        borderRadius: '0px'
      }, {
        offset: 1,
        filter: 'contrast(0.85)',
        transform: finalTransform,
        borderRadius: '10px 10px 0 0'
      }]);
      baseAnimation.addAnimation(presentingAnimation);
    } else {
      baseAnimation.addAnimation(backdropAnimation);

      if (!hasCardModal) {
        wrapperAnimation.fromTo('opacity', '0', '1');
      } else {
        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
        const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;
        presentingAnimation.afterStyles({
          transform: finalTransform
        }).addElement(presentingElRoot.querySelector('.modal-wrapper')).keyframes([{
          offset: 0,
          filter: 'contrast(1)',
          transform: 'translateY(0) scale(1)'
        }, {
          offset: 1,
          filter: 'contrast(0.85)',
          transform: finalTransform
        }]);
        const shadowAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().afterStyles({
          transform: finalTransform
        }).addElement(presentingElRoot.querySelector('.modal-shadow')).keyframes([{
          offset: 0,
          opacity: '1',
          transform: 'translateY(0) scale(1)'
        }, {
          offset: 1,
          opacity: '0',
          transform: finalTransform
        }]);
        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation.addAnimation(backdropAnimation);
  }

  return baseAnimation;
};

const createLeaveAnimation$1 = () => {
  const backdropAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().fromTo('opacity', 'var(--backdrop-opacity)', 0);
  const wrapperAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().fromTo('transform', 'translateY(0vh)', 'translateY(100vh)');
  return {
    backdropAnimation,
    wrapperAnimation
  };
};
/**
 * iOS Modal Leave Animation
 */


const iosLeaveAnimation = (baseEl, opts, duration = 500) => {
  const {
    presentingEl,
    currentBreakpoint
  } = opts;
  const root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.g)(baseEl);
  const {
    wrapperAnimation,
    backdropAnimation
  } = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation$1();
  backdropAnimation.addElement(root.querySelector('ion-backdrop'));
  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({
    opacity: 1
  });
  const baseAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)('leaving-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(duration).addAnimation(wrapperAnimation);

  if (presentingEl) {
    const isMobile = window.innerWidth < 768;
    const hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;
    const presentingElRoot = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.g)(presentingEl);
    const presentingAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().beforeClearStyles(['transform']).afterClearStyles(['transform']).onFinish(currentStep => {
      // only reset background color if this is the last card-style modal
      if (currentStep !== 1) {
        return;
      }

      presentingEl.style.setProperty('overflow', '');
      const numModals = Array.from(bodyEl.querySelectorAll('ion-modal')).filter(m => m.presentingElement !== undefined).length;

      if (numModals <= 1) {
        bodyEl.style.setProperty('background-color', '');
      }
    });
    const bodyEl = document.body;

    if (isMobile) {
      const transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';
      const modalTransform = hasCardModal ? '-10px' : transformOffset;
      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;
      presentingAnimation.addElement(presentingEl).keyframes([{
        offset: 0,
        filter: 'contrast(0.85)',
        transform: finalTransform,
        borderRadius: '10px 10px 0 0'
      }, {
        offset: 1,
        filter: 'contrast(1)',
        transform: 'translateY(0px) scale(1)',
        borderRadius: '0px'
      }]);
      baseAnimation.addAnimation(presentingAnimation);
    } else {
      baseAnimation.addAnimation(backdropAnimation);

      if (!hasCardModal) {
        wrapperAnimation.fromTo('opacity', '1', '0');
      } else {
        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
        const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;
        presentingAnimation.addElement(presentingElRoot.querySelector('.modal-wrapper')).afterStyles({
          transform: 'translate3d(0, 0, 0)'
        }).keyframes([{
          offset: 0,
          filter: 'contrast(0.85)',
          transform: finalTransform
        }, {
          offset: 1,
          filter: 'contrast(1)',
          transform: 'translateY(0) scale(1)'
        }]);
        const shadowAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().addElement(presentingElRoot.querySelector('.modal-shadow')).afterStyles({
          transform: 'translateY(0) scale(1)'
        }).keyframes([{
          offset: 0,
          opacity: '0',
          transform: finalTransform
        }, {
          offset: 1,
          opacity: '1',
          transform: 'translateY(0) scale(1)'
        }]);
        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation.addAnimation(backdropAnimation);
  }

  return baseAnimation;
};

const createEnterAnimation = () => {
  const backdropAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({
    'pointer-events': 'none'
  }).afterClearStyles(['pointer-events']);
  const wrapperAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().keyframes([{
    offset: 0,
    opacity: 0.01,
    transform: 'translateY(40px)'
  }, {
    offset: 1,
    opacity: 1,
    transform: `translateY(0px)`
  }]);
  return {
    backdropAnimation,
    wrapperAnimation
  };
};
/**
 * Md Modal Enter Animation
 */


const mdEnterAnimation = (baseEl, opts) => {
  const {
    currentBreakpoint
  } = opts;
  const root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.g)(baseEl);
  const {
    wrapperAnimation,
    backdropAnimation
  } = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation();
  backdropAnimation.addElement(root.querySelector('ion-backdrop'));
  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));
  return (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().addElement(baseEl).easing('cubic-bezier(0.36,0.66,0.04,1)').duration(280).addAnimation([backdropAnimation, wrapperAnimation]);
};

const createLeaveAnimation = () => {
  const backdropAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().fromTo('opacity', 'var(--backdrop-opacity)', 0);
  const wrapperAnimation = (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().keyframes([{
    offset: 0,
    opacity: 0.99,
    transform: `translateY(0px)`
  }, {
    offset: 1,
    opacity: 0,
    transform: 'translateY(40px)'
  }]);
  return {
    backdropAnimation,
    wrapperAnimation
  };
};
/**
 * Md Modal Leave Animation
 */


const mdLeaveAnimation = (baseEl, opts) => {
  const {
    currentBreakpoint
  } = opts;
  const root = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.g)(baseEl);
  const {
    wrapperAnimation,
    backdropAnimation
  } = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation();
  backdropAnimation.addElement(root.querySelector('ion-backdrop'));
  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));
  return (0,_animation_2c50d24d_js__WEBPACK_IMPORTED_MODULE_11__.c)().easing('cubic-bezier(0.47,0,0.745,0.715)').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};

const createSheetGesture = (baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation, breakpoints = [], getCurrentBreakpoint, onDismiss, onBreakpointChange) => {
  // Defaults for the sheet swipe animation
  const defaultBackdrop = [{
    offset: 0,
    opacity: 'var(--backdrop-opacity)'
  }, {
    offset: 1,
    opacity: 0.01
  }];
  const customBackdrop = [{
    offset: 0,
    opacity: 'var(--backdrop-opacity)'
  }, {
    offset: 1 - backdropBreakpoint,
    opacity: 0
  }, {
    offset: 1,
    opacity: 0
  }];
  const SheetDefaults = {
    WRAPPER_KEYFRAMES: [{
      offset: 0,
      transform: 'translateY(0%)'
    }, {
      offset: 1,
      transform: 'translateY(100%)'
    }],
    BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop
  };
  const contentEl = baseEl.querySelector('ion-content');
  const height = wrapperEl.clientHeight;
  let currentBreakpoint = initialBreakpoint;
  let offset = 0;
  let canDismissBlocksGesture = false;
  const canDismissMaxStep = 0.95;
  const wrapperAnimation = animation.childAnimations.find(ani => ani.id === 'wrapperAnimation');
  const backdropAnimation = animation.childAnimations.find(ani => ani.id === 'backdropAnimation');
  const maxBreakpoint = breakpoints[breakpoints.length - 1];
  const minBreakpoint = breakpoints[0];

  const enableBackdrop = () => {
    baseEl.style.setProperty('pointer-events', 'auto');
    backdropEl.style.setProperty('pointer-events', 'auto');
    /**
     * When the backdrop is enabled, elements such
     * as inputs should not be focusable outside
     * the sheet.
     */

    baseEl.classList.remove('ion-disable-focus-trap');
  };

  const disableBackdrop = () => {
    baseEl.style.setProperty('pointer-events', 'none');
    backdropEl.style.setProperty('pointer-events', 'none');
    /**
     * When the backdrop is enabled, elements such
     * as inputs should not be focusable outside
     * the sheet.
     * Adding this class disables focus trapping
     * for the sheet temporarily.
     */

    baseEl.classList.add('ion-disable-focus-trap');
  };
  /**
   * After the entering animation completes,
   * we need to set the animation to go from
   * offset 0 to offset 1 so that users can
   * swipe in any direction. We then set the
   * animation offset to the current breakpoint
   * so there is no flickering.
   */


  if (wrapperAnimation && backdropAnimation) {
    wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);
    backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);
    animation.progressStart(true, 1 - currentBreakpoint);
    /**
     * If backdrop is not enabled, then content
     * behind modal should be clickable. To do this, we need
     * to remove pointer-events from ion-modal as a whole.
     * ion-backdrop and .modal-wrapper always have pointer-events: auto
     * applied, so the modal content can still be interacted with.
     */

    const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;

    if (shouldEnableBackdrop) {
      enableBackdrop();
    } else {
      disableBackdrop();
    }
  }

  if (contentEl && currentBreakpoint !== maxBreakpoint) {
    contentEl.scrollY = false;
  }

  const canStart = detail => {
    /**
     * If the sheet is fully expanded and
     * the user is swiping on the content,
     * the gesture should not start to
     * allow for scrolling on the content.
     */
    const content = detail.event.target.closest('ion-content');
    currentBreakpoint = getCurrentBreakpoint();

    if (currentBreakpoint === 1 && content) {
      return false;
    }

    return true;
  };

  const onStart = () => {
    /**
     * If canDismiss is anything other than `true`
     * then users should be able to swipe down
     * until a threshold is hit. At that point,
     * the card modal should not proceed any further.
     *
     * canDismiss is never fired via gesture if there is
     * no 0 breakpoint. However, it can be fired if the user
     * presses Esc or the hardware back button.
     * TODO (FW-937)
     * Remove undefined check
     */
    canDismissBlocksGesture = baseEl.canDismiss !== undefined && baseEl.canDismiss !== true && minBreakpoint === 0;
    /**
     * If swiping on the content
     * we should disable scrolling otherwise
     * the sheet will expand and the content will scroll.
     */

    if (contentEl) {
      contentEl.scrollY = false;
    }

    (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.r)(() => {
      /**
       * Dismisses the open keyboard when the sheet drag gesture is started.
       * Sets the focus onto the modal element.
       */
      baseEl.focus();
    });
    animation.progressStart(true, 1 - currentBreakpoint);
  };

  const onMove = detail => {
    /**
     * Given the change in gesture position on the Y axis,
     * compute where the offset of the animation should be
     * relative to where the user dragged.
     */
    const initialStep = 1 - currentBreakpoint;
    const secondToLastBreakpoint = breakpoints.length > 1 ? 1 - breakpoints[1] : undefined;
    const step = initialStep + detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = secondToLastBreakpoint !== undefined && step >= secondToLastBreakpoint && canDismissBlocksGesture;
    /**
     * If we are blocking the gesture from dismissing,
     * set the max step value so that the sheet cannot be
     * completely hidden.
     */

    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    /**
     * If we are blocking the gesture from
     * dismissing, calculate the spring modifier value
     * this will be added to the starting breakpoint
     * value to give the gesture a spring-like feeling.
     * Note that when isAttemptingDismissWithCanDismiss is true,
     * the modifier is always added to the breakpoint that
     * appears right after the 0 breakpoint.
     *
     * Note that this modifier is essentially the progression
     * between secondToLastBreakpoint and maxStep which is
     * why we subtract secondToLastBreakpoint. This lets us get
     * the result as a value from 0 to 1.
     */

    const processedStep = isAttemptingDismissWithCanDismiss && secondToLastBreakpoint !== undefined ? secondToLastBreakpoint + calculateSpringStep((step - secondToLastBreakpoint) / (maxStep - secondToLastBreakpoint)) : step;
    offset = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.l)(0.0001, processedStep, maxStep);
    animation.progressStep(offset);
  };

  const onEnd = detail => {
    /**
     * When the gesture releases, we need to determine
     * the closest breakpoint to snap to.
     */
    const velocity = detail.velocityY;
    const threshold = (detail.deltaY + velocity * 350) / height;
    const diff = currentBreakpoint - threshold;
    const closest = breakpoints.reduce((a, b) => {
      return Math.abs(b - diff) < Math.abs(a - diff) ? b : a;
    });
    moveSheetToBreakpoint({
      breakpoint: closest,
      breakpointOffset: offset,
      canDismiss: canDismissBlocksGesture
    });
  };

  const moveSheetToBreakpoint = options => {
    const {
      breakpoint,
      canDismiss,
      breakpointOffset
    } = options;
    /**
     * canDismiss should only prevent snapping
     * when users are trying to dismiss. If canDismiss
     * is present but the user is trying to swipe upwards,
     * we should allow that to happen,
     */

    const shouldPreventDismiss = canDismiss && breakpoint === 0;
    const snapToBreakpoint = shouldPreventDismiss ? currentBreakpoint : breakpoint;
    const shouldRemainOpen = snapToBreakpoint !== 0;
    currentBreakpoint = 0;
    /**
     * Update the animation so that it plays from
     * the last offset to the closest snap point.
     */

    if (wrapperAnimation && backdropAnimation) {
      wrapperAnimation.keyframes([{
        offset: 0,
        transform: `translateY(${breakpointOffset * 100}%)`
      }, {
        offset: 1,
        transform: `translateY(${(1 - snapToBreakpoint) * 100}%)`
      }]);
      backdropAnimation.keyframes([{
        offset: 0,
        opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(1 - breakpointOffset, backdropBreakpoint)})`
      }, {
        offset: 1,
        opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(snapToBreakpoint, backdropBreakpoint)})`
      }]);
      animation.progressStep(0);
    }
    /**
     * Gesture should remain disabled until the
     * snapping animation completes.
     */


    gesture.enable(false);

    if (shouldPreventDismiss) {
      handleCanDismiss(baseEl, animation);
    } else if (!shouldRemainOpen) {
      onDismiss();
    }

    return new Promise(resolve => {
      animation.onFinish(() => {
        if (shouldRemainOpen) {
          /**
           * Once the snapping animation completes,
           * we need to reset the animation to go
           * from 0 to 1 so users can swipe in any direction.
           * We then set the animation offset to the current
           * breakpoint so that it starts at the snapped position.
           */
          if (wrapperAnimation && backdropAnimation) {
            (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.r)(() => {
              wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);
              backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);
              animation.progressStart(true, 1 - snapToBreakpoint);
              currentBreakpoint = snapToBreakpoint;
              onBreakpointChange(currentBreakpoint);
              /**
               * If the sheet is fully expanded, we can safely
               * enable scrolling again.
               */

              if (contentEl && currentBreakpoint === breakpoints[breakpoints.length - 1]) {
                contentEl.scrollY = true;
              }
              /**
               * Backdrop should become enabled
               * after the backdropBreakpoint value
               */


              const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;

              if (shouldEnableBackdrop) {
                enableBackdrop();
              } else {
                disableBackdrop();
              }

              gesture.enable(true);
              resolve();
            });
          } else {
            gesture.enable(true);
            resolve();
          }
        } else {
          resolve();
        }
        /**
         * This must be a one time callback
         * otherwise a new callback will
         * be added every time onEnd runs.
         */

      }, {
        oneTimeCallback: true
      }).progressEnd(1, 0, 500);
    });
  };

  const gesture = (0,_index_f8d8aa5a_js__WEBPACK_IMPORTED_MODULE_13__.createGesture)({
    el: wrapperEl,
    gestureName: 'modalSheet',
    gesturePriority: 40,
    direction: 'y',
    threshold: 10,
    canStart,
    onStart,
    onMove,
    onEnd
  });
  return {
    gesture,
    moveSheetToBreakpoint
  };
};

const modalIosCss = ":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, #c0c0be);cursor:pointer;z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.modal-handle::before{padding-left:4px;padding-right:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:\"\"}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle::before{padding-left:unset;padding-right:unset;-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.4)}:host(.modal-card),:host(.modal-sheet){--border-radius:10px}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:10px}}.modal-wrapper{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0)}@media screen and (max-width: 767px){@supports (width: 1px){:host(.modal-card){--height:calc(100% - max(30px, var(--ion-safe-area-top)) - 10px)}}@supports not (width: 1px){:host(.modal-card){--height:calc(100% - 40px)}}:host(.modal-card) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-card) .modal-wrapper,:host-context([dir=rtl]).modal-card .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host(.modal-card){--backdrop-opacity:0;--width:100%;-ms-flex-align:end;align-items:flex-end}:host(.modal-card) .modal-shadow{display:none}:host(.modal-card) ion-backdrop{pointer-events:none}}@media screen and (min-width: 768px){:host(.modal-card){--width:calc(100% - 120px);--height:calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));--max-width:720px;--max-height:1000px;--backdrop-opacity:0;--box-shadow:0px 0px 30px 10px rgba(0, 0, 0, 0.1);-webkit-transition:all 0.5s ease-in-out;transition:all 0.5s ease-in-out}:host(.modal-card) .modal-wrapper{-webkit-box-shadow:none;box-shadow:none}:host(.modal-card) .modal-shadow{-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}}:host(.modal-sheet) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-sheet) .modal-wrapper,:host-context([dir=rtl]).modal-sheet .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}";
const modalMdCss = ":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, #c0c0be);cursor:pointer;z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.modal-handle::before{padding-left:4px;padding-right:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:\"\"}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle::before{padding-left:unset;padding-right:unset;-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:2px;--box-shadow:0 28px 48px rgba(0, 0, 0, 0.4)}}.modal-wrapper{-webkit-transform:translate3d(0,  40px,  0);transform:translate3d(0,  40px,  0);opacity:0.01}";
const Modal = class {
  constructor(hostRef) {
    (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    this.didPresent = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionModalDidPresent", 7);
    this.willPresent = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionModalWillPresent", 7);
    this.willDismiss = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionModalWillDismiss", 7);
    this.didDismiss = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionModalDidDismiss", 7);
    this.ionBreakpointDidChange = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "ionBreakpointDidChange", 7);
    this.didPresentShorthand = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "didPresent", 7);
    this.willPresentShorthand = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "willPresent", 7);
    this.willDismissShorthand = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "willDismiss", 7);
    this.didDismissShorthand = (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.e)(this, "didDismiss", 7);
    this.modalIndex = modalIds++;
    this.coreDelegate = (0,_framework_delegate_897f849d_js__WEBPACK_IMPORTED_MODULE_4__.C)();
    this.isSheetModal = false;
    this.inheritedAttributes = {};
    this.inline = false; // Whether or not modal is being dismissed via gesture

    this.gestureAnimationDismissing = false;
    this.presented = false;
    /** @internal */

    this.hasController = false;
    /**
     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
     */

    this.keyboardClose = true;
    /**
     * A decimal value between 0 and 1 that indicates the
     * point after which the backdrop will begin to fade in
     * when using a sheet modal. Prior to this point, the
     * backdrop will be hidden and the content underneath
     * the sheet can be interacted with. This value is exclusive
     * meaning the backdrop will become active after the value
     * specified.
     */

    this.backdropBreakpoint = 0;
    /**
     * The interaction behavior for the sheet modal when the handle is pressed.
     *
     * Defaults to `"none"`, which  means the modal will not change size or position when the handle is pressed.
     * Set to `"cycle"` to let the modal cycle between available breakpoints when pressed.
     *
     * Handle behavior is unavailable when the `handle` property is set to `false` or
     * when the `breakpoints` property is not set (using a fullscreen or card modal).
     */

    this.handleBehavior = 'none';
    /**
     * If `true`, the modal will be dismissed when the backdrop is clicked.
     */

    this.backdropDismiss = true;
    /**
     * If `true`, a backdrop will be displayed behind the modal.
     * This property controls whether or not the backdrop
     * darkens the screen when the modal is presented.
     * It does not control whether or not the backdrop
     * is active or present in the DOM.
     */

    this.showBackdrop = true;
    /**
     * If `true`, the modal will animate.
     */

    this.animated = true;
    /**
     * If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.
     * @deprecated - To prevent modals from dismissing, use canDismiss instead.
     */

    this.swipeToClose = false;
    /**
     * If `true`, the modal will open. If `false`, the modal will close.
     * Use this if you need finer grained control over presentation, otherwise
     * just use the modalController or the `trigger` property.
     * Note: `isOpen` will not automatically be set back to `false` when
     * the modal dismisses. You will need to do that in your code.
     */

    this.isOpen = false;
    /**
     * If `true`, the component passed into `ion-modal` will
     * automatically be mounted when the modal is created. The
     * component will remain mounted even when the modal is dismissed.
     * However, the component will be destroyed when the modal is
     * destroyed. This property is not reactive and should only be
     * used when initially creating a modal.
     *
     * Note: This feature only applies to inline modals in JavaScript
     * frameworks such as Angular, React, and Vue.
     */

    this.keepContentsMounted = false;

    this.configureTriggerInteraction = () => {
      const {
        trigger,
        el,
        destroyTriggerInteraction
      } = this;

      if (destroyTriggerInteraction) {
        destroyTriggerInteraction();
      }

      const triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;

      if (!triggerEl) {
        return;
      }

      const configureTriggerInteraction = (trigEl, modalEl) => {
        const openModal = () => {
          modalEl.present();
        };

        trigEl.addEventListener('click', openModal);
        return () => {
          trigEl.removeEventListener('click', openModal);
        };
      };

      this.destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);
    };

    this.onHandleClick = () => {
      const {
        sheetTransition,
        handleBehavior
      } = this;

      if (handleBehavior !== 'cycle' || sheetTransition !== undefined) {
        /**
         * The sheet modal should not advance to the next breakpoint
         * if the handle behavior is not `cycle` or if the handle
         * is clicked while the sheet is moving to a breakpoint.
         */
        return;
      }

      this.moveToNextBreakpoint();
    };

    this.onBackdropTap = () => {
      const {
        sheetTransition
      } = this;

      if (sheetTransition !== undefined) {
        /**
         * When the handle is double clicked at the largest breakpoint,
         * it will start to move to the first breakpoint. While transitioning,
         * the backdrop will often receive the second click. We prevent the
         * backdrop from dismissing the modal while moving between breakpoints.
         */
        return;
      }

      this.dismiss(undefined, _overlays_87c7c7cb_js__WEBPACK_IMPORTED_MODULE_8__.B);
    };

    this.onLifecycle = modalEvent => {
      const el = this.usersElement;
      const name = LIFECYCLE_MAP[modalEvent.type];

      if (el && name) {
        const ev = new CustomEvent(name, {
          bubbles: false,
          cancelable: false,
          detail: modalEvent.detail
        });
        el.dispatchEvent(ev);
      }
    };
  }

  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }

  onTriggerChange() {
    this.configureTriggerInteraction();
  }

  swipeToCloseChanged(enable) {
    var _this = this;

    return (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this.gesture) {
        _this.gesture.enable(enable);
      } else if (enable) {
        yield _this.initSwipeToClose();
      }
    })();
  }

  breakpointsChanged(breakpoints) {
    if (breakpoints !== undefined) {
      this.sortedBreakpoints = breakpoints.sort((a, b) => a - b);
    }
  }

  connectedCallback() {
    (0,_overlays_87c7c7cb_js__WEBPACK_IMPORTED_MODULE_8__.e)(this.el);
  }

  componentWillLoad() {
    const {
      breakpoints,
      initialBreakpoint,
      swipeToClose,
      el
    } = this;
    this.inheritedAttributes = (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.j)(el, ['role']);
    /**
     * If user has custom ID set then we should
     * not assign the default incrementing ID.
     */

    this.modalId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : `ion-modal-${this.modalIndex}`;
    const isSheetModal = this.isSheetModal = breakpoints !== undefined && initialBreakpoint !== undefined;

    if (isSheetModal) {
      this.currentBreakpoint = this.initialBreakpoint;
    }

    if (breakpoints !== undefined && initialBreakpoint !== undefined && !breakpoints.includes(initialBreakpoint)) {
      (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_7__.p)('Your breakpoints array must include the initialBreakpoint value.');
    }

    if (swipeToClose) {
      (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_7__.p)('swipeToClose has been deprecated in favor of canDismiss.\n\nIf you want a card modal to be swipeable, set canDismiss to `true`. In the next major release of Ionic, swipeToClose will be removed, and all card modals will be swipeable by default.');
    }
  }

  componentDidLoad() {
    /**
     * If modal was rendered with isOpen="true"
     * then we should open modal immediately.
     */
    if (this.isOpen === true) {
      (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.r)(() => this.present());
    }

    this.breakpointsChanged(this.breakpoints);
    this.configureTriggerInteraction();
  }
  /**
   * Determines whether or not an overlay
   * is being used inline or via a controller/JS
   * and returns the correct delegate.
   * By default, subsequent calls to getDelegate
   * will use a cached version of the delegate.
   * This is useful for calling dismiss after
   * present so that the correct delegate is given.
   */


  getDelegate(force = false) {
    if (this.workingDelegate && !force) {
      return {
        delegate: this.workingDelegate,
        inline: this.inline
      };
    }
    /**
     * If using overlay inline
     * we potentially need to use the coreDelegate
     * so that this works in vanilla JS apps.
     * If a developer has presented this component
     * via a controller, then we can assume
     * the component is already in the
     * correct place.
     */


    const parentEl = this.el.parentNode;
    const inline = this.inline = parentEl !== null && !this.hasController;
    const delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;
    return {
      inline,
      delegate
    };
  }
  /**
   * Determines whether or not the
   * modal is allowed to dismiss based
   * on the state of the canDismiss prop.
   */


  checkCanDismiss() {
    var _this2 = this;

    return (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const {
        canDismiss
      } = _this2;
      /**
       * TODO (FW-937) - Remove the following check in
       * the next major release of Ionic.
       */

      if (canDismiss === undefined) {
        return true;
      }

      if (typeof canDismiss === 'function') {
        return canDismiss();
      }

      return canDismiss;
    })();
  }
  /**
   * Present the modal overlay after it has been created.
   */


  present() {
    var _this3 = this;

    return (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this3.presented) {
        return;
      }
      /**
       * When using an inline modal
       * and dismissing a modal it is possible to
       * quickly present the modal while it is
       * dismissing. We need to await any current
       * transition to allow the dismiss to finish
       * before presenting again.
       */


      if (_this3.currentTransition !== undefined) {
        yield _this3.currentTransition;
      }
      /**
       * If the modal is presented multiple times (inline modals), we
       * need to reset the current breakpoint to the initial breakpoint.
       */


      _this3.currentBreakpoint = _this3.initialBreakpoint;
      const data = Object.assign(Object.assign({}, _this3.componentProps), {
        modal: _this3.el
      });

      const {
        inline,
        delegate
      } = _this3.getDelegate(true);

      _this3.usersElement = yield (0,_framework_delegate_897f849d_js__WEBPACK_IMPORTED_MODULE_4__.a)(delegate, _this3.el, _this3.component, ['ion-page'], data, inline);
      yield (0,_index_e6cecce9_js__WEBPACK_IMPORTED_MODULE_10__.e)(_this3.usersElement);
      (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.c)(() => _this3.el.classList.add('show-modal'));
      _this3.currentTransition = (0,_overlays_87c7c7cb_js__WEBPACK_IMPORTED_MODULE_8__.d)(_this3, 'modalEnter', iosEnterAnimation, mdEnterAnimation, {
        presentingEl: _this3.presentingElement,
        currentBreakpoint: _this3.initialBreakpoint,
        backdropBreakpoint: _this3.backdropBreakpoint
      });
      /**
       * TODO (FW-937) - In the next major release of Ionic, all card modals
       * will be swipeable by default. canDismiss will be used to determine if the
       * modal can be dismissed. This check should change to check the presence of
       * presentingElement instead.
       *
       * If we did not do this check, then not using swipeToClose would mean you could
       * not run canDismiss on swipe as there would be no swipe gesture created.
       */

      const hasCardModal = _this3.swipeToClose || _this3.canDismiss !== undefined && _this3.presentingElement !== undefined;
      /**
       * We need to change the status bar at the
       * start of the animation so that it completes
       * by the time the card animation is done.
       */

      if (hasCardModal && (0,_ionic_global_c95cf239_js__WEBPACK_IMPORTED_MODULE_2__.b)(_this3) === 'ios') {
        setCardStatusBarDark();
      }

      yield _this3.currentTransition;

      if (_this3.isSheetModal) {
        _this3.initSheetGesture();
      } else if (hasCardModal) {
        yield _this3.initSwipeToClose();
      }
      /* tslint:disable-next-line */


      if (typeof window !== 'undefined') {
        _this3.keyboardOpenCallback = () => {
          if (_this3.gesture) {
            /**
             * When the native keyboard is opened and the webview
             * is resized, the gesture implementation will become unresponsive
             * and enter a free-scroll mode.
             *
             * When the keyboard is opened, we disable the gesture for
             * a single frame and re-enable once the contents have repositioned
             * from the keyboard placement.
             */
            _this3.gesture.enable(false);

            (0,_helpers_3b390e48_js__WEBPACK_IMPORTED_MODULE_5__.r)(() => {
              if (_this3.gesture) {
                _this3.gesture.enable(true);
              }
            });
          }
        };

        window.addEventListener(_keyboard_4d5544a0_js__WEBPACK_IMPORTED_MODULE_6__.KEYBOARD_DID_OPEN, _this3.keyboardOpenCallback);
      }

      _this3.currentTransition = undefined;
    })();
  }

  initSwipeToClose() {
    var _this4 = this;

    if ((0,_ionic_global_c95cf239_js__WEBPACK_IMPORTED_MODULE_2__.b)(this) !== 'ios') {
      return;
    }

    const {
      el
    } = this; // All of the elements needed for the swipe gesture
    // should be in the DOM and referenced by now, except
    // for the presenting el

    const animationBuilder = this.leaveAnimation || _ionic_global_c95cf239_js__WEBPACK_IMPORTED_MODULE_2__.c.get('modalLeave', iosLeaveAnimation);
    const ani = this.animation = animationBuilder(el, {
      presentingEl: this.presentingElement
    });
    const contentEl = (0,_index_5d0c8232_js__WEBPACK_IMPORTED_MODULE_3__.a)(el);

    if (!contentEl) {
      (0,_index_5d0c8232_js__WEBPACK_IMPORTED_MODULE_3__.p)(el);
      return;
    }

    this.gesture = createSwipeToCloseGesture(el, ani, () => {
      /**
       * While the gesture animation is finishing
       * it is possible for a user to tap the backdrop.
       * This would result in the dismiss animation
       * being played again. Typically this is avoided
       * by setting `presented = false` on the overlay
       * component; however, we cannot do that here as
       * that would prevent the element from being
       * removed from the DOM.
       */
      this.gestureAnimationDismissing = true;
      this.animation.onFinish( /*#__PURE__*/(0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
        yield _this4.dismiss(undefined, 'gesture');
        _this4.gestureAnimationDismissing = false;
      }));
    });
    this.gesture.enable(true);
  }

  initSheetGesture() {
    const {
      wrapperEl,
      initialBreakpoint,
      backdropBreakpoint
    } = this;

    if (!wrapperEl || initialBreakpoint === undefined) {
      return;
    }

    const animationBuilder = this.enterAnimation || _ionic_global_c95cf239_js__WEBPACK_IMPORTED_MODULE_2__.c.get('modalEnter', iosEnterAnimation);
    const ani = this.animation = animationBuilder(this.el, {
      presentingEl: this.presentingElement,
      currentBreakpoint: initialBreakpoint,
      backdropBreakpoint
    });
    ani.progressStart(true, 1);
    const {
      gesture,
      moveSheetToBreakpoint
    } = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, this.sortedBreakpoints, () => {
      var _a;

      return (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : 0;
    }, () => this.sheetOnDismiss(), breakpoint => {
      if (this.currentBreakpoint !== breakpoint) {
        this.currentBreakpoint = breakpoint;
        this.ionBreakpointDidChange.emit({
          breakpoint
        });
      }
    });
    this.gesture = gesture;
    this.moveSheetToBreakpoint = moveSheetToBreakpoint;
    this.gesture.enable(true);
  }

  sheetOnDismiss() {
    var _this5 = this;

    /**
     * While the gesture animation is finishing
     * it is possible for a user to tap the backdrop.
     * This would result in the dismiss animation
     * being played again. Typically this is avoided
     * by setting `presented = false` on the overlay
     * component; however, we cannot do that here as
     * that would prevent the element from being
     * removed from the DOM.
     */
    this.gestureAnimationDismissing = true;
    this.animation.onFinish( /*#__PURE__*/(0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this5.currentBreakpoint = 0;

      _this5.ionBreakpointDidChange.emit({
        breakpoint: _this5.currentBreakpoint
      });

      yield _this5.dismiss(undefined, 'gesture');
      _this5.gestureAnimationDismissing = false;
    }));
  }
  /**
   * Dismiss the modal overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.
   */


  dismiss(data, role) {
    var _this6 = this;

    return (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      var _a;

      if (_this6.gestureAnimationDismissing && role !== 'gesture') {
        return false;
      }
      /**
       * If a canDismiss handler is responsible
       * for calling the dismiss method, we should
       * not run the canDismiss check again.
       */


      if (role !== 'handler' && !(yield _this6.checkCanDismiss())) {
        return false;
      }
      /**
       * We need to start the status bar change
       * before the animation so that the change
       * finishes when the dismiss animation does.
       * TODO (FW-937)
       */


      const hasCardModal = _this6.swipeToClose || _this6.canDismiss !== undefined && _this6.presentingElement !== undefined;

      if (hasCardModal && (0,_ionic_global_c95cf239_js__WEBPACK_IMPORTED_MODULE_2__.b)(_this6) === 'ios') {
        setCardStatusBarDefault();
      }
      /* tslint:disable-next-line */


      if (typeof window !== 'undefined' && _this6.keyboardOpenCallback) {
        window.removeEventListener(_keyboard_4d5544a0_js__WEBPACK_IMPORTED_MODULE_6__.KEYBOARD_DID_OPEN, _this6.keyboardOpenCallback);
      }
      /**
       * When using an inline modal
       * and presenting a modal it is possible to
       * quickly dismiss the modal while it is
       * presenting. We need to await any current
       * transition to allow the present to finish
       * before dismissing again.
       */


      if (_this6.currentTransition !== undefined) {
        yield _this6.currentTransition;
      }

      const enteringAnimation = _overlays_87c7c7cb_js__WEBPACK_IMPORTED_MODULE_8__.h.get(_this6) || [];
      _this6.currentTransition = (0,_overlays_87c7c7cb_js__WEBPACK_IMPORTED_MODULE_8__.f)(_this6, data, role, 'modalLeave', iosLeaveAnimation, mdLeaveAnimation, {
        presentingEl: _this6.presentingElement,
        currentBreakpoint: (_a = _this6.currentBreakpoint) !== null && _a !== void 0 ? _a : _this6.initialBreakpoint,
        backdropBreakpoint: _this6.backdropBreakpoint
      });
      const dismissed = yield _this6.currentTransition;

      if (dismissed) {
        const {
          delegate
        } = _this6.getDelegate();

        yield (0,_framework_delegate_897f849d_js__WEBPACK_IMPORTED_MODULE_4__.d)(delegate, _this6.usersElement);
        (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.c)(() => _this6.el.classList.remove('show-modal'));

        if (_this6.animation) {
          _this6.animation.destroy();
        }

        if (_this6.gesture) {
          _this6.gesture.destroy();
        }

        enteringAnimation.forEach(ani => ani.destroy());
      }

      _this6.currentBreakpoint = undefined;
      _this6.currentTransition = undefined;
      _this6.animation = undefined;
      return dismissed;
    })();
  }
  /**
   * Returns a promise that resolves when the modal did dismiss.
   */


  onDidDismiss() {
    return (0,_overlays_87c7c7cb_js__WEBPACK_IMPORTED_MODULE_8__.g)(this.el, 'ionModalDidDismiss');
  }
  /**
   * Returns a promise that resolves when the modal will dismiss.
   */


  onWillDismiss() {
    return (0,_overlays_87c7c7cb_js__WEBPACK_IMPORTED_MODULE_8__.g)(this.el, 'ionModalWillDismiss');
  }
  /**
   * Move a sheet style modal to a specific breakpoint. The breakpoint value must
   * be a value defined in your `breakpoints` array.
   */


  setCurrentBreakpoint(breakpoint) {
    var _this7 = this;

    return (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (!_this7.isSheetModal) {
        (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_7__.p)('setCurrentBreakpoint is only supported on sheet modals.');
        return;
      }

      if (!_this7.breakpoints.includes(breakpoint)) {
        (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_7__.p)(`Attempted to set invalid breakpoint value ${breakpoint}. Please double check that the breakpoint value is part of your defined breakpoints.`);
        return;
      }

      const {
        currentBreakpoint,
        moveSheetToBreakpoint,
        canDismiss,
        breakpoints
      } = _this7;

      if (currentBreakpoint === breakpoint) {
        return;
      }

      if (moveSheetToBreakpoint) {
        _this7.sheetTransition = moveSheetToBreakpoint({
          breakpoint,
          breakpointOffset: 1 - currentBreakpoint,
          canDismiss: canDismiss !== undefined && canDismiss !== true && breakpoints[0] === 0
        });
        yield _this7.sheetTransition;
        _this7.sheetTransition = undefined;
      }
    })();
  }
  /**
   * Returns the current breakpoint of a sheet style modal
   */


  getCurrentBreakpoint() {
    var _this8 = this;

    return (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this8.currentBreakpoint;
    })();
  }

  moveToNextBreakpoint() {
    var _this9 = this;

    return (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const {
        breakpoints,
        currentBreakpoint
      } = _this9;

      if (!breakpoints || currentBreakpoint == null) {
        /**
         * If the modal does not have breakpoints and/or the current
         * breakpoint is not set, we can't move to the next breakpoint.
         */
        return false;
      }

      const allowedBreakpoints = breakpoints.filter(b => b !== 0);
      const currentBreakpointIndex = allowedBreakpoints.indexOf(currentBreakpoint);
      const nextBreakpointIndex = (currentBreakpointIndex + 1) % allowedBreakpoints.length;
      const nextBreakpoint = allowedBreakpoints[nextBreakpointIndex];
      /**
       * Sets the current breakpoint to the next available breakpoint.
       * If the current breakpoint is the last breakpoint, we set the current
       * breakpoint to the first non-zero breakpoint to avoid dismissing the sheet.
       */

      yield _this9.setCurrentBreakpoint(nextBreakpoint);
      return true;
    })();
  }

  render() {
    const {
      handle,
      isSheetModal,
      presentingElement,
      htmlAttributes,
      handleBehavior,
      inheritedAttributes
    } = this;
    const showHandle = handle !== false && isSheetModal;
    const mode = (0,_ionic_global_c95cf239_js__WEBPACK_IMPORTED_MODULE_2__.b)(this);
    const {
      modalId
    } = this;
    const isCardModal = presentingElement !== undefined && mode === 'ios';
    const isHandleCycle = handleBehavior === 'cycle';
    return (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.h)(_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.H, Object.assign({
      "no-router": true,
      "aria-modal": "true",
      role: "dialog",
      tabindex: "-1"
    }, htmlAttributes, inheritedAttributes, {
      style: {
        zIndex: `${20000 + this.overlayIndex}`
      },
      class: Object.assign({
        [mode]: true,
        ['modal-default']: !isCardModal && !isSheetModal,
        [`modal-card`]: isCardModal,
        [`modal-sheet`]: isSheetModal,
        'overlay-hidden': true
      }, (0,_theme_7670341c_js__WEBPACK_IMPORTED_MODULE_9__.g)(this.cssClass)),
      id: modalId,
      onIonBackdropTap: this.onBackdropTap,
      onIonModalDidPresent: this.onLifecycle,
      onIonModalWillPresent: this.onLifecycle,
      onIonModalWillDismiss: this.onLifecycle,
      onIonModalDidDismiss: this.onLifecycle
    }), (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.h)("ion-backdrop", {
      ref: el => this.backdropEl = el,
      visible: this.showBackdrop,
      tappable: this.backdropDismiss,
      part: "backdrop"
    }), mode === 'ios' && (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "modal-shadow"
    }), (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "modal-wrapper ion-overlay-wrapper",
      part: "content",
      ref: el => this.wrapperEl = el
    }, showHandle && (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.h)("button", {
      class: "modal-handle",
      // Prevents the handle from receiving keyboard focus when it does not cycle
      tabIndex: !isHandleCycle ? -1 : 0,
      "aria-label": "Activate to adjust the size of the dialog overlaying the screen",
      onClick: isHandleCycle ? this.onHandleClick : undefined,
      part: "handle"
    }), (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", null)));
  }

  get el() {
    return (0,_index_8e692445_js__WEBPACK_IMPORTED_MODULE_1__.i)(this);
  }

  static get watchers() {
    return {
      "isOpen": ["onIsOpenChange"],
      "trigger": ["onTriggerChange"],
      "swipeToClose": ["swipeToCloseChanged"]
    };
  }

};
const LIFECYCLE_MAP = {
  ionModalDidPresent: 'ionViewDidEnter',
  ionModalWillPresent: 'ionViewWillEnter',
  ionModalWillDismiss: 'ionViewWillLeave',
  ionModalDidDismiss: 'ionViewDidLeave'
};
let modalIds = 0;
Modal.style = {
  ios: modalIosCss,
  md: modalMdCss
};


/***/ }),

/***/ 320:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/theme-7670341c.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ createColorClasses),
/* harmony export */   "g": () => (/* binding */ getClassMap),
/* harmony export */   "h": () => (/* binding */ hostContext),
/* harmony export */   "o": () => (/* binding */ openURL)
/* harmony export */ });
/* harmony import */ var C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 1670);


/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el) => {
  return el.closest(selector) !== null;
};
/**
 * Create the mode and color classes for the component based on the classes passed in
 */


const createColorClasses = (color, cssClassMap) => {
  return typeof color === 'string' && color.length > 0 ? Object.assign({
    'ion-color': true,
    [`ion-color-${color}`]: true
  }, cssClassMap) : cssClassMap;
};

const getClassList = classes => {
  if (classes !== undefined) {
    const array = Array.isArray(classes) ? classes : classes.split(' ');
    return array.filter(c => c != null).map(c => c.trim()).filter(c => c !== '');
  }

  return [];
};

const getClassMap = classes => {
  const map = {};
  getClassList(classes).forEach(c => map[c] = true);
  return map;
};

const SCHEME = /^[a-z][a-z0-9+\-.]*:/;

const openURL = /*#__PURE__*/function () {
  var _ref = (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url, ev, direction, animation) {
    if (url != null && url[0] !== '#' && !SCHEME.test(url)) {
      const router = document.querySelector('ion-router');

      if (router) {
        if (ev != null) {
          ev.preventDefault();
        }

        return router.push(url, direction, animation);
      }
    }

    return false;
  });

  return function openURL(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2lvbmljX2NvcmVfZGlzdF9lc21faW9uLW1vZGFsX2VudHJ5X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxlQUFlLEdBQUcsQ0FBQ0MsT0FBRCxFQUFVLEdBQUdDLE1BQWIsS0FBd0I7RUFDOUMsT0FBT0MsT0FBTyxDQUFDQyxJQUFSLENBQWMsb0JBQW1CSCxPQUFRLEVBQXpDLEVBQTRDLEdBQUdDLE1BQS9DLENBQVA7QUFDRCxDQUZEO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1HLGFBQWEsR0FBRyxDQUFDSixPQUFELEVBQVUsR0FBR0MsTUFBYixLQUF3QjtFQUM1QyxPQUFPQyxPQUFPLENBQUNHLEtBQVIsQ0FBZSxrQkFBaUJMLE9BQVEsRUFBeEMsRUFBMkMsR0FBR0MsTUFBOUMsQ0FBUDtBQUNELENBRkQ7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTUsseUJBQXlCLEdBQUcsQ0FBQ0MsRUFBRCxFQUFLLEdBQUdDLGVBQVIsS0FBNEI7RUFDNUQsT0FBT04sT0FBTyxDQUFDRyxLQUFSLENBQWUsSUFBR0UsRUFBRSxDQUFDRSxPQUFILENBQVdDLFdBQVgsRUFBeUIseUJBQXdCRixlQUFlLENBQUNHLElBQWhCLENBQXFCLE1BQXJCLENBQTZCLEdBQWhHLENBQVA7QUFDRCxDQUZEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLElBQUltRCxLQUFKOztBQUNBLENBQUMsVUFBVUEsS0FBVixFQUFpQjtFQUNoQkEsS0FBSyxDQUFDLE1BQUQsQ0FBTCxHQUFnQixNQUFoQjtFQUNBQSxLQUFLLENBQUMsT0FBRCxDQUFMLEdBQWlCLE9BQWpCO0VBQ0FBLEtBQUssQ0FBQyxTQUFELENBQUwsR0FBbUIsU0FBbkI7QUFDRCxDQUpELEVBSUdBLEtBQUssS0FBS0EsS0FBSyxHQUFHLEVBQWIsQ0FKUjs7QUFLQSxNQUFNQyxTQUFTLEdBQUc7RUFDaEJDLFNBQVMsR0FBRztJQUNWLElBQUlDLEVBQUo7O0lBQ0EsT0FBTyxDQUFDLENBQUNBLEVBQUUsR0FBR0osa0RBQUcsS0FBSyxJQUFSLElBQWdCQSxrREFBRyxLQUFLLEtBQUssQ0FBN0IsR0FBaUMsS0FBSyxDQUF0QyxHQUEwQ0EsNERBQWhELE1BQW1FLElBQW5FLElBQTJFSSxFQUFFLEtBQUssS0FBSyxDQUF2RixHQUEyRixLQUFLLENBQWhHLEdBQW9HQSxFQUFFLENBQUNFLGlCQUFILENBQXFCLFdBQXJCLENBQXJHLE1BQTRJTixrREFBRyxLQUFLLElBQVIsSUFBZ0JBLGtEQUFHLEtBQUssS0FBSyxDQUE3QixHQUFpQyxLQUFLLENBQXRDLEdBQTBDQSw4RUFBdEwsQ0FBUDtFQUNELENBSmU7O0VBS2hCUSw2QkFBNkIsR0FBRztJQUM5QixJQUFJSixFQUFKO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7SUFDSSxPQUFPLENBQUMsRUFBRSxDQUFDQSxFQUFFLEdBQUdKLGtEQUFHLEtBQUssSUFBUixJQUFnQkEsa0RBQUcsS0FBSyxLQUFLLENBQTdCLEdBQWlDLEtBQUssQ0FBdEMsR0FBMENBLDREQUFoRCxNQUFtRSxJQUFuRSxJQUEyRUksRUFBRSxLQUFLLEtBQUssQ0FBdkYsR0FBMkYsS0FBSyxDQUFoRyxHQUFvR0EsRUFBRSxDQUFDSyxhQUF6RyxDQUFSO0VBQ0QsQ0FkZTs7RUFlaEJDLFFBQVEsQ0FBQ0MsT0FBRCxFQUFVO0lBQ2hCLE1BQU1DLE1BQU0sR0FBRyxLQUFLVCxTQUFMLEVBQWY7O0lBQ0EsSUFBSSxDQUFDUyxNQUFMLEVBQWE7TUFDWDtJQUNEOztJQUNEQSxNQUFNLENBQUNGLFFBQVAsQ0FBZ0JDLE9BQWhCO0VBQ0Q7O0FBckJlLENBQWxCO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTUUsd0JBQXdCLEdBQUcsQ0FBQ0MsQ0FBRCxFQUFJQyxrQkFBSixLQUEyQjtFQUMxRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJQSxrQkFBa0IsS0FBSyxDQUEzQixFQUE4QjtJQUM1QixPQUFPLENBQVA7RUFDRDs7RUFDRCxNQUFNQyxLQUFLLEdBQUcsS0FBSyxJQUFJRCxrQkFBVCxDQUFkO0VBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0VBQ0UsTUFBTS9ELENBQUMsR0FBRyxFQUFFK0Qsa0JBQWtCLEdBQUdDLEtBQXZCLENBQVY7RUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztFQUNFLE9BQU9GLENBQUMsR0FBR0UsS0FBSixHQUFZaEUsQ0FBbkI7QUFDRCxDQTlDRDtBQStDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1pRSxvQkFBb0IsR0FBRyxNQUFNO0VBQ2pDLElBQUksQ0FBQ2pCLGtEQUFELElBQVFBLDZEQUFBLElBQWtCLEdBQTFCLElBQWlDLENBQUNFLFNBQVMsQ0FBQ00sNkJBQVYsRUFBdEMsRUFBaUY7SUFDL0U7RUFDRDs7RUFDRE4sU0FBUyxDQUFDUSxRQUFWLENBQW1CO0lBQUVTLEtBQUssRUFBRWxCLEtBQUssQ0FBQ21CO0VBQWYsQ0FBbkI7QUFDRCxDQUxEOztBQU1BLE1BQU1DLHVCQUF1QixHQUFHLE1BQU07RUFDcEMsSUFBSSxDQUFDckIsa0RBQUQsSUFBUUEsNkRBQUEsSUFBa0IsR0FBMUIsSUFBaUMsQ0FBQ0UsU0FBUyxDQUFDTSw2QkFBVixFQUF0QyxFQUFpRjtJQUMvRTtFQUNEOztFQUNETixTQUFTLENBQUNRLFFBQVYsQ0FBbUI7SUFBRVMsS0FBSyxFQUFFbEIsS0FBSyxDQUFDcUI7RUFBZixDQUFuQjtBQUNELENBTEQ7O0FBT0EsTUFBTUMsZ0JBQWdCO0VBQUEsd0pBQUcsV0FBTzdFLEVBQVAsRUFBVzhFLFNBQVgsRUFBeUI7SUFDaEQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNFLElBQUksT0FBTzlFLEVBQUUsQ0FBQytFLFVBQVYsS0FBeUIsVUFBN0IsRUFBeUM7TUFDdkM7SUFDRDtJQUNEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztJQUNFLE1BQU1DLGFBQWEsU0FBU2hGLEVBQUUsQ0FBQytFLFVBQUgsRUFBNUI7O0lBQ0EsSUFBSSxDQUFDQyxhQUFMLEVBQW9CO01BQ2xCO0lBQ0Q7SUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0lBQ0UsSUFBSUYsU0FBUyxDQUFDRyxTQUFWLEVBQUosRUFBMkI7TUFDekJILFNBQVMsQ0FBQ0ksUUFBVixDQUFtQixNQUFNO1FBQ3ZCbEYsRUFBRSxDQUFDOEMsT0FBSCxDQUFXcUMsU0FBWCxFQUFzQixTQUF0QjtNQUNELENBRkQsRUFFRztRQUFFQyxlQUFlLEVBQUU7TUFBbkIsQ0FGSDtJQUdELENBSkQsTUFLSztNQUNIcEYsRUFBRSxDQUFDOEMsT0FBSCxDQUFXcUMsU0FBWCxFQUFzQixTQUF0QjtJQUNEO0VBQ0YsQ0F2Q3FCOztFQUFBLGdCQUFoQk4sZ0JBQWdCO0lBQUE7RUFBQTtBQUFBLEdBQXRCO0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTVEsbUJBQW1CLEdBQUlDLENBQUQsSUFBTztFQUNqQyxPQUFPLGFBQWEsWUFBWSxDQUFDLE9BQUQsR0FBV0EsQ0FBdkIsQ0FBYixHQUF5QyxVQUFVLFlBQVksQ0FBQyxTQUFELEdBQWFBLENBQXpCLENBQW5ELEdBQWlGLENBQXhGO0FBQ0QsQ0FGRCxFQUlBOzs7QUFDQSxNQUFNQyxvQkFBb0IsR0FBRztFQUMzQkMsb0JBQW9CLEVBQUU7QUFESyxDQUE3Qjs7QUFHQSxNQUFNQyx5QkFBeUIsR0FBRyxDQUFDekYsRUFBRCxFQUFLOEUsU0FBTCxFQUFnQlksU0FBaEIsS0FBOEI7RUFDOUQ7QUFDRjtBQUNBO0FBQ0E7RUFDRSxNQUFNQyxpQkFBaUIsR0FBRyxHQUExQjtFQUNBLE1BQU1DLE1BQU0sR0FBRzVGLEVBQUUsQ0FBQzZGLFlBQWxCO0VBQ0EsSUFBSUMsTUFBTSxHQUFHLEtBQWI7RUFDQSxJQUFJQyx1QkFBdUIsR0FBRyxLQUE5QjtFQUNBLElBQUlDLFNBQVMsR0FBRyxJQUFoQjtFQUNBLElBQUlDLFFBQVEsR0FBRyxJQUFmO0VBQ0EsTUFBTUMsaUJBQWlCLEdBQUcsR0FBMUI7RUFDQSxJQUFJQyxjQUFjLEdBQUcsSUFBckI7RUFDQSxJQUFJQyxRQUFRLEdBQUcsQ0FBZjs7RUFDQSxNQUFNQyxVQUFVLEdBQUcsTUFBTTtJQUN2QixJQUFJTCxTQUFTLElBQUl6RSxxREFBWSxDQUFDeUUsU0FBRCxDQUE3QixFQUEwQztNQUN4QyxPQUFPQSxTQUFTLENBQUNNLE9BQWpCO01BQ0E7QUFDTjtBQUNBO0FBQ0E7QUFDQTtJQUNLLENBUEQsTUFRSztNQUNILE9BQU8sSUFBUDtJQUNEO0VBQ0YsQ0FaRDs7RUFhQSxNQUFNQyxRQUFRLEdBQUlDLE1BQUQsSUFBWTtJQUMzQixNQUFNQyxNQUFNLEdBQUdELE1BQU0sQ0FBQ0UsS0FBUCxDQUFhRCxNQUE1Qjs7SUFDQSxJQUFJQSxNQUFNLEtBQUssSUFBWCxJQUFtQixDQUFDQSxNQUFNLENBQUNFLE9BQS9CLEVBQXdDO01BQ3RDLE9BQU8sSUFBUDtJQUNEO0lBQ0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7SUFDSVgsU0FBUyxHQUFHMUUscURBQXFCLENBQUNtRixNQUFELENBQWpDOztJQUNBLElBQUlULFNBQUosRUFBZTtNQUNiO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7TUFDTSxJQUFJekUscURBQVksQ0FBQ3lFLFNBQUQsQ0FBaEIsRUFBNkI7UUFDM0IsTUFBTVksSUFBSSxHQUFHMUUsdURBQWMsQ0FBQzhELFNBQUQsQ0FBM0I7UUFDQUMsUUFBUSxHQUFHVyxJQUFJLENBQUNDLGFBQUwsQ0FBbUIsZUFBbkIsQ0FBWDtNQUNELENBSEQsTUFJSztRQUNIWixRQUFRLEdBQUdELFNBQVg7TUFDRDs7TUFDRCxNQUFNYyxxQkFBcUIsR0FBRyxDQUFDLENBQUNkLFNBQVMsQ0FBQ2EsYUFBVixDQUF3QixlQUF4QixDQUFoQztNQUNBLE9BQU8sQ0FBQ0MscUJBQUQsSUFBMEJiLFFBQVEsQ0FBQ2MsU0FBVCxLQUF1QixDQUF4RDtJQUNEO0lBQ0Q7QUFDSjtBQUNBO0FBQ0E7OztJQUNJLE1BQU1DLE1BQU0sR0FBR1AsTUFBTSxDQUFDRSxPQUFQLENBQWUsWUFBZixDQUFmOztJQUNBLElBQUlLLE1BQU0sS0FBSyxJQUFmLEVBQXFCO01BQ25CLE9BQU8sSUFBUDtJQUNEOztJQUNELE9BQU8sS0FBUDtFQUNELENBdkREOztFQXdEQSxNQUFNQyxPQUFPLEdBQUlULE1BQUQsSUFBWTtJQUMxQixNQUFNO01BQUVVO0lBQUYsSUFBYVYsTUFBbkI7SUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztJQUNJTCxjQUFjLEdBQUdFLFVBQVUsRUFBM0I7SUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJTix1QkFBdUIsR0FBRy9GLEVBQUUsQ0FBQytFLFVBQUgsS0FBa0JJLFNBQWxCLElBQStCbkYsRUFBRSxDQUFDK0UsVUFBSCxLQUFrQixJQUEzRTtJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFDSSxJQUFJbUMsTUFBTSxHQUFHLENBQVQsSUFBY2xCLFNBQWxCLEVBQTZCO01BQzNCdkUscURBQXFCLENBQUN1RSxTQUFELENBQXJCO0lBQ0Q7O0lBQ0RsQixTQUFTLENBQUNxQyxhQUFWLENBQXdCLElBQXhCLEVBQThCckIsTUFBTSxHQUFHLENBQUgsR0FBTyxDQUEzQztFQUNELENBM0JEOztFQTRCQSxNQUFNc0IsTUFBTSxHQUFJWixNQUFELElBQVk7SUFDekIsTUFBTTtNQUFFVTtJQUFGLElBQWFWLE1BQW5CO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJLElBQUlVLE1BQU0sR0FBRyxDQUFULElBQWNsQixTQUFsQixFQUE2QjtNQUMzQnZFLHFEQUFxQixDQUFDdUUsU0FBRCxDQUFyQjtJQUNEO0lBQ0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztJQUNJLE1BQU1xQixJQUFJLEdBQUdiLE1BQU0sQ0FBQ1UsTUFBUCxHQUFnQnRCLE1BQTdCO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJLE1BQU0wQixnQ0FBZ0MsR0FBR0QsSUFBSSxJQUFJLENBQVIsSUFBYXRCLHVCQUF0RDtJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0lBQ0ksTUFBTXdCLE9BQU8sR0FBR0QsZ0NBQWdDLEdBQUdwQixpQkFBSCxHQUF1QixNQUF2RTtJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0lBQ0ksTUFBTXNCLGFBQWEsR0FBR0YsZ0NBQWdDLEdBQUdqQyxtQkFBbUIsQ0FBQ2dDLElBQUksR0FBR0UsT0FBUixDQUF0QixHQUF5Q0YsSUFBL0Y7SUFDQSxNQUFNSSxXQUFXLEdBQUdyRix1REFBSyxDQUFDLE1BQUQsRUFBU29GLGFBQVQsRUFBd0JELE9BQXhCLENBQXpCO0lBQ0F6QyxTQUFTLENBQUM0QyxZQUFWLENBQXVCRCxXQUF2QjtJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0lBQ0ksSUFBSUEsV0FBVyxJQUFJOUIsaUJBQWYsSUFBb0NTLFFBQVEsR0FBR1QsaUJBQW5ELEVBQXNFO01BQ3BFaEIsdUJBQXVCO01BQ3ZCO0FBQ047QUFDQTtBQUNBO0FBQ0E7SUFDSyxDQVBELE1BUUssSUFBSThDLFdBQVcsR0FBRzlCLGlCQUFkLElBQW1DUyxRQUFRLElBQUlULGlCQUFuRCxFQUFzRTtNQUN6RXBCLG9CQUFvQjtJQUNyQjs7SUFDRDZCLFFBQVEsR0FBR3FCLFdBQVg7RUFDRCxDQWxFRDs7RUFtRUEsTUFBTUUsS0FBSyxHQUFJbkIsTUFBRCxJQUFZO0lBQ3hCLE1BQU1vQixRQUFRLEdBQUdwQixNQUFNLENBQUNxQixTQUF4QjtJQUNBLE1BQU1SLElBQUksR0FBR2IsTUFBTSxDQUFDVSxNQUFQLEdBQWdCdEIsTUFBN0I7SUFDQSxNQUFNMEIsZ0NBQWdDLEdBQUdELElBQUksSUFBSSxDQUFSLElBQWF0Qix1QkFBdEQ7SUFDQSxNQUFNd0IsT0FBTyxHQUFHRCxnQ0FBZ0MsR0FBR3BCLGlCQUFILEdBQXVCLE1BQXZFO0lBQ0EsTUFBTXNCLGFBQWEsR0FBR0YsZ0NBQWdDLEdBQUdqQyxtQkFBbUIsQ0FBQ2dDLElBQUksR0FBR0UsT0FBUixDQUF0QixHQUF5Q0YsSUFBL0Y7SUFDQSxNQUFNSSxXQUFXLEdBQUdyRix1REFBSyxDQUFDLE1BQUQsRUFBU29GLGFBQVQsRUFBd0JELE9BQXhCLENBQXpCO0lBQ0EsTUFBTU8sU0FBUyxHQUFHLENBQUN0QixNQUFNLENBQUNVLE1BQVAsR0FBZ0JVLFFBQVEsR0FBRyxJQUE1QixJQUFvQ2hDLE1BQXREO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJLE1BQU1tQyxjQUFjLEdBQUcsQ0FBQ1QsZ0NBQUQsSUFBcUNRLFNBQVMsSUFBSW5DLGlCQUF6RTtJQUNBLElBQUlxQyxZQUFZLEdBQUdELGNBQWMsR0FBRyxDQUFDLEtBQUosR0FBWSxLQUE3Qzs7SUFDQSxJQUFJLENBQUNBLGNBQUwsRUFBcUI7TUFDbkJqRCxTQUFTLENBQUNtRCxNQUFWLENBQWlCLGdDQUFqQjtNQUNBRCxZQUFZLElBQUk3RSw2REFBdUIsQ0FBQyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQUQsRUFBUyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVQsRUFBaUIsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFqQixFQUErQixDQUFDLENBQUQsRUFBSSxDQUFKLENBQS9CLEVBQXVDc0UsV0FBdkMsQ0FBdkIsQ0FBMkUsQ0FBM0UsQ0FBaEI7SUFDRCxDQUhELE1BSUs7TUFDSDNDLFNBQVMsQ0FBQ21ELE1BQVYsQ0FBaUIsZ0NBQWpCO01BQ0FELFlBQVksSUFBSTdFLDZEQUF1QixDQUFDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBRCxFQUFTLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBVCxFQUF1QixDQUFDLENBQUQsRUFBSSxDQUFKLENBQXZCLEVBQStCLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBL0IsRUFBdUNzRSxXQUF2QyxDQUF2QixDQUEyRSxDQUEzRSxDQUFoQjtJQUNEOztJQUNELE1BQU1TLFFBQVEsR0FBR0gsY0FBYyxHQUMzQkksZUFBZSxDQUFDZCxJQUFJLEdBQUd6QixNQUFSLEVBQWdCZ0MsUUFBaEIsQ0FEWSxHQUUzQk8sZUFBZSxDQUFDLENBQUMsSUFBSVYsV0FBTCxJQUFvQjdCLE1BQXJCLEVBQTZCZ0MsUUFBN0IsQ0FGbkI7SUFHQTlCLE1BQU0sR0FBR2lDLGNBQVQ7SUFDQUssT0FBTyxDQUFDQyxNQUFSLENBQWUsS0FBZjs7SUFDQSxJQUFJckMsU0FBSixFQUFlO01BQ2J0RSxxREFBbUIsQ0FBQ3NFLFNBQUQsRUFBWUcsY0FBWixDQUFuQjtJQUNEOztJQUNEckIsU0FBUyxDQUNOSSxRQURILENBQ1ksTUFBTTtNQUNoQixJQUFJLENBQUM2QyxjQUFMLEVBQXFCO1FBQ25CSyxPQUFPLENBQUNDLE1BQVIsQ0FBZSxJQUFmO01BQ0Q7SUFDRixDQUxELEVBTUdDLFdBTkgsQ0FNZVAsY0FBYyxHQUFHLENBQUgsR0FBTyxDQU5wQyxFQU11Q0MsWUFOdkMsRUFNcURFLFFBTnJEO0lBT0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJLElBQUlaLGdDQUFnQyxJQUFJRyxXQUFXLEdBQUdGLE9BQU8sR0FBRyxDQUFoRSxFQUFtRTtNQUNqRTFDLGdCQUFnQixDQUFDN0UsRUFBRCxFQUFLOEUsU0FBTCxDQUFoQjtJQUNELENBRkQsTUFHSyxJQUFJaUQsY0FBSixFQUFvQjtNQUN2QnJDLFNBQVM7SUFDVjtFQUNGLENBekREOztFQTBEQSxNQUFNMEMsT0FBTyxHQUFHaEYsa0VBQWEsQ0FBQztJQUM1QnBELEVBRDRCO0lBRTVCdUksV0FBVyxFQUFFLG1CQUZlO0lBRzVCQyxlQUFlLEVBQUUsRUFIVztJQUk1QkMsU0FBUyxFQUFFLEdBSmlCO0lBSzVCWCxTQUFTLEVBQUUsRUFMaUI7SUFNNUJ2QixRQU40QjtJQU81QlUsT0FQNEI7SUFRNUJHLE1BUjRCO0lBUzVCTztFQVQ0QixDQUFELENBQTdCO0VBV0EsT0FBT1MsT0FBUDtBQUNELENBeFBEOztBQXlQQSxNQUFNRCxlQUFlLEdBQUcsQ0FBQ08sU0FBRCxFQUFZZCxRQUFaLEtBQXlCO0VBQy9DLE9BQU94Rix1REFBSyxDQUFDLEdBQUQsRUFBTXNHLFNBQVMsR0FBR0MsSUFBSSxDQUFDQyxHQUFMLENBQVNoQixRQUFRLEdBQUcsR0FBcEIsQ0FBbEIsRUFBNEMsR0FBNUMsQ0FBWjtBQUNELENBRkQ7O0FBSUEsTUFBTWlCLHlCQUF5QixHQUFJQyxJQUFELElBQVU7RUFDMUMsTUFBTTtJQUFFQyxpQkFBRjtJQUFxQjFFO0VBQXJCLElBQTRDeUUsSUFBbEQ7RUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztFQUNFLE1BQU1FLGtCQUFrQixHQUFHM0Usa0JBQWtCLEtBQUtjLFNBQXZCLElBQW9DZCxrQkFBa0IsR0FBRzBFLGlCQUFwRjtFQUNBLE1BQU1FLGVBQWUsR0FBR0Qsa0JBQWtCLEdBQUksa0NBQWlDRCxpQkFBa0IsR0FBdkQsR0FBNEQsR0FBdEc7RUFDQSxNQUFNRyxpQkFBaUIsR0FBR2hHLDBEQUFlLENBQUMsbUJBQUQsQ0FBZixDQUFxQ2lHLE1BQXJDLENBQTRDLFNBQTVDLEVBQXVELENBQXZELEVBQTBERixlQUExRCxDQUExQjs7RUFDQSxJQUFJRCxrQkFBSixFQUF3QjtJQUN0QkUsaUJBQWlCLENBQ2RFLFlBREgsQ0FDZ0I7TUFDZCxrQkFBa0I7SUFESixDQURoQixFQUlHQyxnQkFKSCxDQUlvQixDQUFDLGdCQUFELENBSnBCO0VBS0Q7O0VBQ0QsTUFBTUMsZ0JBQWdCLEdBQUdwRywwREFBZSxDQUFDLGtCQUFELENBQWYsQ0FBb0NxRyxTQUFwQyxDQUE4QyxDQUNyRTtJQUFFQyxNQUFNLEVBQUUsQ0FBVjtJQUFhQyxPQUFPLEVBQUUsQ0FBdEI7SUFBeUJDLFNBQVMsRUFBRTtFQUFwQyxDQURxRSxFQUVyRTtJQUFFRixNQUFNLEVBQUUsQ0FBVjtJQUFhQyxPQUFPLEVBQUUsQ0FBdEI7SUFBeUJDLFNBQVMsRUFBRyxjQUFhLE1BQU1YLGlCQUFpQixHQUFHLEdBQUk7RUFBaEYsQ0FGcUUsQ0FBOUMsQ0FBekI7RUFJQSxPQUFPO0lBQUVPLGdCQUFGO0lBQW9CSjtFQUFwQixDQUFQO0FBQ0QsQ0F0QkQ7O0FBdUJBLE1BQU1TLHlCQUF5QixHQUFJYixJQUFELElBQVU7RUFDMUMsTUFBTTtJQUFFQyxpQkFBRjtJQUFxQjFFO0VBQXJCLElBQTRDeUUsSUFBbEQ7RUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztFQUNFLE1BQU1jLGFBQWEsR0FBSSxrQ0FBaUN6Rix3QkFBd0IsQ0FBQzRFLGlCQUFELEVBQW9CMUUsa0JBQXBCLENBQXdDLEdBQXhIO0VBQ0EsTUFBTXdGLGVBQWUsR0FBRyxDQUN0QjtJQUFFTCxNQUFNLEVBQUUsQ0FBVjtJQUFhQyxPQUFPLEVBQUVHO0VBQXRCLENBRHNCLEVBRXRCO0lBQUVKLE1BQU0sRUFBRSxDQUFWO0lBQWFDLE9BQU8sRUFBRTtFQUF0QixDQUZzQixDQUF4QjtFQUlBLE1BQU1LLGNBQWMsR0FBRyxDQUNyQjtJQUFFTixNQUFNLEVBQUUsQ0FBVjtJQUFhQyxPQUFPLEVBQUVHO0VBQXRCLENBRHFCLEVBRXJCO0lBQUVKLE1BQU0sRUFBRW5GLGtCQUFWO0lBQThCb0YsT0FBTyxFQUFFO0VBQXZDLENBRnFCLEVBR3JCO0lBQUVELE1BQU0sRUFBRSxDQUFWO0lBQWFDLE9BQU8sRUFBRTtFQUF0QixDQUhxQixDQUF2QjtFQUtBLE1BQU1QLGlCQUFpQixHQUFHaEcsMERBQWUsQ0FBQyxtQkFBRCxDQUFmLENBQXFDcUcsU0FBckMsQ0FBK0NsRixrQkFBa0IsS0FBSyxDQUF2QixHQUEyQnlGLGNBQTNCLEdBQTRDRCxlQUEzRixDQUExQjtFQUNBLE1BQU1QLGdCQUFnQixHQUFHcEcsMERBQWUsQ0FBQyxrQkFBRCxDQUFmLENBQW9DcUcsU0FBcEMsQ0FBOEMsQ0FDckU7SUFBRUMsTUFBTSxFQUFFLENBQVY7SUFBYUMsT0FBTyxFQUFFLENBQXRCO0lBQXlCQyxTQUFTLEVBQUcsY0FBYSxNQUFNWCxpQkFBaUIsR0FBRyxHQUFJO0VBQWhGLENBRHFFLEVBRXJFO0lBQUVTLE1BQU0sRUFBRSxDQUFWO0lBQWFDLE9BQU8sRUFBRSxDQUF0QjtJQUF5QkMsU0FBUyxFQUFHO0VBQXJDLENBRnFFLENBQTlDLENBQXpCO0VBSUEsT0FBTztJQUFFSixnQkFBRjtJQUFvQko7RUFBcEIsQ0FBUDtBQUNELENBdkJEOztBQXlCQSxNQUFNYSxzQkFBc0IsR0FBRyxNQUFNO0VBQ25DLE1BQU1iLGlCQUFpQixHQUFHaEcsMERBQWUsR0FDdENpRyxNQUR1QixDQUNoQixTQURnQixFQUNMLElBREssRUFDQyx5QkFERCxFQUV2QkMsWUFGdUIsQ0FFVjtJQUNkLGtCQUFrQjtFQURKLENBRlUsRUFLdkJDLGdCQUx1QixDQUtOLENBQUMsZ0JBQUQsQ0FMTSxDQUExQjtFQU1BLE1BQU1DLGdCQUFnQixHQUFHcEcsMERBQWUsR0FBR2lHLE1BQWxCLENBQXlCLFdBQXpCLEVBQXNDLG1CQUF0QyxFQUEyRCxpQkFBM0QsQ0FBekI7RUFDQSxPQUFPO0lBQUVELGlCQUFGO0lBQXFCSTtFQUFyQixDQUFQO0FBQ0QsQ0FURDtBQVVBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTVUsaUJBQWlCLEdBQUcsQ0FBQ0MsTUFBRCxFQUFTbkIsSUFBVCxLQUFrQjtFQUMxQyxNQUFNO0lBQUVvQixZQUFGO0lBQWdCbkI7RUFBaEIsSUFBc0NELElBQTVDO0VBQ0EsTUFBTWxDLElBQUksR0FBRzFFLHVEQUFjLENBQUMrSCxNQUFELENBQTNCO0VBQ0EsTUFBTTtJQUFFWCxnQkFBRjtJQUFvQko7RUFBcEIsSUFBMENILGlCQUFpQixLQUFLNUQsU0FBdEIsR0FBa0MwRCx5QkFBeUIsQ0FBQ0MsSUFBRCxDQUEzRCxHQUFvRWlCLHNCQUFzQixFQUExSTtFQUNBYixpQkFBaUIsQ0FBQ2lCLFVBQWxCLENBQTZCdkQsSUFBSSxDQUFDQyxhQUFMLENBQW1CLGNBQW5CLENBQTdCO0VBQ0F5QyxnQkFBZ0IsQ0FBQ2EsVUFBakIsQ0FBNEJ2RCxJQUFJLENBQUN3RCxnQkFBTCxDQUFzQiwrQkFBdEIsQ0FBNUIsRUFBb0ZoQixZQUFwRixDQUFpRztJQUFFSyxPQUFPLEVBQUU7RUFBWCxDQUFqRztFQUNBLE1BQU1ZLGFBQWEsR0FBR25ILDBEQUFlLENBQUMsZUFBRCxDQUFmLENBQ25CaUgsVUFEbUIsQ0FDUkYsTUFEUSxFQUVuQmhDLE1BRm1CLENBRVosNkJBRlksRUFHbkJDLFFBSG1CLENBR1YsR0FIVSxFQUluQm9DLFlBSm1CLENBSU5oQixnQkFKTSxDQUF0Qjs7RUFLQSxJQUFJWSxZQUFKLEVBQWtCO0lBQ2hCLE1BQU1LLFFBQVEsR0FBR0MsTUFBTSxDQUFDaEcsVUFBUCxHQUFvQixHQUFyQztJQUNBLE1BQU1pRyxZQUFZLEdBQUdQLFlBQVksQ0FBQ2hLLE9BQWIsS0FBeUIsV0FBekIsSUFBd0NnSyxZQUFZLENBQUNRLGlCQUFiLEtBQW1DdkYsU0FBaEc7SUFDQSxNQUFNd0YsZ0JBQWdCLEdBQUd6SSx1REFBYyxDQUFDZ0ksWUFBRCxDQUF2QztJQUNBLE1BQU1VLG1CQUFtQixHQUFHMUgsMERBQWUsR0FBR2tHLFlBQWxCLENBQStCO01BQ3pETSxTQUFTLEVBQUUsZUFEOEM7TUFFekQsb0JBQW9CLFlBRnFDO01BR3pEbUIsUUFBUSxFQUFFO0lBSCtDLENBQS9CLENBQTVCO0lBS0EsTUFBTUMsTUFBTSxHQUFHQyxRQUFRLENBQUNDLElBQXhCOztJQUNBLElBQUlULFFBQUosRUFBYztNQUNaO0FBQ047QUFDQTtBQUNBO0FBQ0E7TUFDTSxNQUFNVSxlQUFlLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDQyxRQUFKLENBQWEsT0FBYixFQUFzQixlQUF0QixDQUFELEdBQTBDLE1BQTFDLEdBQW1ELHFDQUEzRTtNQUNBLE1BQU1DLGNBQWMsR0FBR1gsWUFBWSxHQUFHLE9BQUgsR0FBYVEsZUFBaEQ7TUFDQSxNQUFNSSxpQkFBaUIsR0FBRzlGLG9CQUFvQixDQUFDQyxvQkFBL0M7TUFDQSxNQUFNOEYsY0FBYyxHQUFJLGNBQWFGLGNBQWUsV0FBVUMsaUJBQWtCLEdBQWhGO01BQ0FULG1CQUFtQixDQUNoQlcsV0FESCxDQUNlO1FBQ2I3QixTQUFTLEVBQUU0QjtNQURFLENBRGYsRUFJR0UsY0FKSCxDQUlrQixNQUFNVixNQUFNLENBQUNyRyxLQUFQLENBQWFnSCxXQUFiLENBQXlCLGtCQUF6QixFQUE2QyxPQUE3QyxDQUp4QixFQUtHdEIsVUFMSCxDQUtjRCxZQUxkLEVBTUdYLFNBTkgsQ0FNYSxDQUNYO1FBQUVDLE1BQU0sRUFBRSxDQUFWO1FBQWFrQyxNQUFNLEVBQUUsYUFBckI7UUFBb0NoQyxTQUFTLEVBQUUsMEJBQS9DO1FBQTJFaUMsWUFBWSxFQUFFO01BQXpGLENBRFcsRUFFWDtRQUFFbkMsTUFBTSxFQUFFLENBQVY7UUFBYWtDLE1BQU0sRUFBRSxnQkFBckI7UUFBdUNoQyxTQUFTLEVBQUU0QixjQUFsRDtRQUFrRUssWUFBWSxFQUFFO01BQWhGLENBRlcsQ0FOYjtNQVVBdEIsYUFBYSxDQUFDQyxZQUFkLENBQTJCTSxtQkFBM0I7SUFDRCxDQXJCRCxNQXNCSztNQUNIUCxhQUFhLENBQUNDLFlBQWQsQ0FBMkJwQixpQkFBM0I7O01BQ0EsSUFBSSxDQUFDdUIsWUFBTCxFQUFtQjtRQUNqQm5CLGdCQUFnQixDQUFDSCxNQUFqQixDQUF3QixTQUF4QixFQUFtQyxHQUFuQyxFQUF3QyxHQUF4QztNQUNELENBRkQsTUFHSztRQUNILE1BQU1rQyxpQkFBaUIsR0FBR1osWUFBWSxHQUFHbEYsb0JBQW9CLENBQUNDLG9CQUF4QixHQUErQyxDQUFyRjtRQUNBLE1BQU04RixjQUFjLEdBQUksMkJBQTBCRCxpQkFBa0IsR0FBcEU7UUFDQVQsbUJBQW1CLENBQ2hCVyxXQURILENBQ2U7VUFDYjdCLFNBQVMsRUFBRTRCO1FBREUsQ0FEZixFQUlHbkIsVUFKSCxDQUljUSxnQkFBZ0IsQ0FBQzlELGFBQWpCLENBQStCLGdCQUEvQixDQUpkLEVBS0cwQyxTQUxILENBS2EsQ0FDWDtVQUFFQyxNQUFNLEVBQUUsQ0FBVjtVQUFha0MsTUFBTSxFQUFFLGFBQXJCO1VBQW9DaEMsU0FBUyxFQUFFO1FBQS9DLENBRFcsRUFFWDtVQUFFRixNQUFNLEVBQUUsQ0FBVjtVQUFha0MsTUFBTSxFQUFFLGdCQUFyQjtVQUF1Q2hDLFNBQVMsRUFBRTRCO1FBQWxELENBRlcsQ0FMYjtRQVNBLE1BQU1NLGVBQWUsR0FBRzFJLDBEQUFlLEdBQ3BDcUksV0FEcUIsQ0FDVDtVQUNiN0IsU0FBUyxFQUFFNEI7UUFERSxDQURTLEVBSXJCbkIsVUFKcUIsQ0FJVlEsZ0JBQWdCLENBQUM5RCxhQUFqQixDQUErQixlQUEvQixDQUpVLEVBS3JCMEMsU0FMcUIsQ0FLWCxDQUNYO1VBQUVDLE1BQU0sRUFBRSxDQUFWO1VBQWFDLE9BQU8sRUFBRSxHQUF0QjtVQUEyQkMsU0FBUyxFQUFFO1FBQXRDLENBRFcsRUFFWDtVQUFFRixNQUFNLEVBQUUsQ0FBVjtVQUFhQyxPQUFPLEVBQUUsR0FBdEI7VUFBMkJDLFNBQVMsRUFBRTRCO1FBQXRDLENBRlcsQ0FMVyxDQUF4QjtRQVNBakIsYUFBYSxDQUFDQyxZQUFkLENBQTJCLENBQUNNLG1CQUFELEVBQXNCZ0IsZUFBdEIsQ0FBM0I7TUFDRDtJQUNGO0VBQ0YsQ0E3REQsTUE4REs7SUFDSHZCLGFBQWEsQ0FBQ0MsWUFBZCxDQUEyQnBCLGlCQUEzQjtFQUNEOztFQUNELE9BQU9tQixhQUFQO0FBQ0QsQ0E3RUQ7O0FBK0VBLE1BQU13QixzQkFBc0IsR0FBRyxNQUFNO0VBQ25DLE1BQU0zQyxpQkFBaUIsR0FBR2hHLDBEQUFlLEdBQUdpRyxNQUFsQixDQUF5QixTQUF6QixFQUFvQyx5QkFBcEMsRUFBK0QsQ0FBL0QsQ0FBMUI7RUFDQSxNQUFNRyxnQkFBZ0IsR0FBR3BHLDBEQUFlLEdBQUdpRyxNQUFsQixDQUF5QixXQUF6QixFQUFzQyxpQkFBdEMsRUFBeUQsbUJBQXpELENBQXpCO0VBQ0EsT0FBTztJQUFFRCxpQkFBRjtJQUFxQkk7RUFBckIsQ0FBUDtBQUNELENBSkQ7QUFLQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU13QyxpQkFBaUIsR0FBRyxDQUFDN0IsTUFBRCxFQUFTbkIsSUFBVCxFQUFlWixRQUFRLEdBQUcsR0FBMUIsS0FBa0M7RUFDMUQsTUFBTTtJQUFFZ0MsWUFBRjtJQUFnQm5CO0VBQWhCLElBQXNDRCxJQUE1QztFQUNBLE1BQU1sQyxJQUFJLEdBQUcxRSx1REFBYyxDQUFDK0gsTUFBRCxDQUEzQjtFQUNBLE1BQU07SUFBRVgsZ0JBQUY7SUFBb0JKO0VBQXBCLElBQTBDSCxpQkFBaUIsS0FBSzVELFNBQXRCLEdBQWtDd0UseUJBQXlCLENBQUNiLElBQUQsQ0FBM0QsR0FBb0UrQyxzQkFBc0IsRUFBMUk7RUFDQTNDLGlCQUFpQixDQUFDaUIsVUFBbEIsQ0FBNkJ2RCxJQUFJLENBQUNDLGFBQUwsQ0FBbUIsY0FBbkIsQ0FBN0I7RUFDQXlDLGdCQUFnQixDQUFDYSxVQUFqQixDQUE0QnZELElBQUksQ0FBQ3dELGdCQUFMLENBQXNCLCtCQUF0QixDQUE1QixFQUFvRmhCLFlBQXBGLENBQWlHO0lBQUVLLE9BQU8sRUFBRTtFQUFYLENBQWpHO0VBQ0EsTUFBTVksYUFBYSxHQUFHbkgsMERBQWUsQ0FBQyxjQUFELENBQWYsQ0FDbkJpSCxVQURtQixDQUNSRixNQURRLEVBRW5CaEMsTUFGbUIsQ0FFWiw2QkFGWSxFQUduQkMsUUFIbUIsQ0FHVkEsUUFIVSxFQUluQm9DLFlBSm1CLENBSU5oQixnQkFKTSxDQUF0Qjs7RUFLQSxJQUFJWSxZQUFKLEVBQWtCO0lBQ2hCLE1BQU1LLFFBQVEsR0FBR0MsTUFBTSxDQUFDaEcsVUFBUCxHQUFvQixHQUFyQztJQUNBLE1BQU1pRyxZQUFZLEdBQUdQLFlBQVksQ0FBQ2hLLE9BQWIsS0FBeUIsV0FBekIsSUFBd0NnSyxZQUFZLENBQUNRLGlCQUFiLEtBQW1DdkYsU0FBaEc7SUFDQSxNQUFNd0YsZ0JBQWdCLEdBQUd6SSx1REFBYyxDQUFDZ0ksWUFBRCxDQUF2QztJQUNBLE1BQU1VLG1CQUFtQixHQUFHMUgsMERBQWUsR0FDeEM2SSxpQkFEeUIsQ0FDUCxDQUFDLFdBQUQsQ0FETyxFQUV6QjFDLGdCQUZ5QixDQUVSLENBQUMsV0FBRCxDQUZRLEVBR3pCbkUsUUFIeUIsQ0FHZjhHLFdBQUQsSUFBaUI7TUFDM0I7TUFDQSxJQUFJQSxXQUFXLEtBQUssQ0FBcEIsRUFBdUI7UUFDckI7TUFDRDs7TUFDRDlCLFlBQVksQ0FBQ3pGLEtBQWIsQ0FBbUJnSCxXQUFuQixDQUErQixVQUEvQixFQUEyQyxFQUEzQztNQUNBLE1BQU1RLFNBQVMsR0FBR0MsS0FBSyxDQUFDQyxJQUFOLENBQVdyQixNQUFNLENBQUNWLGdCQUFQLENBQXdCLFdBQXhCLENBQVgsRUFBaURzQixNQUFqRCxDQUF5RFUsQ0FBRCxJQUFPQSxDQUFDLENBQUMxQixpQkFBRixLQUF3QnZGLFNBQXZGLEVBQWtHa0gsTUFBcEg7O01BQ0EsSUFBSUosU0FBUyxJQUFJLENBQWpCLEVBQW9CO1FBQ2xCbkIsTUFBTSxDQUFDckcsS0FBUCxDQUFhZ0gsV0FBYixDQUF5QixrQkFBekIsRUFBNkMsRUFBN0M7TUFDRDtJQUNGLENBYjJCLENBQTVCO0lBY0EsTUFBTVgsTUFBTSxHQUFHQyxRQUFRLENBQUNDLElBQXhCOztJQUNBLElBQUlULFFBQUosRUFBYztNQUNaLE1BQU1VLGVBQWUsR0FBRyxDQUFDQyxHQUFHLENBQUNDLFFBQUosQ0FBYSxPQUFiLEVBQXNCLGVBQXRCLENBQUQsR0FBMEMsTUFBMUMsR0FBbUQscUNBQTNFO01BQ0EsTUFBTUMsY0FBYyxHQUFHWCxZQUFZLEdBQUcsT0FBSCxHQUFhUSxlQUFoRDtNQUNBLE1BQU1JLGlCQUFpQixHQUFHOUYsb0JBQW9CLENBQUNDLG9CQUEvQztNQUNBLE1BQU04RixjQUFjLEdBQUksY0FBYUYsY0FBZSxXQUFVQyxpQkFBa0IsR0FBaEY7TUFDQVQsbUJBQW1CLENBQUNULFVBQXBCLENBQStCRCxZQUEvQixFQUE2Q1gsU0FBN0MsQ0FBdUQsQ0FDckQ7UUFBRUMsTUFBTSxFQUFFLENBQVY7UUFBYWtDLE1BQU0sRUFBRSxnQkFBckI7UUFBdUNoQyxTQUFTLEVBQUU0QixjQUFsRDtRQUFrRUssWUFBWSxFQUFFO01BQWhGLENBRHFELEVBRXJEO1FBQUVuQyxNQUFNLEVBQUUsQ0FBVjtRQUFha0MsTUFBTSxFQUFFLGFBQXJCO1FBQW9DaEMsU0FBUyxFQUFFLDBCQUEvQztRQUEyRWlDLFlBQVksRUFBRTtNQUF6RixDQUZxRCxDQUF2RDtNQUlBdEIsYUFBYSxDQUFDQyxZQUFkLENBQTJCTSxtQkFBM0I7SUFDRCxDQVZELE1BV0s7TUFDSFAsYUFBYSxDQUFDQyxZQUFkLENBQTJCcEIsaUJBQTNCOztNQUNBLElBQUksQ0FBQ3VCLFlBQUwsRUFBbUI7UUFDakJuQixnQkFBZ0IsQ0FBQ0gsTUFBakIsQ0FBd0IsU0FBeEIsRUFBbUMsR0FBbkMsRUFBd0MsR0FBeEM7TUFDRCxDQUZELE1BR0s7UUFDSCxNQUFNa0MsaUJBQWlCLEdBQUdaLFlBQVksR0FBR2xGLG9CQUFvQixDQUFDQyxvQkFBeEIsR0FBK0MsQ0FBckY7UUFDQSxNQUFNOEYsY0FBYyxHQUFJLDJCQUEwQkQsaUJBQWtCLEdBQXBFO1FBQ0FULG1CQUFtQixDQUNoQlQsVUFESCxDQUNjUSxnQkFBZ0IsQ0FBQzlELGFBQWpCLENBQStCLGdCQUEvQixDQURkLEVBRUcwRSxXQUZILENBRWU7VUFDYjdCLFNBQVMsRUFBRTtRQURFLENBRmYsRUFLR0gsU0FMSCxDQUthLENBQ1g7VUFBRUMsTUFBTSxFQUFFLENBQVY7VUFBYWtDLE1BQU0sRUFBRSxnQkFBckI7VUFBdUNoQyxTQUFTLEVBQUU0QjtRQUFsRCxDQURXLEVBRVg7VUFBRTlCLE1BQU0sRUFBRSxDQUFWO1VBQWFrQyxNQUFNLEVBQUUsYUFBckI7VUFBb0NoQyxTQUFTLEVBQUU7UUFBL0MsQ0FGVyxDQUxiO1FBU0EsTUFBTWtDLGVBQWUsR0FBRzFJLDBEQUFlLEdBQ3BDaUgsVUFEcUIsQ0FDVlEsZ0JBQWdCLENBQUM5RCxhQUFqQixDQUErQixlQUEvQixDQURVLEVBRXJCMEUsV0FGcUIsQ0FFVDtVQUNiN0IsU0FBUyxFQUFFO1FBREUsQ0FGUyxFQUtyQkgsU0FMcUIsQ0FLWCxDQUNYO1VBQUVDLE1BQU0sRUFBRSxDQUFWO1VBQWFDLE9BQU8sRUFBRSxHQUF0QjtVQUEyQkMsU0FBUyxFQUFFNEI7UUFBdEMsQ0FEVyxFQUVYO1VBQUU5QixNQUFNLEVBQUUsQ0FBVjtVQUFhQyxPQUFPLEVBQUUsR0FBdEI7VUFBMkJDLFNBQVMsRUFBRTtRQUF0QyxDQUZXLENBTFcsQ0FBeEI7UUFTQVcsYUFBYSxDQUFDQyxZQUFkLENBQTJCLENBQUNNLG1CQUFELEVBQXNCZ0IsZUFBdEIsQ0FBM0I7TUFDRDtJQUNGO0VBQ0YsQ0EzREQsTUE0REs7SUFDSHZCLGFBQWEsQ0FBQ0MsWUFBZCxDQUEyQnBCLGlCQUEzQjtFQUNEOztFQUNELE9BQU9tQixhQUFQO0FBQ0QsQ0EzRUQ7O0FBNkVBLE1BQU1pQyxvQkFBb0IsR0FBRyxNQUFNO0VBQ2pDLE1BQU1wRCxpQkFBaUIsR0FBR2hHLDBEQUFlLEdBQ3RDaUcsTUFEdUIsQ0FDaEIsU0FEZ0IsRUFDTCxJQURLLEVBQ0MseUJBREQsRUFFdkJDLFlBRnVCLENBRVY7SUFDZCxrQkFBa0I7RUFESixDQUZVLEVBS3ZCQyxnQkFMdUIsQ0FLTixDQUFDLGdCQUFELENBTE0sQ0FBMUI7RUFNQSxNQUFNQyxnQkFBZ0IsR0FBR3BHLDBEQUFlLEdBQUdxRyxTQUFsQixDQUE0QixDQUNuRDtJQUFFQyxNQUFNLEVBQUUsQ0FBVjtJQUFhQyxPQUFPLEVBQUUsSUFBdEI7SUFBNEJDLFNBQVMsRUFBRTtFQUF2QyxDQURtRCxFQUVuRDtJQUFFRixNQUFNLEVBQUUsQ0FBVjtJQUFhQyxPQUFPLEVBQUUsQ0FBdEI7SUFBeUJDLFNBQVMsRUFBRztFQUFyQyxDQUZtRCxDQUE1QixDQUF6QjtFQUlBLE9BQU87SUFBRVIsaUJBQUY7SUFBcUJJO0VBQXJCLENBQVA7QUFDRCxDQVpEO0FBYUE7QUFDQTtBQUNBOzs7QUFDQSxNQUFNaUQsZ0JBQWdCLEdBQUcsQ0FBQ3RDLE1BQUQsRUFBU25CLElBQVQsS0FBa0I7RUFDekMsTUFBTTtJQUFFQztFQUFGLElBQXdCRCxJQUE5QjtFQUNBLE1BQU1sQyxJQUFJLEdBQUcxRSx1REFBYyxDQUFDK0gsTUFBRCxDQUEzQjtFQUNBLE1BQU07SUFBRVgsZ0JBQUY7SUFBb0JKO0VBQXBCLElBQTBDSCxpQkFBaUIsS0FBSzVELFNBQXRCLEdBQWtDMEQseUJBQXlCLENBQUNDLElBQUQsQ0FBM0QsR0FBb0V3RCxvQkFBb0IsRUFBeEk7RUFDQXBELGlCQUFpQixDQUFDaUIsVUFBbEIsQ0FBNkJ2RCxJQUFJLENBQUNDLGFBQUwsQ0FBbUIsY0FBbkIsQ0FBN0I7RUFDQXlDLGdCQUFnQixDQUFDYSxVQUFqQixDQUE0QnZELElBQUksQ0FBQ0MsYUFBTCxDQUFtQixnQkFBbkIsQ0FBNUI7RUFDQSxPQUFPM0QsMERBQWUsR0FDbkJpSCxVQURJLENBQ09GLE1BRFAsRUFFSmhDLE1BRkksQ0FFRyxnQ0FGSCxFQUdKQyxRQUhJLENBR0ssR0FITCxFQUlKb0MsWUFKSSxDQUlTLENBQUNwQixpQkFBRCxFQUFvQkksZ0JBQXBCLENBSlQsQ0FBUDtBQUtELENBWEQ7O0FBYUEsTUFBTWtELG9CQUFvQixHQUFHLE1BQU07RUFDakMsTUFBTXRELGlCQUFpQixHQUFHaEcsMERBQWUsR0FBR2lHLE1BQWxCLENBQXlCLFNBQXpCLEVBQW9DLHlCQUFwQyxFQUErRCxDQUEvRCxDQUExQjtFQUNBLE1BQU1HLGdCQUFnQixHQUFHcEcsMERBQWUsR0FBR3FHLFNBQWxCLENBQTRCLENBQ25EO0lBQUVDLE1BQU0sRUFBRSxDQUFWO0lBQWFDLE9BQU8sRUFBRSxJQUF0QjtJQUE0QkMsU0FBUyxFQUFHO0VBQXhDLENBRG1ELEVBRW5EO0lBQUVGLE1BQU0sRUFBRSxDQUFWO0lBQWFDLE9BQU8sRUFBRSxDQUF0QjtJQUF5QkMsU0FBUyxFQUFFO0VBQXBDLENBRm1ELENBQTVCLENBQXpCO0VBSUEsT0FBTztJQUFFUixpQkFBRjtJQUFxQkk7RUFBckIsQ0FBUDtBQUNELENBUEQ7QUFRQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1tRCxnQkFBZ0IsR0FBRyxDQUFDeEMsTUFBRCxFQUFTbkIsSUFBVCxLQUFrQjtFQUN6QyxNQUFNO0lBQUVDO0VBQUYsSUFBd0JELElBQTlCO0VBQ0EsTUFBTWxDLElBQUksR0FBRzFFLHVEQUFjLENBQUMrSCxNQUFELENBQTNCO0VBQ0EsTUFBTTtJQUFFWCxnQkFBRjtJQUFvQko7RUFBcEIsSUFBMENILGlCQUFpQixLQUFLNUQsU0FBdEIsR0FBa0N3RSx5QkFBeUIsQ0FBQ2IsSUFBRCxDQUEzRCxHQUFvRTBELG9CQUFvQixFQUF4STtFQUNBdEQsaUJBQWlCLENBQUNpQixVQUFsQixDQUE2QnZELElBQUksQ0FBQ0MsYUFBTCxDQUFtQixjQUFuQixDQUE3QjtFQUNBeUMsZ0JBQWdCLENBQUNhLFVBQWpCLENBQTRCdkQsSUFBSSxDQUFDQyxhQUFMLENBQW1CLGdCQUFuQixDQUE1QjtFQUNBLE9BQU8zRCwwREFBZSxHQUNuQitFLE1BREksQ0FDRyxrQ0FESCxFQUVKQyxRQUZJLENBRUssR0FGTCxFQUdKb0MsWUFISSxDQUdTLENBQUNwQixpQkFBRCxFQUFvQkksZ0JBQXBCLENBSFQsQ0FBUDtBQUlELENBVkQ7O0FBWUEsTUFBTW9ELGtCQUFrQixHQUFHLENBQUN6QyxNQUFELEVBQVMwQyxVQUFULEVBQXFCQyxTQUFyQixFQUFnQ0MsaUJBQWhDLEVBQW1EeEksa0JBQW5ELEVBQXVFUyxTQUF2RSxFQUFrRmdJLFdBQVcsR0FBRyxFQUFoRyxFQUFvR0Msb0JBQXBHLEVBQTBIckgsU0FBMUgsRUFBcUlzSCxrQkFBckksS0FBNEo7RUFDckw7RUFDQSxNQUFNbkQsZUFBZSxHQUFHLENBQ3RCO0lBQUVMLE1BQU0sRUFBRSxDQUFWO0lBQWFDLE9BQU8sRUFBRTtFQUF0QixDQURzQixFQUV0QjtJQUFFRCxNQUFNLEVBQUUsQ0FBVjtJQUFhQyxPQUFPLEVBQUU7RUFBdEIsQ0FGc0IsQ0FBeEI7RUFJQSxNQUFNSyxjQUFjLEdBQUcsQ0FDckI7SUFBRU4sTUFBTSxFQUFFLENBQVY7SUFBYUMsT0FBTyxFQUFFO0VBQXRCLENBRHFCLEVBRXJCO0lBQUVELE1BQU0sRUFBRSxJQUFJbkYsa0JBQWQ7SUFBa0NvRixPQUFPLEVBQUU7RUFBM0MsQ0FGcUIsRUFHckI7SUFBRUQsTUFBTSxFQUFFLENBQVY7SUFBYUMsT0FBTyxFQUFFO0VBQXRCLENBSHFCLENBQXZCO0VBS0EsTUFBTXdELGFBQWEsR0FBRztJQUNwQkMsaUJBQWlCLEVBQUUsQ0FDakI7TUFBRTFELE1BQU0sRUFBRSxDQUFWO01BQWFFLFNBQVMsRUFBRTtJQUF4QixDQURpQixFQUVqQjtNQUFFRixNQUFNLEVBQUUsQ0FBVjtNQUFhRSxTQUFTLEVBQUU7SUFBeEIsQ0FGaUIsQ0FEQztJQUtwQnlELGtCQUFrQixFQUFFOUksa0JBQWtCLEtBQUssQ0FBdkIsR0FBMkJ5RixjQUEzQixHQUE0Q0Q7RUFMNUMsQ0FBdEI7RUFPQSxNQUFNN0QsU0FBUyxHQUFHaUUsTUFBTSxDQUFDcEQsYUFBUCxDQUFxQixhQUFyQixDQUFsQjtFQUNBLE1BQU1qQixNQUFNLEdBQUdnSCxTQUFTLENBQUNRLFlBQXpCO0VBQ0EsSUFBSXJFLGlCQUFpQixHQUFHOEQsaUJBQXhCO0VBQ0EsSUFBSXJELE1BQU0sR0FBRyxDQUFiO0VBQ0EsSUFBSXpELHVCQUF1QixHQUFHLEtBQTlCO0VBQ0EsTUFBTUcsaUJBQWlCLEdBQUcsSUFBMUI7RUFDQSxNQUFNb0QsZ0JBQWdCLEdBQUd4RSxTQUFTLENBQUN1SSxlQUFWLENBQTBCQyxJQUExQixDQUFnQ0MsR0FBRCxJQUFTQSxHQUFHLENBQUNDLEVBQUosS0FBVyxrQkFBbkQsQ0FBekI7RUFDQSxNQUFNdEUsaUJBQWlCLEdBQUdwRSxTQUFTLENBQUN1SSxlQUFWLENBQTBCQyxJQUExQixDQUFnQ0MsR0FBRCxJQUFTQSxHQUFHLENBQUNDLEVBQUosS0FBVyxtQkFBbkQsQ0FBMUI7RUFDQSxNQUFNQyxhQUFhLEdBQUdYLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDVCxNQUFaLEdBQXFCLENBQXRCLENBQWpDO0VBQ0EsTUFBTXFCLGFBQWEsR0FBR1osV0FBVyxDQUFDLENBQUQsQ0FBakM7O0VBQ0EsTUFBTWEsY0FBYyxHQUFHLE1BQU07SUFDM0IxRCxNQUFNLENBQUN4RixLQUFQLENBQWFnSCxXQUFiLENBQXlCLGdCQUF6QixFQUEyQyxNQUEzQztJQUNBa0IsVUFBVSxDQUFDbEksS0FBWCxDQUFpQmdILFdBQWpCLENBQTZCLGdCQUE3QixFQUErQyxNQUEvQztJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0lBQ0l4QixNQUFNLENBQUMyRCxTQUFQLENBQWlCQyxNQUFqQixDQUF3Qix3QkFBeEI7RUFDRCxDQVREOztFQVVBLE1BQU1DLGVBQWUsR0FBRyxNQUFNO0lBQzVCN0QsTUFBTSxDQUFDeEYsS0FBUCxDQUFhZ0gsV0FBYixDQUF5QixnQkFBekIsRUFBMkMsTUFBM0M7SUFDQWtCLFVBQVUsQ0FBQ2xJLEtBQVgsQ0FBaUJnSCxXQUFqQixDQUE2QixnQkFBN0IsRUFBK0MsTUFBL0M7SUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFDSXhCLE1BQU0sQ0FBQzJELFNBQVAsQ0FBaUJHLEdBQWpCLENBQXFCLHdCQUFyQjtFQUNELENBWEQ7RUFZQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7RUFDRSxJQUFJekUsZ0JBQWdCLElBQUlKLGlCQUF4QixFQUEyQztJQUN6Q0ksZ0JBQWdCLENBQUNDLFNBQWpCLENBQTJCLENBQUMsR0FBRzBELGFBQWEsQ0FBQ0MsaUJBQWxCLENBQTNCO0lBQ0FoRSxpQkFBaUIsQ0FBQ0ssU0FBbEIsQ0FBNEIsQ0FBQyxHQUFHMEQsYUFBYSxDQUFDRSxrQkFBbEIsQ0FBNUI7SUFDQXJJLFNBQVMsQ0FBQ3FDLGFBQVYsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBSTRCLGlCQUFsQztJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJLE1BQU1pRixvQkFBb0IsR0FBR2pGLGlCQUFpQixHQUFHMUUsa0JBQWpEOztJQUNBLElBQUkySixvQkFBSixFQUEwQjtNQUN4QkwsY0FBYztJQUNmLENBRkQsTUFHSztNQUNIRyxlQUFlO0lBQ2hCO0VBQ0Y7O0VBQ0QsSUFBSTlILFNBQVMsSUFBSStDLGlCQUFpQixLQUFLMEUsYUFBdkMsRUFBc0Q7SUFDcER6SCxTQUFTLENBQUNNLE9BQVYsR0FBb0IsS0FBcEI7RUFDRDs7RUFDRCxNQUFNQyxRQUFRLEdBQUlDLE1BQUQsSUFBWTtJQUMzQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDSSxNQUFNeUgsT0FBTyxHQUFHekgsTUFBTSxDQUFDRSxLQUFQLENBQWFELE1BQWIsQ0FBb0JFLE9BQXBCLENBQTRCLGFBQTVCLENBQWhCO0lBQ0FvQyxpQkFBaUIsR0FBR2dFLG9CQUFvQixFQUF4Qzs7SUFDQSxJQUFJaEUsaUJBQWlCLEtBQUssQ0FBdEIsSUFBMkJrRixPQUEvQixFQUF3QztNQUN0QyxPQUFPLEtBQVA7SUFDRDs7SUFDRCxPQUFPLElBQVA7RUFDRCxDQWJEOztFQWNBLE1BQU1oSCxPQUFPLEdBQUcsTUFBTTtJQUNwQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDSWxCLHVCQUF1QixHQUFHa0UsTUFBTSxDQUFDbEYsVUFBUCxLQUFzQkksU0FBdEIsSUFBbUM4RSxNQUFNLENBQUNsRixVQUFQLEtBQXNCLElBQXpELElBQWlFMkksYUFBYSxLQUFLLENBQTdHO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7SUFDSSxJQUFJMUgsU0FBSixFQUFlO01BQ2JBLFNBQVMsQ0FBQ00sT0FBVixHQUFvQixLQUFwQjtJQUNEOztJQUNEakUsdURBQUcsQ0FBQyxNQUFNO01BQ1I7QUFDTjtBQUNBO0FBQ0E7TUFDTTRILE1BQU0sQ0FBQ2lFLEtBQVA7SUFDRCxDQU5FLENBQUg7SUFPQXBKLFNBQVMsQ0FBQ3FDLGFBQVYsQ0FBd0IsSUFBeEIsRUFBOEIsSUFBSTRCLGlCQUFsQztFQUNELENBOUJEOztFQStCQSxNQUFNM0IsTUFBTSxHQUFJWixNQUFELElBQVk7SUFDekI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtJQUNJLE1BQU0ySCxXQUFXLEdBQUcsSUFBSXBGLGlCQUF4QjtJQUNBLE1BQU1xRixzQkFBc0IsR0FBR3RCLFdBQVcsQ0FBQ1QsTUFBWixHQUFxQixDQUFyQixHQUF5QixJQUFJUyxXQUFXLENBQUMsQ0FBRCxDQUF4QyxHQUE4QzNILFNBQTdFO0lBQ0EsTUFBTWtDLElBQUksR0FBRzhHLFdBQVcsR0FBRzNILE1BQU0sQ0FBQ1UsTUFBUCxHQUFnQnRCLE1BQTNDO0lBQ0EsTUFBTXlJLGlDQUFpQyxHQUFHRCxzQkFBc0IsS0FBS2pKLFNBQTNCLElBQXdDa0MsSUFBSSxJQUFJK0csc0JBQWhELElBQTBFckksdUJBQXBIO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7SUFDSSxNQUFNd0IsT0FBTyxHQUFHOEcsaUNBQWlDLEdBQUduSSxpQkFBSCxHQUF1QixNQUF4RTtJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0lBQ0ksTUFBTXNCLGFBQWEsR0FBRzZHLGlDQUFpQyxJQUFJRCxzQkFBc0IsS0FBS2pKLFNBQWhFLEdBQ2xCaUosc0JBQXNCLEdBQ3RCL0ksbUJBQW1CLENBQUMsQ0FBQ2dDLElBQUksR0FBRytHLHNCQUFSLEtBQW1DN0csT0FBTyxHQUFHNkcsc0JBQTdDLENBQUQsQ0FGRCxHQUdsQi9HLElBSEo7SUFJQW1DLE1BQU0sR0FBR3BILHVEQUFLLENBQUMsTUFBRCxFQUFTb0YsYUFBVCxFQUF3QkQsT0FBeEIsQ0FBZDtJQUNBekMsU0FBUyxDQUFDNEMsWUFBVixDQUF1QjhCLE1BQXZCO0VBQ0QsQ0FwQ0Q7O0VBcUNBLE1BQU03QixLQUFLLEdBQUluQixNQUFELElBQVk7SUFDeEI7QUFDSjtBQUNBO0FBQ0E7SUFDSSxNQUFNb0IsUUFBUSxHQUFHcEIsTUFBTSxDQUFDcUIsU0FBeEI7SUFDQSxNQUFNQyxTQUFTLEdBQUcsQ0FBQ3RCLE1BQU0sQ0FBQ1UsTUFBUCxHQUFnQlUsUUFBUSxHQUFHLEdBQTVCLElBQW1DaEMsTUFBckQ7SUFDQSxNQUFNMEksSUFBSSxHQUFHdkYsaUJBQWlCLEdBQUdqQixTQUFqQztJQUNBLE1BQU1uQixPQUFPLEdBQUdtRyxXQUFXLENBQUN5QixNQUFaLENBQW1CLENBQUNsTyxDQUFELEVBQUlDLENBQUosS0FBVTtNQUMzQyxPQUFPcUksSUFBSSxDQUFDQyxHQUFMLENBQVN0SSxDQUFDLEdBQUdnTyxJQUFiLElBQXFCM0YsSUFBSSxDQUFDQyxHQUFMLENBQVN2SSxDQUFDLEdBQUdpTyxJQUFiLENBQXJCLEdBQTBDaE8sQ0FBMUMsR0FBOENELENBQXJEO0lBQ0QsQ0FGZSxDQUFoQjtJQUdBbU8scUJBQXFCLENBQUM7TUFDcEJDLFVBQVUsRUFBRTlILE9BRFE7TUFFcEIrSCxnQkFBZ0IsRUFBRWxGLE1BRkU7TUFHcEJ6RSxVQUFVLEVBQUVnQjtJQUhRLENBQUQsQ0FBckI7RUFLRCxDQWhCRDs7RUFpQkEsTUFBTXlJLHFCQUFxQixHQUFJdkssT0FBRCxJQUFhO0lBQ3pDLE1BQU07TUFBRXdLLFVBQUY7TUFBYzFKLFVBQWQ7TUFBMEIySjtJQUExQixJQUErQ3pLLE9BQXJEO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJLE1BQU0wSyxvQkFBb0IsR0FBRzVKLFVBQVUsSUFBSTBKLFVBQVUsS0FBSyxDQUExRDtJQUNBLE1BQU1HLGdCQUFnQixHQUFHRCxvQkFBb0IsR0FBRzVGLGlCQUFILEdBQXVCMEYsVUFBcEU7SUFDQSxNQUFNSSxnQkFBZ0IsR0FBR0QsZ0JBQWdCLEtBQUssQ0FBOUM7SUFDQTdGLGlCQUFpQixHQUFHLENBQXBCO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7O0lBQ0ksSUFBSU8sZ0JBQWdCLElBQUlKLGlCQUF4QixFQUEyQztNQUN6Q0ksZ0JBQWdCLENBQUNDLFNBQWpCLENBQTJCLENBQ3pCO1FBQUVDLE1BQU0sRUFBRSxDQUFWO1FBQWFFLFNBQVMsRUFBRyxjQUFhZ0YsZ0JBQWdCLEdBQUcsR0FBSTtNQUE3RCxDQUR5QixFQUV6QjtRQUFFbEYsTUFBTSxFQUFFLENBQVY7UUFBYUUsU0FBUyxFQUFHLGNBQWEsQ0FBQyxJQUFJa0YsZ0JBQUwsSUFBeUIsR0FBSTtNQUFuRSxDQUZ5QixDQUEzQjtNQUlBMUYsaUJBQWlCLENBQUNLLFNBQWxCLENBQTRCLENBQzFCO1FBQ0VDLE1BQU0sRUFBRSxDQURWO1FBRUVDLE9BQU8sRUFBRyxrQ0FBaUN0Rix3QkFBd0IsQ0FBQyxJQUFJdUssZ0JBQUwsRUFBdUJySyxrQkFBdkIsQ0FBMkM7TUFGaEgsQ0FEMEIsRUFLMUI7UUFDRW1GLE1BQU0sRUFBRSxDQURWO1FBRUVDLE9BQU8sRUFBRyxrQ0FBaUN0Rix3QkFBd0IsQ0FBQ3lLLGdCQUFELEVBQW1Cdkssa0JBQW5CLENBQXVDO01BRjVHLENBTDBCLENBQTVCO01BVUFTLFNBQVMsQ0FBQzRDLFlBQVYsQ0FBdUIsQ0FBdkI7SUFDRDtJQUNEO0FBQ0o7QUFDQTtBQUNBOzs7SUFDSVUsT0FBTyxDQUFDQyxNQUFSLENBQWUsS0FBZjs7SUFDQSxJQUFJc0csb0JBQUosRUFBMEI7TUFDeEI5SixnQkFBZ0IsQ0FBQ29GLE1BQUQsRUFBU25GLFNBQVQsQ0FBaEI7SUFDRCxDQUZELE1BR0ssSUFBSSxDQUFDK0osZ0JBQUwsRUFBdUI7TUFDMUJuSixTQUFTO0lBQ1Y7O0lBQ0QsT0FBTyxJQUFJb0osT0FBSixDQUFhQyxPQUFELElBQWE7TUFDOUJqSyxTQUFTLENBQ05JLFFBREgsQ0FDWSxNQUFNO1FBQ2hCLElBQUkySixnQkFBSixFQUFzQjtVQUNwQjtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtVQUNVLElBQUl2RixnQkFBZ0IsSUFBSUosaUJBQXhCLEVBQTJDO1lBQ3pDN0csdURBQUcsQ0FBQyxNQUFNO2NBQ1JpSCxnQkFBZ0IsQ0FBQ0MsU0FBakIsQ0FBMkIsQ0FBQyxHQUFHMEQsYUFBYSxDQUFDQyxpQkFBbEIsQ0FBM0I7Y0FDQWhFLGlCQUFpQixDQUFDSyxTQUFsQixDQUE0QixDQUFDLEdBQUcwRCxhQUFhLENBQUNFLGtCQUFsQixDQUE1QjtjQUNBckksU0FBUyxDQUFDcUMsYUFBVixDQUF3QixJQUF4QixFQUE4QixJQUFJeUgsZ0JBQWxDO2NBQ0E3RixpQkFBaUIsR0FBRzZGLGdCQUFwQjtjQUNBNUIsa0JBQWtCLENBQUNqRSxpQkFBRCxDQUFsQjtjQUNBO0FBQ2Q7QUFDQTtBQUNBOztjQUNjLElBQUkvQyxTQUFTLElBQUkrQyxpQkFBaUIsS0FBSytELFdBQVcsQ0FBQ0EsV0FBVyxDQUFDVCxNQUFaLEdBQXFCLENBQXRCLENBQWxELEVBQTRFO2dCQUMxRXJHLFNBQVMsQ0FBQ00sT0FBVixHQUFvQixJQUFwQjtjQUNEO2NBQ0Q7QUFDZDtBQUNBO0FBQ0E7OztjQUNjLE1BQU0wSCxvQkFBb0IsR0FBR2pGLGlCQUFpQixHQUFHMUUsa0JBQWpEOztjQUNBLElBQUkySixvQkFBSixFQUEwQjtnQkFDeEJMLGNBQWM7Y0FDZixDQUZELE1BR0s7Z0JBQ0hHLGVBQWU7Y0FDaEI7O2NBQ0QxRixPQUFPLENBQUNDLE1BQVIsQ0FBZSxJQUFmO2NBQ0EwRyxPQUFPO1lBQ1IsQ0ExQkUsQ0FBSDtVQTJCRCxDQTVCRCxNQTZCSztZQUNIM0csT0FBTyxDQUFDQyxNQUFSLENBQWUsSUFBZjtZQUNBMEcsT0FBTztVQUNSO1FBQ0YsQ0F6Q0QsTUEwQ0s7VUFDSEEsT0FBTztRQUNSO1FBQ0Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7TUFDTyxDQXBERCxFQW9ERztRQUFFM0osZUFBZSxFQUFFO01BQW5CLENBcERILEVBcURHa0QsV0FyREgsQ0FxRGUsQ0FyRGYsRUFxRGtCLENBckRsQixFQXFEcUIsR0FyRHJCO0lBc0RELENBdkRNLENBQVA7RUF3REQsQ0FwR0Q7O0VBcUdBLE1BQU1GLE9BQU8sR0FBR2hGLGtFQUFhLENBQUM7SUFDNUJwRCxFQUFFLEVBQUU0TSxTQUR3QjtJQUU1QnJFLFdBQVcsRUFBRSxZQUZlO0lBRzVCQyxlQUFlLEVBQUUsRUFIVztJQUk1QkMsU0FBUyxFQUFFLEdBSmlCO0lBSzVCWCxTQUFTLEVBQUUsRUFMaUI7SUFNNUJ2QixRQU40QjtJQU81QlUsT0FQNEI7SUFRNUJHLE1BUjRCO0lBUzVCTztFQVQ0QixDQUFELENBQTdCO0VBV0EsT0FBTztJQUNMUyxPQURLO0lBRUxvRztFQUZLLENBQVA7QUFJRCxDQXZTRDs7QUF5U0EsTUFBTVEsV0FBVyxHQUFHLDRpSkFBcEI7QUFFQSxNQUFNQyxVQUFVLEdBQUcsd3hGQUFuQjtBQUVBLE1BQU1DLEtBQUssR0FBRyxNQUFNO0VBQ2xCQyxXQUFXLENBQUNDLE9BQUQsRUFBVTtJQUNuQjNPLHFEQUFnQixDQUFDLElBQUQsRUFBTzJPLE9BQVAsQ0FBaEI7SUFDQSxLQUFLQyxVQUFMLEdBQWtCMU8scURBQVcsQ0FBQyxJQUFELEVBQU8sb0JBQVAsRUFBNkIsQ0FBN0IsQ0FBN0I7SUFDQSxLQUFLMk8sV0FBTCxHQUFtQjNPLHFEQUFXLENBQUMsSUFBRCxFQUFPLHFCQUFQLEVBQThCLENBQTlCLENBQTlCO0lBQ0EsS0FBSzRPLFdBQUwsR0FBbUI1TyxxREFBVyxDQUFDLElBQUQsRUFBTyxxQkFBUCxFQUE4QixDQUE5QixDQUE5QjtJQUNBLEtBQUs2TyxVQUFMLEdBQWtCN08scURBQVcsQ0FBQyxJQUFELEVBQU8sb0JBQVAsRUFBNkIsQ0FBN0IsQ0FBN0I7SUFDQSxLQUFLOE8sc0JBQUwsR0FBOEI5TyxxREFBVyxDQUFDLElBQUQsRUFBTyx3QkFBUCxFQUFpQyxDQUFqQyxDQUF6QztJQUNBLEtBQUsrTyxtQkFBTCxHQUEyQi9PLHFEQUFXLENBQUMsSUFBRCxFQUFPLFlBQVAsRUFBcUIsQ0FBckIsQ0FBdEM7SUFDQSxLQUFLZ1Asb0JBQUwsR0FBNEJoUCxxREFBVyxDQUFDLElBQUQsRUFBTyxhQUFQLEVBQXNCLENBQXRCLENBQXZDO0lBQ0EsS0FBS2lQLG9CQUFMLEdBQTRCalAscURBQVcsQ0FBQyxJQUFELEVBQU8sYUFBUCxFQUFzQixDQUF0QixDQUF2QztJQUNBLEtBQUtrUCxtQkFBTCxHQUEyQmxQLHFEQUFXLENBQUMsSUFBRCxFQUFPLFlBQVAsRUFBcUIsQ0FBckIsQ0FBdEM7SUFDQSxLQUFLbVAsVUFBTCxHQUFrQkMsUUFBUSxFQUExQjtJQUNBLEtBQUtDLFlBQUwsR0FBb0JsTyxrRUFBWSxFQUFoQztJQUNBLEtBQUttTyxZQUFMLEdBQW9CLEtBQXBCO0lBQ0EsS0FBS0MsbUJBQUwsR0FBMkIsRUFBM0I7SUFDQSxLQUFLQyxNQUFMLEdBQWMsS0FBZCxDQWZtQixDQWdCbkI7O0lBQ0EsS0FBS0MsMEJBQUwsR0FBa0MsS0FBbEM7SUFDQSxLQUFLQyxTQUFMLEdBQWlCLEtBQWpCO0lBQ0E7O0lBQ0EsS0FBS0MsYUFBTCxHQUFxQixLQUFyQjtJQUNBO0FBQ0o7QUFDQTs7SUFDSSxLQUFLQyxhQUFMLEdBQXFCLElBQXJCO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJLEtBQUtsTSxrQkFBTCxHQUEwQixDQUExQjtJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFDSSxLQUFLbU0sY0FBTCxHQUFzQixNQUF0QjtJQUNBO0FBQ0o7QUFDQTs7SUFDSSxLQUFLQyxlQUFMLEdBQXVCLElBQXZCO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0lBQ0ksS0FBS0MsWUFBTCxHQUFvQixJQUFwQjtJQUNBO0FBQ0o7QUFDQTs7SUFDSSxLQUFLQyxRQUFMLEdBQWdCLElBQWhCO0lBQ0E7QUFDSjtBQUNBO0FBQ0E7O0lBQ0ksS0FBS0MsWUFBTCxHQUFvQixLQUFwQjtJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUNJLEtBQUs5SyxNQUFMLEdBQWMsS0FBZDtJQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0lBQ0ksS0FBSytLLG1CQUFMLEdBQTJCLEtBQTNCOztJQUNBLEtBQUtDLDJCQUFMLEdBQW1DLE1BQU07TUFDdkMsTUFBTTtRQUFFQyxPQUFGO1FBQVcvUSxFQUFYO1FBQWVnUjtNQUFmLElBQTZDLElBQW5EOztNQUNBLElBQUlBLHlCQUFKLEVBQStCO1FBQzdCQSx5QkFBeUI7TUFDMUI7O01BQ0QsTUFBTUMsU0FBUyxHQUFHRixPQUFPLEtBQUs1TCxTQUFaLEdBQXdCNEYsUUFBUSxDQUFDbUcsY0FBVCxDQUF3QkgsT0FBeEIsQ0FBeEIsR0FBMkQsSUFBN0U7O01BQ0EsSUFBSSxDQUFDRSxTQUFMLEVBQWdCO1FBQ2Q7TUFDRDs7TUFDRCxNQUFNSCwyQkFBMkIsR0FBRyxDQUFDSyxNQUFELEVBQVNDLE9BQVQsS0FBcUI7UUFDdkQsTUFBTUMsU0FBUyxHQUFHLE1BQU07VUFDdEJELE9BQU8sQ0FBQ3hPLE9BQVI7UUFDRCxDQUZEOztRQUdBdU8sTUFBTSxDQUFDRyxnQkFBUCxDQUF3QixPQUF4QixFQUFpQ0QsU0FBakM7UUFDQSxPQUFPLE1BQU07VUFDWEYsTUFBTSxDQUFDSSxtQkFBUCxDQUEyQixPQUEzQixFQUFvQ0YsU0FBcEM7UUFDRCxDQUZEO01BR0QsQ0FSRDs7TUFTQSxLQUFLTCx5QkFBTCxHQUFpQ0YsMkJBQTJCLENBQUNHLFNBQUQsRUFBWWpSLEVBQVosQ0FBNUQ7SUFDRCxDQW5CRDs7SUFvQkEsS0FBS3dSLGFBQUwsR0FBcUIsTUFBTTtNQUN6QixNQUFNO1FBQUVDLGVBQUY7UUFBbUJqQjtNQUFuQixJQUFzQyxJQUE1Qzs7TUFDQSxJQUFJQSxjQUFjLEtBQUssT0FBbkIsSUFBOEJpQixlQUFlLEtBQUt0TSxTQUF0RCxFQUFpRTtRQUMvRDtBQUNSO0FBQ0E7QUFDQTtBQUNBO1FBQ1E7TUFDRDs7TUFDRCxLQUFLdU0sb0JBQUw7SUFDRCxDQVhEOztJQVlBLEtBQUtDLGFBQUwsR0FBcUIsTUFBTTtNQUN6QixNQUFNO1FBQUVGO01BQUYsSUFBc0IsSUFBNUI7O01BQ0EsSUFBSUEsZUFBZSxLQUFLdE0sU0FBeEIsRUFBbUM7UUFDakM7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO1FBQ1E7TUFDRDs7TUFDRCxLQUFLckMsT0FBTCxDQUFhcUMsU0FBYixFQUF3QnpDLG9EQUF4QjtJQUNELENBWkQ7O0lBYUEsS0FBS2tQLFdBQUwsR0FBb0JDLFVBQUQsSUFBZ0I7TUFDakMsTUFBTTdSLEVBQUUsR0FBRyxLQUFLOFIsWUFBaEI7TUFDQSxNQUFNQyxJQUFJLEdBQUdDLGFBQWEsQ0FBQ0gsVUFBVSxDQUFDSSxJQUFaLENBQTFCOztNQUNBLElBQUlqUyxFQUFFLElBQUkrUixJQUFWLEVBQWdCO1FBQ2QsTUFBTUcsRUFBRSxHQUFHLElBQUlDLFdBQUosQ0FBZ0JKLElBQWhCLEVBQXNCO1VBQy9CSyxPQUFPLEVBQUUsS0FEc0I7VUFFL0JDLFVBQVUsRUFBRSxLQUZtQjtVQUcvQjdMLE1BQU0sRUFBRXFMLFVBQVUsQ0FBQ3JMO1FBSFksQ0FBdEIsQ0FBWDtRQUtBeEcsRUFBRSxDQUFDc1MsYUFBSCxDQUFpQkosRUFBakI7TUFDRDtJQUNGLENBWEQ7RUFZRDs7RUFDREssY0FBYyxDQUFDQyxRQUFELEVBQVdDLFFBQVgsRUFBcUI7SUFDakMsSUFBSUQsUUFBUSxLQUFLLElBQWIsSUFBcUJDLFFBQVEsS0FBSyxLQUF0QyxFQUE2QztNQUMzQyxLQUFLN1AsT0FBTDtJQUNELENBRkQsTUFHSyxJQUFJNFAsUUFBUSxLQUFLLEtBQWIsSUFBc0JDLFFBQVEsS0FBSyxJQUF2QyxFQUE2QztNQUNoRCxLQUFLM1AsT0FBTDtJQUNEO0VBQ0Y7O0VBQ0Q0UCxlQUFlLEdBQUc7SUFDaEIsS0FBSzVCLDJCQUFMO0VBQ0Q7O0VBQ0s2QixtQkFBbUIsQ0FBQ3RLLE1BQUQsRUFBUztJQUFBOztJQUFBO01BQ2hDLElBQUksS0FBSSxDQUFDRCxPQUFULEVBQWtCO1FBQ2hCLEtBQUksQ0FBQ0EsT0FBTCxDQUFhQyxNQUFiLENBQW9CQSxNQUFwQjtNQUNELENBRkQsTUFHSyxJQUFJQSxNQUFKLEVBQVk7UUFDZixNQUFNLEtBQUksQ0FBQ3VLLGdCQUFMLEVBQU47TUFDRDtJQU4rQjtFQU9qQzs7RUFDREMsa0JBQWtCLENBQUMvRixXQUFELEVBQWM7SUFDOUIsSUFBSUEsV0FBVyxLQUFLM0gsU0FBcEIsRUFBK0I7TUFDN0IsS0FBSzJOLGlCQUFMLEdBQXlCaEcsV0FBVyxDQUFDaUcsSUFBWixDQUFpQixDQUFDMVMsQ0FBRCxFQUFJQyxDQUFKLEtBQVVELENBQUMsR0FBR0MsQ0FBL0IsQ0FBekI7SUFDRDtFQUNGOztFQUNEMFMsaUJBQWlCLEdBQUc7SUFDbEJyUSx3REFBYyxDQUFDLEtBQUszQyxFQUFOLENBQWQ7RUFDRDs7RUFDRGlULGlCQUFpQixHQUFHO0lBQ2xCLE1BQU07TUFBRW5HLFdBQUY7TUFBZUQsaUJBQWY7TUFBa0MrRCxZQUFsQztNQUFnRDVRO0lBQWhELElBQXVELElBQTdEO0lBQ0EsS0FBS2tRLG1CQUFMLEdBQTJCM04sdURBQWlCLENBQUN2QyxFQUFELEVBQUssQ0FBQyxNQUFELENBQUwsQ0FBNUM7SUFDQTtBQUNKO0FBQ0E7QUFDQTs7SUFDSSxLQUFLa1QsT0FBTCxHQUFlLEtBQUtsVCxFQUFMLENBQVFtVCxZQUFSLENBQXFCLElBQXJCLElBQTZCLEtBQUtuVCxFQUFMLENBQVFvVCxZQUFSLENBQXFCLElBQXJCLENBQTdCLEdBQTJELGFBQVksS0FBS3RELFVBQVcsRUFBdEc7SUFDQSxNQUFNRyxZQUFZLEdBQUksS0FBS0EsWUFBTCxHQUFvQm5ELFdBQVcsS0FBSzNILFNBQWhCLElBQTZCMEgsaUJBQWlCLEtBQUsxSCxTQUE3Rjs7SUFDQSxJQUFJOEssWUFBSixFQUFrQjtNQUNoQixLQUFLbEgsaUJBQUwsR0FBeUIsS0FBSzhELGlCQUE5QjtJQUNEOztJQUNELElBQUlDLFdBQVcsS0FBSzNILFNBQWhCLElBQTZCMEgsaUJBQWlCLEtBQUsxSCxTQUFuRCxJQUFnRSxDQUFDMkgsV0FBVyxDQUFDdUcsUUFBWixDQUFxQnhHLGlCQUFyQixDQUFyRSxFQUE4RztNQUM1R3JOLHFEQUFlLENBQUMsa0VBQUQsQ0FBZjtJQUNEOztJQUNELElBQUlvUixZQUFKLEVBQWtCO01BQ2hCcFIscURBQWUsQ0FBQyxxUEFBRCxDQUFmO0lBQ0Q7RUFDRjs7RUFDRDhULGdCQUFnQixHQUFHO0lBQ2pCO0FBQ0o7QUFDQTtBQUNBO0lBQ0ksSUFBSSxLQUFLeE4sTUFBTCxLQUFnQixJQUFwQixFQUEwQjtNQUN4QnpELHVEQUFHLENBQUMsTUFBTSxLQUFLTyxPQUFMLEVBQVAsQ0FBSDtJQUNEOztJQUNELEtBQUtpUSxrQkFBTCxDQUF3QixLQUFLL0YsV0FBN0I7SUFDQSxLQUFLZ0UsMkJBQUw7RUFDRDtFQUNEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0VBQ0V5QyxXQUFXLENBQUNDLEtBQUssR0FBRyxLQUFULEVBQWdCO0lBQ3pCLElBQUksS0FBS0MsZUFBTCxJQUF3QixDQUFDRCxLQUE3QixFQUFvQztNQUNsQyxPQUFPO1FBQ0xFLFFBQVEsRUFBRSxLQUFLRCxlQURWO1FBRUx0RCxNQUFNLEVBQUUsS0FBS0E7TUFGUixDQUFQO0lBSUQ7SUFDRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztJQUNJLE1BQU13RCxRQUFRLEdBQUcsS0FBSzNULEVBQUwsQ0FBUTRULFVBQXpCO0lBQ0EsTUFBTXpELE1BQU0sR0FBSSxLQUFLQSxNQUFMLEdBQWN3RCxRQUFRLEtBQUssSUFBYixJQUFxQixDQUFDLEtBQUtyRCxhQUF6RDtJQUNBLE1BQU1vRCxRQUFRLEdBQUksS0FBS0QsZUFBTCxHQUF1QnRELE1BQU0sR0FBRyxLQUFLdUQsUUFBTCxJQUFpQixLQUFLMUQsWUFBekIsR0FBd0MsS0FBSzBELFFBQTVGO0lBQ0EsT0FBTztNQUFFdkQsTUFBRjtNQUFVdUQ7SUFBVixDQUFQO0VBQ0Q7RUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7RUFDUUcsZUFBZSxHQUFHO0lBQUE7O0lBQUE7TUFDdEIsTUFBTTtRQUFFOU87TUFBRixJQUFpQixNQUF2QjtNQUNBO0FBQ0o7QUFDQTtBQUNBOztNQUNJLElBQUlBLFVBQVUsS0FBS0ksU0FBbkIsRUFBOEI7UUFDNUIsT0FBTyxJQUFQO01BQ0Q7O01BQ0QsSUFBSSxPQUFPSixVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO1FBQ3BDLE9BQU9BLFVBQVUsRUFBakI7TUFDRDs7TUFDRCxPQUFPQSxVQUFQO0lBWnNCO0VBYXZCO0VBQ0Q7QUFDRjtBQUNBOzs7RUFDUW5DLE9BQU8sR0FBRztJQUFBOztJQUFBO01BQ2QsSUFBSSxNQUFJLENBQUN5TixTQUFULEVBQW9CO1FBQ2xCO01BQ0Q7TUFDRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7TUFDSSxJQUFJLE1BQUksQ0FBQ3lELGlCQUFMLEtBQTJCM08sU0FBL0IsRUFBMEM7UUFDeEMsTUFBTSxNQUFJLENBQUMyTyxpQkFBWDtNQUNEO01BQ0Q7QUFDSjtBQUNBO0FBQ0E7OztNQUNJLE1BQUksQ0FBQy9LLGlCQUFMLEdBQXlCLE1BQUksQ0FBQzhELGlCQUE5QjtNQUNBLE1BQU1rSCxJQUFJLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjRCxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLE1BQUksQ0FBQ0MsY0FBdkIsQ0FBZCxFQUFzRDtRQUFFQyxLQUFLLEVBQUUsTUFBSSxDQUFDblU7TUFBZCxDQUF0RCxDQUFiOztNQUNBLE1BQU07UUFBRW1RLE1BQUY7UUFBVXVEO01BQVYsSUFBdUIsTUFBSSxDQUFDSCxXQUFMLENBQWlCLElBQWpCLENBQTdCOztNQUNBLE1BQUksQ0FBQ3pCLFlBQUwsU0FBMEIvUCxrRUFBZSxDQUFDMlIsUUFBRCxFQUFXLE1BQUksQ0FBQzFULEVBQWhCLEVBQW9CLE1BQUksQ0FBQ29VLFNBQXpCLEVBQW9DLENBQUMsVUFBRCxDQUFwQyxFQUFrREwsSUFBbEQsRUFBd0Q1RCxNQUF4RCxDQUF6QztNQUNBLE1BQU1sTixzREFBUyxDQUFDLE1BQUksQ0FBQzZPLFlBQU4sQ0FBZjtNQUNBalIscURBQVMsQ0FBQyxNQUFNLE1BQUksQ0FBQ2IsRUFBTCxDQUFRNE4sU0FBUixDQUFrQkcsR0FBbEIsQ0FBc0IsWUFBdEIsQ0FBUCxDQUFUO01BQ0EsTUFBSSxDQUFDK0YsaUJBQUwsR0FBeUJsUix3REFBTyxDQUFDLE1BQUQsRUFBTyxZQUFQLEVBQXFCb0gsaUJBQXJCLEVBQXdDdUMsZ0JBQXhDLEVBQTBEO1FBQ3hGckMsWUFBWSxFQUFFLE1BQUksQ0FBQ1EsaUJBRHFFO1FBRXhGM0IsaUJBQWlCLEVBQUUsTUFBSSxDQUFDOEQsaUJBRmdFO1FBR3hGeEksa0JBQWtCLEVBQUUsTUFBSSxDQUFDQTtNQUgrRCxDQUExRCxDQUFoQztNQUtBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7TUFDSSxNQUFNb0csWUFBWSxHQUFHLE1BQUksQ0FBQ21HLFlBQUwsSUFBc0IsTUFBSSxDQUFDN0wsVUFBTCxLQUFvQkksU0FBcEIsSUFBaUMsTUFBSSxDQUFDdUYsaUJBQUwsS0FBMkJ2RixTQUF2RztNQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O01BQ0ksSUFBSXNGLFlBQVksSUFBSXRKLDREQUFVLENBQUMsTUFBRCxDQUFWLEtBQXFCLEtBQXpDLEVBQWdEO1FBQzlDb0Qsb0JBQW9CO01BQ3JCOztNQUNELE1BQU0sTUFBSSxDQUFDdVAsaUJBQVg7O01BQ0EsSUFBSSxNQUFJLENBQUM3RCxZQUFULEVBQXVCO1FBQ3JCLE1BQUksQ0FBQ29FLGdCQUFMO01BQ0QsQ0FGRCxNQUdLLElBQUk1SixZQUFKLEVBQWtCO1FBQ3JCLE1BQU0sTUFBSSxDQUFDbUksZ0JBQUwsRUFBTjtNQUNEO01BQ0Q7OztNQUNBLElBQUksT0FBT3BJLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7UUFDakMsTUFBSSxDQUFDOEosb0JBQUwsR0FBNEIsTUFBTTtVQUNoQyxJQUFJLE1BQUksQ0FBQ2xNLE9BQVQsRUFBa0I7WUFDaEI7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO1lBQ1UsTUFBSSxDQUFDQSxPQUFMLENBQWFDLE1BQWIsQ0FBb0IsS0FBcEI7O1lBQ0FoRyx1REFBRyxDQUFDLE1BQU07Y0FDUixJQUFJLE1BQUksQ0FBQytGLE9BQVQsRUFBa0I7Z0JBQ2hCLE1BQUksQ0FBQ0EsT0FBTCxDQUFhQyxNQUFiLENBQW9CLElBQXBCO2NBQ0Q7WUFDRixDQUpFLENBQUg7VUFLRDtRQUNGLENBbEJEOztRQW1CQW1DLE1BQU0sQ0FBQzhHLGdCQUFQLENBQXdCOU8sb0VBQXhCLEVBQTJDLE1BQUksQ0FBQzhSLG9CQUFoRDtNQUNEOztNQUNELE1BQUksQ0FBQ1IsaUJBQUwsR0FBeUIzTyxTQUF6QjtJQTlFYztFQStFZjs7RUFDRHlOLGdCQUFnQixHQUFHO0lBQUE7O0lBQ2pCLElBQUl6Uiw0REFBVSxDQUFDLElBQUQsQ0FBVixLQUFxQixLQUF6QixFQUFnQztNQUM5QjtJQUNEOztJQUNELE1BQU07TUFBRW5CO0lBQUYsSUFBUyxJQUFmLENBSmlCLENBS2pCO0lBQ0E7SUFDQTs7SUFDQSxNQUFNdVUsZ0JBQWdCLEdBQUcsS0FBS0MsY0FBTCxJQUF1QnBULDREQUFBLENBQVcsWUFBWCxFQUF5QjBLLGlCQUF6QixDQUFoRDtJQUNBLE1BQU15QixHQUFHLEdBQUksS0FBS3pJLFNBQUwsR0FBaUJ5UCxnQkFBZ0IsQ0FBQ3ZVLEVBQUQsRUFBSztNQUFFa0ssWUFBWSxFQUFFLEtBQUtRO0lBQXJCLENBQUwsQ0FBOUM7SUFDQSxNQUFNMUUsU0FBUyxHQUFHckUscURBQWMsQ0FBQzNCLEVBQUQsQ0FBaEM7O0lBQ0EsSUFBSSxDQUFDZ0csU0FBTCxFQUFnQjtNQUNkcEUscURBQXVCLENBQUM1QixFQUFELENBQXZCO01BQ0E7SUFDRDs7SUFDRCxLQUFLb0ksT0FBTCxHQUFlM0MseUJBQXlCLENBQUN6RixFQUFELEVBQUt1TixHQUFMLEVBQVUsTUFBTTtNQUN0RDtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtNQUNNLEtBQUs2QywwQkFBTCxHQUFrQyxJQUFsQztNQUNBLEtBQUt0TCxTQUFMLENBQWVJLFFBQWYsNEpBQXdCLGFBQVk7UUFDbEMsTUFBTSxNQUFJLENBQUNwQyxPQUFMLENBQWFxQyxTQUFiLEVBQXdCLFNBQXhCLENBQU47UUFDQSxNQUFJLENBQUNpTCwwQkFBTCxHQUFrQyxLQUFsQztNQUNELENBSEQ7SUFJRCxDQWhCdUMsQ0FBeEM7SUFpQkEsS0FBS2hJLE9BQUwsQ0FBYUMsTUFBYixDQUFvQixJQUFwQjtFQUNEOztFQUNEZ00sZ0JBQWdCLEdBQUc7SUFDakIsTUFBTTtNQUFFekgsU0FBRjtNQUFhQyxpQkFBYjtNQUFnQ3hJO0lBQWhDLElBQXVELElBQTdEOztJQUNBLElBQUksQ0FBQ3VJLFNBQUQsSUFBY0MsaUJBQWlCLEtBQUsxSCxTQUF4QyxFQUFtRDtNQUNqRDtJQUNEOztJQUNELE1BQU1vUCxnQkFBZ0IsR0FBRyxLQUFLRyxjQUFMLElBQXVCdFQsNERBQUEsQ0FBVyxZQUFYLEVBQXlCNEksaUJBQXpCLENBQWhEO0lBQ0EsTUFBTXVELEdBQUcsR0FBSSxLQUFLekksU0FBTCxHQUFpQnlQLGdCQUFnQixDQUFDLEtBQUt2VSxFQUFOLEVBQVU7TUFDdERrSyxZQUFZLEVBQUUsS0FBS1EsaUJBRG1DO01BRXREM0IsaUJBQWlCLEVBQUU4RCxpQkFGbUM7TUFHdER4STtJQUhzRCxDQUFWLENBQTlDO0lBS0FrSixHQUFHLENBQUNwRyxhQUFKLENBQWtCLElBQWxCLEVBQXdCLENBQXhCO0lBQ0EsTUFBTTtNQUFFaUIsT0FBRjtNQUFXb0c7SUFBWCxJQUFxQzlCLGtCQUFrQixDQUFDLEtBQUsxTSxFQUFOLEVBQVUsS0FBSzJNLFVBQWYsRUFBMkJDLFNBQTNCLEVBQXNDQyxpQkFBdEMsRUFBeUR4SSxrQkFBekQsRUFBNkVrSixHQUE3RSxFQUFrRixLQUFLdUYsaUJBQXZGLEVBQTBHLE1BQU07TUFBRSxJQUFJcFAsRUFBSjs7TUFBUSxPQUFPLENBQUNBLEVBQUUsR0FBRyxLQUFLcUYsaUJBQVgsTUFBa0MsSUFBbEMsSUFBMENyRixFQUFFLEtBQUssS0FBSyxDQUF0RCxHQUEwREEsRUFBMUQsR0FBK0QsQ0FBdEU7SUFBMEUsQ0FBcE0sRUFBc00sTUFBTSxLQUFLaVIsY0FBTCxFQUE1TSxFQUFvT2xHLFVBQUQsSUFBZ0I7TUFDOVMsSUFBSSxLQUFLMUYsaUJBQUwsS0FBMkIwRixVQUEvQixFQUEyQztRQUN6QyxLQUFLMUYsaUJBQUwsR0FBeUIwRixVQUF6QjtRQUNBLEtBQUtnQixzQkFBTCxDQUE0Qm1GLElBQTVCLENBQWlDO1VBQUVuRztRQUFGLENBQWpDO01BQ0Q7SUFDRixDQUw0RCxDQUE3RDtJQU1BLEtBQUtyRyxPQUFMLEdBQWVBLE9BQWY7SUFDQSxLQUFLb0cscUJBQUwsR0FBNkJBLHFCQUE3QjtJQUNBLEtBQUtwRyxPQUFMLENBQWFDLE1BQWIsQ0FBb0IsSUFBcEI7RUFDRDs7RUFDRHNNLGNBQWMsR0FBRztJQUFBOztJQUNmO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ0ksS0FBS3ZFLDBCQUFMLEdBQWtDLElBQWxDO0lBQ0EsS0FBS3RMLFNBQUwsQ0FBZUksUUFBZiw0SkFBd0IsYUFBWTtNQUNsQyxNQUFJLENBQUM2RCxpQkFBTCxHQUF5QixDQUF6Qjs7TUFDQSxNQUFJLENBQUMwRyxzQkFBTCxDQUE0Qm1GLElBQTVCLENBQWlDO1FBQUVuRyxVQUFVLEVBQUUsTUFBSSxDQUFDMUY7TUFBbkIsQ0FBakM7O01BQ0EsTUFBTSxNQUFJLENBQUNqRyxPQUFMLENBQWFxQyxTQUFiLEVBQXdCLFNBQXhCLENBQU47TUFDQSxNQUFJLENBQUNpTCwwQkFBTCxHQUFrQyxLQUFsQztJQUNELENBTEQ7RUFNRDtFQUNEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0VBQ1F0TixPQUFPLENBQUNpUixJQUFELEVBQU9jLElBQVAsRUFBYTtJQUFBOztJQUFBO01BQ3hCLElBQUluUixFQUFKOztNQUNBLElBQUksTUFBSSxDQUFDME0sMEJBQUwsSUFBbUN5RSxJQUFJLEtBQUssU0FBaEQsRUFBMkQ7UUFDekQsT0FBTyxLQUFQO01BQ0Q7TUFDRDtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7TUFDSSxJQUFJQSxJQUFJLEtBQUssU0FBVCxJQUFzQixRQUFRLE1BQUksQ0FBQ2hCLGVBQUwsRUFBUixDQUExQixFQUEyRDtRQUN6RCxPQUFPLEtBQVA7TUFDRDtNQUNEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O01BQ0ksTUFBTXBKLFlBQVksR0FBRyxNQUFJLENBQUNtRyxZQUFMLElBQXNCLE1BQUksQ0FBQzdMLFVBQUwsS0FBb0JJLFNBQXBCLElBQWlDLE1BQUksQ0FBQ3VGLGlCQUFMLEtBQTJCdkYsU0FBdkc7O01BQ0EsSUFBSXNGLFlBQVksSUFBSXRKLDREQUFVLENBQUMsTUFBRCxDQUFWLEtBQXFCLEtBQXpDLEVBQWdEO1FBQzlDd0QsdUJBQXVCO01BQ3hCO01BQ0Q7OztNQUNBLElBQUksT0FBTzZGLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUMsTUFBSSxDQUFDOEosb0JBQTFDLEVBQWdFO1FBQzlEOUosTUFBTSxDQUFDK0csbUJBQVAsQ0FBMkIvTyxvRUFBM0IsRUFBOEMsTUFBSSxDQUFDOFIsb0JBQW5EO01BQ0Q7TUFDRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7TUFDSSxJQUFJLE1BQUksQ0FBQ1IsaUJBQUwsS0FBMkIzTyxTQUEvQixFQUEwQztRQUN4QyxNQUFNLE1BQUksQ0FBQzJPLGlCQUFYO01BQ0Q7O01BQ0QsTUFBTWdCLGlCQUFpQixHQUFHalMsd0RBQUEsQ0FBcUIsTUFBckIsS0FBOEIsRUFBeEQ7TUFDQSxNQUFJLENBQUNpUixpQkFBTCxHQUF5QmhSLHdEQUFPLENBQUMsTUFBRCxFQUFPaVIsSUFBUCxFQUFhYyxJQUFiLEVBQW1CLFlBQW5CLEVBQWlDL0ksaUJBQWpDLEVBQW9EVyxnQkFBcEQsRUFBc0U7UUFDcEd2QyxZQUFZLEVBQUUsTUFBSSxDQUFDUSxpQkFEaUY7UUFFcEczQixpQkFBaUIsRUFBRSxDQUFDckYsRUFBRSxHQUFHLE1BQUksQ0FBQ3FGLGlCQUFYLE1BQWtDLElBQWxDLElBQTBDckYsRUFBRSxLQUFLLEtBQUssQ0FBdEQsR0FBMERBLEVBQTFELEdBQStELE1BQUksQ0FBQ21KLGlCQUZhO1FBR3BHeEksa0JBQWtCLEVBQUUsTUFBSSxDQUFDQTtNQUgyRSxDQUF0RSxDQUFoQztNQUtBLE1BQU0wUSxTQUFTLFNBQVMsTUFBSSxDQUFDakIsaUJBQTdCOztNQUNBLElBQUlpQixTQUFKLEVBQWU7UUFDYixNQUFNO1VBQUVyQjtRQUFGLElBQWUsTUFBSSxDQUFDSCxXQUFMLEVBQXJCOztRQUNBLE1BQU12UixrRUFBZSxDQUFDMFIsUUFBRCxFQUFXLE1BQUksQ0FBQzVCLFlBQWhCLENBQXJCO1FBQ0FqUixxREFBUyxDQUFDLE1BQU0sTUFBSSxDQUFDYixFQUFMLENBQVE0TixTQUFSLENBQWtCQyxNQUFsQixDQUF5QixZQUF6QixDQUFQLENBQVQ7O1FBQ0EsSUFBSSxNQUFJLENBQUMvSSxTQUFULEVBQW9CO1VBQ2xCLE1BQUksQ0FBQ0EsU0FBTCxDQUFla1EsT0FBZjtRQUNEOztRQUNELElBQUksTUFBSSxDQUFDNU0sT0FBVCxFQUFrQjtVQUNoQixNQUFJLENBQUNBLE9BQUwsQ0FBYTRNLE9BQWI7UUFDRDs7UUFDREYsaUJBQWlCLENBQUNHLE9BQWxCLENBQTJCMUgsR0FBRCxJQUFTQSxHQUFHLENBQUN5SCxPQUFKLEVBQW5DO01BQ0Q7O01BQ0QsTUFBSSxDQUFDak0saUJBQUwsR0FBeUI1RCxTQUF6QjtNQUNBLE1BQUksQ0FBQzJPLGlCQUFMLEdBQXlCM08sU0FBekI7TUFDQSxNQUFJLENBQUNMLFNBQUwsR0FBaUJLLFNBQWpCO01BQ0EsT0FBTzRQLFNBQVA7SUE1RHdCO0VBNkR6QjtFQUNEO0FBQ0Y7QUFDQTs7O0VBQ0VHLFlBQVksR0FBRztJQUNiLE9BQU9uUyx3REFBVyxDQUFDLEtBQUsvQyxFQUFOLEVBQVUsb0JBQVYsQ0FBbEI7RUFDRDtFQUNEO0FBQ0Y7QUFDQTs7O0VBQ0VtVixhQUFhLEdBQUc7SUFDZCxPQUFPcFMsd0RBQVcsQ0FBQyxLQUFLL0MsRUFBTixFQUFVLHFCQUFWLENBQWxCO0VBQ0Q7RUFDRDtBQUNGO0FBQ0E7QUFDQTs7O0VBQ1FvVixvQkFBb0IsQ0FBQzNHLFVBQUQsRUFBYTtJQUFBOztJQUFBO01BQ3JDLElBQUksQ0FBQyxNQUFJLENBQUN3QixZQUFWLEVBQXdCO1FBQ3RCelEscURBQWUsQ0FBQyx5REFBRCxDQUFmO1FBQ0E7TUFDRDs7TUFDRCxJQUFJLENBQUMsTUFBSSxDQUFDc04sV0FBTCxDQUFpQnVHLFFBQWpCLENBQTBCNUUsVUFBMUIsQ0FBTCxFQUE0QztRQUMxQ2pQLHFEQUFlLENBQUUsNkNBQTRDaVAsVUFBVyxzRkFBekQsQ0FBZjtRQUNBO01BQ0Q7O01BQ0QsTUFBTTtRQUFFMUYsaUJBQUY7UUFBcUJ5RixxQkFBckI7UUFBNEN6SixVQUE1QztRQUF3RCtIO01BQXhELElBQXdFLE1BQTlFOztNQUNBLElBQUkvRCxpQkFBaUIsS0FBSzBGLFVBQTFCLEVBQXNDO1FBQ3BDO01BQ0Q7O01BQ0QsSUFBSUQscUJBQUosRUFBMkI7UUFDekIsTUFBSSxDQUFDaUQsZUFBTCxHQUF1QmpELHFCQUFxQixDQUFDO1VBQzNDQyxVQUQyQztVQUUzQ0MsZ0JBQWdCLEVBQUUsSUFBSTNGLGlCQUZxQjtVQUczQ2hFLFVBQVUsRUFBRUEsVUFBVSxLQUFLSSxTQUFmLElBQTRCSixVQUFVLEtBQUssSUFBM0MsSUFBbUQrSCxXQUFXLENBQUMsQ0FBRCxDQUFYLEtBQW1CO1FBSHZDLENBQUQsQ0FBNUM7UUFLQSxNQUFNLE1BQUksQ0FBQzJFLGVBQVg7UUFDQSxNQUFJLENBQUNBLGVBQUwsR0FBdUJ0TSxTQUF2QjtNQUNEO0lBckJvQztFQXNCdEM7RUFDRDtBQUNGO0FBQ0E7OztFQUNRNEgsb0JBQW9CLEdBQUc7SUFBQTs7SUFBQTtNQUMzQixPQUFPLE1BQUksQ0FBQ2hFLGlCQUFaO0lBRDJCO0VBRTVCOztFQUNLMkksb0JBQW9CLEdBQUc7SUFBQTs7SUFBQTtNQUMzQixNQUFNO1FBQUU1RSxXQUFGO1FBQWUvRDtNQUFmLElBQXFDLE1BQTNDOztNQUNBLElBQUksQ0FBQytELFdBQUQsSUFBZ0IvRCxpQkFBaUIsSUFBSSxJQUF6QyxFQUErQztRQUM3QztBQUNOO0FBQ0E7QUFDQTtRQUNNLE9BQU8sS0FBUDtNQUNEOztNQUNELE1BQU1zTSxrQkFBa0IsR0FBR3ZJLFdBQVcsQ0FBQ3BCLE1BQVosQ0FBb0JwTCxDQUFELElBQU9BLENBQUMsS0FBSyxDQUFoQyxDQUEzQjtNQUNBLE1BQU1nVixzQkFBc0IsR0FBR0Qsa0JBQWtCLENBQUNFLE9BQW5CLENBQTJCeE0saUJBQTNCLENBQS9CO01BQ0EsTUFBTXlNLG1CQUFtQixHQUFHLENBQUNGLHNCQUFzQixHQUFHLENBQTFCLElBQStCRCxrQkFBa0IsQ0FBQ2hKLE1BQTlFO01BQ0EsTUFBTW9KLGNBQWMsR0FBR0osa0JBQWtCLENBQUNHLG1CQUFELENBQXpDO01BQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7TUFDSSxNQUFNLE1BQUksQ0FBQ0osb0JBQUwsQ0FBMEJLLGNBQTFCLENBQU47TUFDQSxPQUFPLElBQVA7SUFuQjJCO0VBb0I1Qjs7RUFDREMsTUFBTSxHQUFHO0lBQ1AsTUFBTTtNQUFFQyxNQUFGO01BQVUxRixZQUFWO01BQXdCdkYsaUJBQXhCO01BQTJDa0wsY0FBM0M7TUFBMkRwRixjQUEzRDtNQUEyRU47SUFBM0UsSUFBbUcsSUFBekc7SUFDQSxNQUFNMkYsVUFBVSxHQUFHRixNQUFNLEtBQUssS0FBWCxJQUFvQjFGLFlBQXZDO0lBQ0EsTUFBTTZGLElBQUksR0FBRzNVLDREQUFVLENBQUMsSUFBRCxDQUF2QjtJQUNBLE1BQU07TUFBRStSO0lBQUYsSUFBYyxJQUFwQjtJQUNBLE1BQU02QyxXQUFXLEdBQUdyTCxpQkFBaUIsS0FBS3ZGLFNBQXRCLElBQW1DMlEsSUFBSSxLQUFLLEtBQWhFO0lBQ0EsTUFBTUUsYUFBYSxHQUFHeEYsY0FBYyxLQUFLLE9BQXpDO0lBQ0EsT0FBUTFQLHFEQUFDLENBQUNFLGlEQUFELEVBQU9nVCxNQUFNLENBQUNDLE1BQVAsQ0FBYztNQUFFLGFBQWEsSUFBZjtNQUFxQixjQUFjLE1BQW5DO01BQTJDWSxJQUFJLEVBQUUsUUFBakQ7TUFBMkRvQixRQUFRLEVBQUU7SUFBckUsQ0FBZCxFQUEyRkwsY0FBM0YsRUFBMkcxRixtQkFBM0csRUFBZ0k7TUFBRXpMLEtBQUssRUFBRTtRQUNySnlSLE1BQU0sRUFBRyxHQUFFLFFBQVEsS0FBS0MsWUFBYTtNQURnSCxDQUFUO01BRTNJQyxLQUFLLEVBQUVwQyxNQUFNLENBQUNDLE1BQVAsQ0FBYztRQUFFLENBQUM2QixJQUFELEdBQVEsSUFBVjtRQUFnQixDQUFDLGVBQUQsR0FBbUIsQ0FBQ0MsV0FBRCxJQUFnQixDQUFDOUYsWUFBcEQ7UUFBa0UsQ0FBRSxZQUFGLEdBQWdCOEYsV0FBbEY7UUFBK0YsQ0FBRSxhQUFGLEdBQWlCOUYsWUFBaEg7UUFBOEgsa0JBQWtCO01BQWhKLENBQWQsRUFBc0tqTixxREFBVyxDQUFDLEtBQUtxVCxRQUFOLENBQWpMLENBRm9JO01BRStEN0ksRUFBRSxFQUFFMEYsT0FGbkU7TUFFNEVvRCxnQkFBZ0IsRUFBRSxLQUFLM0UsYUFGbkc7TUFFa0g0RSxvQkFBb0IsRUFBRSxLQUFLM0UsV0FGN0k7TUFFMEo0RSxxQkFBcUIsRUFBRSxLQUFLNUUsV0FGdEw7TUFFbU02RSxxQkFBcUIsRUFBRSxLQUFLN0UsV0FGL047TUFFNE84RSxvQkFBb0IsRUFBRSxLQUFLOUU7SUFGdlEsQ0FBaEksQ0FBUCxFQUU4WjlRLHFEQUFDLENBQUMsY0FBRCxFQUFpQjtNQUFFNlYsR0FBRyxFQUFHM1csRUFBRCxJQUFTLEtBQUsyTSxVQUFMLEdBQWtCM00sRUFBbEM7TUFBdUM0VyxPQUFPLEVBQUUsS0FBS2xHLFlBQXJEO01BQW1FbUcsUUFBUSxFQUFFLEtBQUtwRyxlQUFsRjtNQUFtR3FHLElBQUksRUFBRTtJQUF6RyxDQUFqQixDQUYvWixFQUV3aUJoQixJQUFJLEtBQUssS0FBVCxJQUFrQmhWLHFEQUFDLENBQUMsS0FBRCxFQUFRO01BQUVzVixLQUFLLEVBQUU7SUFBVCxDQUFSLENBRjNqQixFQUUrbEJ0VixxREFBQyxDQUFDLEtBQUQsRUFBUTtNQUFFc1YsS0FBSyxFQUFFLG1DQUFUO01BQThDVSxJQUFJLEVBQUUsU0FBcEQ7TUFBK0RILEdBQUcsRUFBRzNXLEVBQUQsSUFBUyxLQUFLNE0sU0FBTCxHQUFpQjVNO0lBQTlGLENBQVIsRUFBNkc2VixVQUFVLElBQUsvVSxxREFBQyxDQUFDLFFBQUQsRUFBVztNQUFFc1YsS0FBSyxFQUFFLGNBQVQ7TUFDL3VCO01BQ0FXLFFBQVEsRUFBRSxDQUFDZixhQUFELEdBQWlCLENBQUMsQ0FBbEIsR0FBc0IsQ0FGK3NCO01BRTVzQixjQUFjLGlFQUY4ckI7TUFFM25CZ0IsT0FBTyxFQUFFaEIsYUFBYSxHQUFHLEtBQUt4RSxhQUFSLEdBQXdCck0sU0FGNmtCO01BRWxrQjJSLElBQUksRUFBRTtJQUY0akIsQ0FBWCxDQUE3SCxFQUV0YWhXLHFEQUFDLENBQUMsTUFBRCxFQUFTLElBQVQsQ0FGcWEsQ0FGaG1CLENBQVQ7RUFLRDs7RUFDSyxJQUFGZCxFQUFFLEdBQUc7SUFBRSxPQUFPa0IscURBQVUsQ0FBQyxJQUFELENBQWpCO0VBQTBCOztFQUNsQixXQUFSK1YsUUFBUSxHQUFHO0lBQUUsT0FBTztNQUM3QixVQUFVLENBQUMsZ0JBQUQsQ0FEbUI7TUFFN0IsV0FBVyxDQUFDLGlCQUFELENBRmtCO01BRzdCLGdCQUFnQixDQUFDLHFCQUFEO0lBSGEsQ0FBUDtFQUlwQjs7QUFqakJjLENBQXBCO0FBbWpCQSxNQUFNakYsYUFBYSxHQUFHO0VBQ3BCa0Ysa0JBQWtCLEVBQUUsaUJBREE7RUFFcEJDLG1CQUFtQixFQUFFLGtCQUZEO0VBR3BCQyxtQkFBbUIsRUFBRSxrQkFIRDtFQUlwQkMsa0JBQWtCLEVBQUU7QUFKQSxDQUF0QjtBQU1BLElBQUl0SCxRQUFRLEdBQUcsQ0FBZjtBQUNBYixLQUFLLENBQUN6SyxLQUFOLEdBQWM7RUFDWjZTLEdBQUcsRUFBRXRJLFdBRE87RUFFWnVJLEVBQUUsRUFBRXRJO0FBRlEsQ0FBZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbm5EQTtBQUNBO0FBQ0E7QUFDQSxNQUFNd0ksV0FBVyxHQUFHLENBQUNDLFFBQUQsRUFBVzFYLEVBQVgsS0FBa0I7RUFDcEMsT0FBT0EsRUFBRSxDQUFDMkcsT0FBSCxDQUFXK1EsUUFBWCxNQUF5QixJQUFoQztBQUNELENBRkQ7QUFHQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLGtCQUFrQixHQUFHLENBQUNDLEtBQUQsRUFBUUMsV0FBUixLQUF3QjtFQUNqRCxPQUFPLE9BQU9ELEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLEtBQUssQ0FBQ3ZMLE1BQU4sR0FBZSxDQUE1QyxHQUNIMkgsTUFBTSxDQUFDQyxNQUFQLENBQWM7SUFBRSxhQUFhLElBQWY7SUFBcUIsQ0FBRSxhQUFZMkQsS0FBTSxFQUFwQixHQUF3QjtFQUE3QyxDQUFkLEVBQW1FQyxXQUFuRSxDQURHLEdBQytFQSxXQUR0RjtBQUVELENBSEQ7O0FBSUEsTUFBTUMsWUFBWSxHQUFJQyxPQUFELElBQWE7RUFDaEMsSUFBSUEsT0FBTyxLQUFLNVMsU0FBaEIsRUFBMkI7SUFDekIsTUFBTTZTLEtBQUssR0FBRzlMLEtBQUssQ0FBQytMLE9BQU4sQ0FBY0YsT0FBZCxJQUF5QkEsT0FBekIsR0FBbUNBLE9BQU8sQ0FBQ0csS0FBUixDQUFjLEdBQWQsQ0FBakQ7SUFDQSxPQUFPRixLQUFLLENBQ1R0TSxNQURJLENBQ0k5SyxDQUFELElBQU9BLENBQUMsSUFBSSxJQURmLEVBRUp1WCxHQUZJLENBRUN2WCxDQUFELElBQU9BLENBQUMsQ0FBQ3dYLElBQUYsRUFGUCxFQUdKMU0sTUFISSxDQUdJOUssQ0FBRCxJQUFPQSxDQUFDLEtBQUssRUFIaEIsQ0FBUDtFQUlEOztFQUNELE9BQU8sRUFBUDtBQUNELENBVEQ7O0FBVUEsTUFBTW9DLFdBQVcsR0FBSStVLE9BQUQsSUFBYTtFQUMvQixNQUFNSSxHQUFHLEdBQUcsRUFBWjtFQUNBTCxZQUFZLENBQUNDLE9BQUQsQ0FBWixDQUFzQjlDLE9BQXRCLENBQStCclUsQ0FBRCxJQUFRdVgsR0FBRyxDQUFDdlgsQ0FBRCxDQUFILEdBQVMsSUFBL0M7RUFDQSxPQUFPdVgsR0FBUDtBQUNELENBSkQ7O0FBS0EsTUFBTUUsTUFBTSxHQUFHLHNCQUFmOztBQUNBLE1BQU1DLE9BQU87RUFBQSx3SkFBRyxXQUFPQyxHQUFQLEVBQVlyRyxFQUFaLEVBQWdCekosU0FBaEIsRUFBMkIzRCxTQUEzQixFQUF5QztJQUN2RCxJQUFJeVQsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxLQUFXLEdBQTFCLElBQWlDLENBQUNGLE1BQU0sQ0FBQ0csSUFBUCxDQUFZRCxHQUFaLENBQXRDLEVBQXdEO01BQ3RELE1BQU1FLE1BQU0sR0FBRzFOLFFBQVEsQ0FBQ2xFLGFBQVQsQ0FBdUIsWUFBdkIsQ0FBZjs7TUFDQSxJQUFJNFIsTUFBSixFQUFZO1FBQ1YsSUFBSXZHLEVBQUUsSUFBSSxJQUFWLEVBQWdCO1VBQ2RBLEVBQUUsQ0FBQ3dHLGNBQUg7UUFDRDs7UUFDRCxPQUFPRCxNQUFNLENBQUNFLElBQVAsQ0FBWUosR0FBWixFQUFpQjlQLFNBQWpCLEVBQTRCM0QsU0FBNUIsQ0FBUDtNQUNEO0lBQ0Y7O0lBQ0QsT0FBTyxLQUFQO0VBQ0QsQ0FYWTs7RUFBQSxnQkFBUHdULE9BQU87SUFBQTtFQUFBO0FBQUEsR0FBYiIsInNvdXJjZXMiOlsiLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vaW5kZXgtYzRiMTE2NzYuanMiLCIuL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS9pb24tbW9kYWwuZW50cnkuanMiLCIuL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS90aGVtZS03NjcwMzQxYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuLyoqXG4gKiBMb2dzIGEgd2FybmluZyB0byB0aGUgY29uc29sZSB3aXRoIGFuIElvbmljIHByZWZpeFxuICogdG8gaW5kaWNhdGUgdGhlIGxpYnJhcnkgdGhhdCBpcyB3YXJuaW5nIHRoZSBkZXZlbG9wZXIuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgc3RyaW5nIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkIHRvIHRoZSBjb25zb2xlLlxuICovXG5jb25zdCBwcmludElvbldhcm5pbmcgPSAobWVzc2FnZSwgLi4ucGFyYW1zKSA9PiB7XG4gIHJldHVybiBjb25zb2xlLndhcm4oYFtJb25pYyBXYXJuaW5nXTogJHttZXNzYWdlfWAsIC4uLnBhcmFtcyk7XG59O1xuLypcbiAqIExvZ3MgYW4gZXJyb3IgdG8gdGhlIGNvbnNvbGUgd2l0aCBhbiBJb25pYyBwcmVmaXhcbiAqIHRvIGluZGljYXRlIHRoZSBsaWJyYXJ5IHRoYXQgaXMgd2FybmluZyB0aGUgZGV2ZWxvcGVyLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIHN0cmluZyBtZXNzYWdlIHRvIGJlIGxvZ2dlZCB0byB0aGUgY29uc29sZS5cbiAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzdXBwbHkgdG8gdGhlIGNvbnNvbGUuZXJyb3IuXG4gKi9cbmNvbnN0IHByaW50SW9uRXJyb3IgPSAobWVzc2FnZSwgLi4ucGFyYW1zKSA9PiB7XG4gIHJldHVybiBjb25zb2xlLmVycm9yKGBbSW9uaWMgRXJyb3JdOiAke21lc3NhZ2V9YCwgLi4ucGFyYW1zKTtcbn07XG4vKipcbiAqIFByaW50cyBhbiBlcnJvciBpbmZvcm1pbmcgZGV2ZWxvcGVycyB0aGF0IGFuIGltcGxlbWVudGF0aW9uIHJlcXVpcmVzIGFuIGVsZW1lbnQgdG8gYmUgdXNlZFxuICogd2l0aGluIGEgc3BlY2lmaWMgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIGVsIFRoZSB3ZWIgY29tcG9uZW50IGVsZW1lbnQgdGhpcyBpcyByZXF1aXJpbmcgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0gdGFyZ2V0U2VsZWN0b3JzIFRoZSBzZWxlY3RvciBvciBzZWxlY3RvcnMgdGhhdCB3ZXJlIG5vdCBmb3VuZC5cbiAqL1xuY29uc3QgcHJpbnRSZXF1aXJlZEVsZW1lbnRFcnJvciA9IChlbCwgLi4udGFyZ2V0U2VsZWN0b3JzKSA9PiB7XG4gIHJldHVybiBjb25zb2xlLmVycm9yKGA8JHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PiBtdXN0IGJlIHVzZWQgaW5zaWRlICR7dGFyZ2V0U2VsZWN0b3JzLmpvaW4oJyBvciAnKX0uYCk7XG59O1xuXG5leHBvcnQgeyBwcmludFJlcXVpcmVkRWxlbWVudEVycm9yIGFzIGEsIHByaW50SW9uRXJyb3IgYXMgYiwgcHJpbnRJb25XYXJuaW5nIGFzIHAgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGUgYXMgY3JlYXRlRXZlbnQsIGMgYXMgd3JpdGVUYXNrLCBoLCBIIGFzIEhvc3QsIGkgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtOGU2OTI0NDUuanMnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlLCBjIGFzIGNvbmZpZyB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLWM5NWNmMjM5LmpzJztcbmltcG9ydCB7IGYgYXMgZmluZENsb3Nlc3RJb25Db250ZW50LCBpIGFzIGlzSW9uQ29udGVudCwgZCBhcyBkaXNhYmxlQ29udGVudFNjcm9sbFksIHIgYXMgcmVzZXRDb250ZW50U2Nyb2xsWSwgYSBhcyBmaW5kSW9uQ29udGVudCwgcCBhcyBwcmludElvbkNvbnRlbnRFcnJvck1zZyB9IGZyb20gJy4vaW5kZXgtNWQwYzgyMzIuanMnO1xuaW1wb3J0IHsgQyBhcyBDb3JlRGVsZWdhdGUsIGEgYXMgYXR0YWNoQ29tcG9uZW50LCBkIGFzIGRldGFjaENvbXBvbmVudCB9IGZyb20gJy4vZnJhbWV3b3JrLWRlbGVnYXRlLTg5N2Y4NDlkLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0RWxlbWVudFJvb3QsIGwgYXMgY2xhbXAsIHIgYXMgcmFmLCBqIGFzIGluaGVyaXRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9oZWxwZXJzLTNiMzkwZTQ4LmpzJztcbmltcG9ydCB7IEtFWUJPQVJEX0RJRF9PUEVOIH0gZnJvbSAnLi9rZXlib2FyZC00ZDU1NDRhMC5qcyc7XG5pbXBvcnQgeyBwIGFzIHByaW50SW9uV2FybmluZyB9IGZyb20gJy4vaW5kZXgtYzRiMTE2NzYuanMnO1xuaW1wb3J0IHsgQiBhcyBCQUNLRFJPUCwgZSBhcyBwcmVwYXJlT3ZlcmxheSwgZCBhcyBwcmVzZW50LCBoIGFzIGFjdGl2ZUFuaW1hdGlvbnMsIGYgYXMgZGlzbWlzcywgZyBhcyBldmVudE1ldGhvZCB9IGZyb20gJy4vb3ZlcmxheXMtODdjN2M3Y2IuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRDbGFzc01hcCB9IGZyb20gJy4vdGhlbWUtNzY3MDM0MWMuanMnO1xuaW1wb3J0IHsgZSBhcyBkZWVwUmVhZHkgfSBmcm9tICcuL2luZGV4LWU2Y2VjY2U5LmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlQW5pbWF0aW9uIH0gZnJvbSAnLi9hbmltYXRpb24tMmM1MGQyNGQuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbiB9IGZyb20gJy4vY3ViaWMtYmV6aWVyLWMzMTM5NDdhLmpzJztcbmltcG9ydCB7IGNyZWF0ZUdlc3R1cmUgfSBmcm9tICcuL2luZGV4LWY4ZDhhYTVhLmpzJztcbmltcG9ydCB7IHcgYXMgd2luIH0gZnJvbSAnLi9pbmRleC0zM2ZmZWMyNS5qcyc7XG5pbXBvcnQgJy4vaGFyZHdhcmUtYmFjay1idXR0b24tNDkwZGYxMTUuanMnO1xuaW1wb3J0ICcuL2dlc3R1cmUtY29udHJvbGxlci0xNzA2MGI3Yy5qcyc7XG5cbnZhciBTdHlsZTtcbihmdW5jdGlvbiAoU3R5bGUpIHtcbiAgU3R5bGVbXCJEYXJrXCJdID0gXCJEQVJLXCI7XG4gIFN0eWxlW1wiTGlnaHRcIl0gPSBcIkxJR0hUXCI7XG4gIFN0eWxlW1wiRGVmYXVsdFwiXSA9IFwiREVGQVVMVFwiO1xufSkoU3R5bGUgfHwgKFN0eWxlID0ge30pKTtcbmNvbnN0IFN0YXR1c0JhciA9IHtcbiAgZ2V0RW5naW5lKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5DYXBhY2l0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1BsdWdpbkF2YWlsYWJsZSgnU3RhdHVzQmFyJykpICYmICh3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4uQ2FwYWNpdG9yLlBsdWdpbnMuU3RhdHVzQmFyKTtcbiAgfSxcbiAgc3VwcG9ydHNEZWZhdWx0U3RhdHVzQmFyU3R5bGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIC8qKlxuICAgICAqIFRoZSAnREVGQVVMVCcgc3RhdHVzIGJhciBzdHlsZSB3YXMgYWRkZWRcbiAgICAgKiB0byB0aGUgQGNhcGFjaXRvci9zdGF0dXMtYmFyIHBsdWdpbiBpbiBDYXBhY2l0b3IgMy5cbiAgICAgKiBQbHVnaW5IZWFkZXJzIGlzIG9ubHkgc3VwcG9ydGVkIGluIENhcGFjaXRvciAzKyxcbiAgICAgKiBzbyB3ZSBjYW4gdXNlIHRoaXMgdG8gZGV0ZWN0IENhcGFjaXRvciAzLlxuICAgICAqL1xuICAgIHJldHVybiAhISgoX2EgPSB3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4uQ2FwYWNpdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuUGx1Z2luSGVhZGVycyk7XG4gIH0sXG4gIHNldFN0eWxlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbmdpbmUgPSB0aGlzLmdldEVuZ2luZSgpO1xuICAgIGlmICghZW5naW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZ2luZS5zZXRTdHlsZShvcHRpb25zKTtcbiAgfSxcbn07XG5cbi8qKlxuICogVXNlIHkgPSBteCArIGIgdG9cbiAqIGZpZ3VyZSBvdXQgdGhlIGJhY2tkcm9wIHZhbHVlXG4gKiBhdCBhIHBhcnRpY3VsYXIgeCBjb29yZGluYXRlLiBUaGlzXG4gKiBpcyB1c2VmdWwgd2hlbiB0aGUgYmFja2Ryb3AgZG9lc1xuICogbm90IGJlZ2luIHRvIGZhZGUgaW4gdW50aWwgYWZ0ZXJcbiAqIHRoZSAwIGJyZWFrcG9pbnQuXG4gKi9cbmNvbnN0IGdldEJhY2tkcm9wVmFsdWVGb3JTaGVldCA9ICh4LCBiYWNrZHJvcEJyZWFrcG9pbnQpID0+IHtcbiAgLyoqXG4gICAqIFdlIHdpbGwgdXNlIHRoZXNlIHBvaW50czpcbiAgICogKGJhY2tkcm9wQnJlYWtwb2ludCwgMClcbiAgICogKG1heEJyZWFrcG9pbnQsIDEpXG4gICAqIFdlIGtub3cgdGhhdCBhdCB0aGUgYmVnaW5uaW5nIGJyZWFrcG9pbnQsXG4gICAqIHRoZSBiYWNrZHJvcCB3aWxsIGJlIGhpZGRlbi4gV2UgYWxzb1xuICAgKiBrbm93IHRoYXQgYXQgdGhlIG1heEJyZWFrcG9pbnQsIHRoZSBiYWNrZHJvcFxuICAgKiBtdXN0IGJlIGZ1bGx5IHZpc2libGUuIG1heEJyZWFrcG9pbnQgc2hvdWxkXG4gICAqIGFsd2F5cyBiZSAxIGV2ZW4gaWYgdGhlIG1heGltdW0gdmFsdWVcbiAgICogb2YgdGhlIGJyZWFrcG9pbnRzIGFycmF5IGlzIG5vdCAxIHNpbmNlXG4gICAqIHRoZSBhbmltYXRpb24gcnVucyBmcm9tIGEgcHJvZ3Jlc3Mgb2YgMFxuICAgKiB0byBhIHByb2dyZXNzIG9mIDEuXG4gICAqIG0gPSAoeTIgLSB5MSkgLyAoeDIgLSB4MSlcbiAgICpcbiAgICogVGhpcyBpcyBzaW1wbGlmaWVkIGZyb206XG4gICAqIG0gPSAoMSAtIDApIC8gKG1heEJyZWFrcG9pbnQgLSBiYWNrZHJvcEJyZWFrcG9pbnQpXG4gICAqXG4gICAqIElmIHRoZSBiYWNrZHJvcEJyZWFrcG9pbnQgaXMgMSwgd2UgcmV0dXJuIDAgYXMgdGhlXG4gICAqIGJhY2tkcm9wIGlzIGNvbXBsZXRlbHkgaGlkZGVuLlxuICAgKlxuICAgKi9cbiAgaWYgKGJhY2tkcm9wQnJlYWtwb2ludCA9PT0gMSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IHNsb3BlID0gMSAvICgxIC0gYmFja2Ryb3BCcmVha3BvaW50KTtcbiAgLyoqXG4gICAqIEZyb20gaGVyZSwgY29tcHV0ZSBiIHdoaWNoIGlzXG4gICAqIHRoZSBiYWNrZHJvcCBvcGFjaXR5IGlmIHRoZSBvZmZzZXRcbiAgICogaXMgMC4gSWYgdGhlIGJhY2tkcm9wIGRvZXMgbm90XG4gICAqIGJlZ2luIHRvIGZhZGUgaW4gdW50aWwgYWZ0ZXIgdGhlXG4gICAqIDAgYnJlYWtwb2ludCwgdGhpcyBiIHZhbHVlIHdpbGwgYmVcbiAgICogbmVnYXRpdmUuIFRoaXMgaXMgZmluZSBhcyB3ZSBuZXZlciBwYXNzXG4gICAqIGIgZGlyZWN0bHkgaW50byB0aGUgYW5pbWF0aW9uIGtleWZyYW1lcy5cbiAgICogYiA9IHkgLSBteFxuICAgKiBVc2UgYSBrbm93biBwb2ludDogKGJhY2tkcm9wQnJlYWtwb2ludCwgMClcbiAgICogVGhpcyBpcyBzaW1wbGlmaWVkIGZyb206XG4gICAqIGIgPSAwIC0gKGJhY2tkcm9wQnJlYWtwb2ludCAqIHNsb3BlKVxuICAgKi9cbiAgY29uc3QgYiA9IC0oYmFja2Ryb3BCcmVha3BvaW50ICogc2xvcGUpO1xuICAvKipcbiAgICogRmluYWxseSwgd2UgY2FuIG5vdyBkZXRlcm1pbmUgdGhlXG4gICAqIGJhY2tkcm9wIG9mZnNldCBnaXZlbiBhbiBhcmJpdHJhcnlcbiAgICogZ2VzdHVyZSBvZmZzZXQuXG4gICAqL1xuICByZXR1cm4geCAqIHNsb3BlICsgYjtcbn07XG4vKipcbiAqIFRoZSB0YWJsZXQvZGVza3RvcCBjYXJkIG1vZGFsIGFjdGl2YXRlc1xuICogd2hlbiB0aGUgd2luZG93IHdpZHRoIGlzID49IDc2OC5cbiAqIEF0IHRoYXQgcG9pbnQsIHRoZSBwcmVzZW50aW5nIGVsZW1lbnRcbiAqIGlzIG5vdCB0cmFuc2Zvcm1lZCwgc28gd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFkanVzdCB0aGUgc3RhdHVzIGJhciBjb2xvci5cbiAqXG4gKiBOb3RlOiBXZSBjaGVjayBzdXBwb3J0c0RlZmF1bHRTdGF0dXNCYXJTdHlsZSBzbyB0aGF0XG4gKiBDYXBhY2l0b3IgPD0gMiB1c2VycyBkbyBub3QgZ2V0IHRoZWlyIHN0YXR1cyBiYXJcbiAqIHN0dWNrIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZSBkdWUgdG8gYSBsYWNrIG9mXG4gKiBzdXBwb3J0IGZvciBTdHlsZS5EZWZhdWx0LlxuICovXG5jb25zdCBzZXRDYXJkU3RhdHVzQmFyRGFyayA9ICgpID0+IHtcbiAgaWYgKCF3aW4gfHwgd2luLmlubmVyV2lkdGggPj0gNzY4IHx8ICFTdGF0dXNCYXIuc3VwcG9ydHNEZWZhdWx0U3RhdHVzQmFyU3R5bGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBTdGF0dXNCYXIuc2V0U3R5bGUoeyBzdHlsZTogU3R5bGUuRGFyayB9KTtcbn07XG5jb25zdCBzZXRDYXJkU3RhdHVzQmFyRGVmYXVsdCA9ICgpID0+IHtcbiAgaWYgKCF3aW4gfHwgd2luLmlubmVyV2lkdGggPj0gNzY4IHx8ICFTdGF0dXNCYXIuc3VwcG9ydHNEZWZhdWx0U3RhdHVzQmFyU3R5bGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBTdGF0dXNCYXIuc2V0U3R5bGUoeyBzdHlsZTogU3R5bGUuRGVmYXVsdCB9KTtcbn07XG5cbmNvbnN0IGhhbmRsZUNhbkRpc21pc3MgPSBhc3luYyAoZWwsIGFuaW1hdGlvbikgPT4ge1xuICAvKipcbiAgICogSWYgY2FuRGlzbWlzcyBpcyBub3QgYSBmdW5jdGlvblxuICAgKiB0aGVuIHdlIGNhbiByZXR1cm4gZWFybHkuIElmIGNhbkRpc21pc3MgaXMgYHRydWVgLFxuICAgKiB0aGVuIGNhbkRpc21pc3NCbG9ja3NHZXN0dXJlIGlzIGBmYWxzZWAgYXMgY2FuRGlzbWlzc1xuICAgKiB3aWxsIG5ldmVyIGludGVycnVwdCB0aGUgZ2VzdHVyZS4gQXMgYSByZXN1bHQsXG4gICAqIHRoaXMgY29kZSBibG9jayBpcyBuZXZlciByZWFjaGVkLiBJZiBjYW5EaXNtaXNzIGlzIGBmYWxzZWAsXG4gICAqIHRoZW4gd2UgbmV2ZXIgZGlzbWlzcy5cbiAgICovXG4gIGlmICh0eXBlb2YgZWwuY2FuRGlzbWlzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcbiAgICogUnVuIHRoZSBjYW5EaXNtaXNzIGNhbGxiYWNrLlxuICAgKiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAsXG4gICAqIHRoZW4gd2UgY2FuIHByb2NlZWQgd2l0aCBkaXNtaXNzLlxuICAgKi9cbiAgY29uc3Qgc2hvdWxkRGlzbWlzcyA9IGF3YWl0IGVsLmNhbkRpc21pc3MoKTtcbiAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBJZiBjYW5EaXNtaXNzIHJlc29sdmVkIGFmdGVyIHRoZSBzbmFwXG4gICAqIGJhY2sgYW5pbWF0aW9uIGZpbmlzaGVkLCB3ZSBjYW5cbiAgICogZGlzbWlzcyBpbW1lZGlhdGVseS5cbiAgICpcbiAgICogSWYgY2FuRGlzbWlzcyByZXNvbHZlZCBiZWZvcmUgdGhlIHNuYXBcbiAgICogYmFjayBhbmltYXRpb24gZmluaXNoZWQsIHdlIG5lZWQgdG9cbiAgICogd2FpdCB1bnRpbCB0aGUgc25hcCBiYWNrIGFuaW1hdGlvbiBpc1xuICAgKiBkb25lIGJlZm9yZSBkaXNtaXNzaW5nLlxuICAgKi9cbiAgaWYgKGFuaW1hdGlvbi5pc1J1bm5pbmcoKSkge1xuICAgIGFuaW1hdGlvbi5vbkZpbmlzaCgoKSA9PiB7XG4gICAgICBlbC5kaXNtaXNzKHVuZGVmaW5lZCwgJ2hhbmRsZXInKTtcbiAgICB9LCB7IG9uZVRpbWVDYWxsYmFjazogdHJ1ZSB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICBlbC5kaXNtaXNzKHVuZGVmaW5lZCwgJ2hhbmRsZXInKTtcbiAgfVxufTtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsZXRzIHVzIHNpbXVsYXRlIGEgcmVhbGlzdGljIHNwcmluZy1saWtlIGFuaW1hdGlvblxuICogd2hlbiBzd2lwaW5nIGRvd24gb24gdGhlIG1vZGFsLlxuICogVGhlcmUgYXJlIHR3byBmb3JjZXMgdGhhdCB3ZSBuZWVkIHRvIHVzZSB0byBjb21wdXRlIHRoZSBzcHJpbmcgcGh5c2ljczpcbiAqXG4gKiAxLiBTdGlmZm5lc3MsIGs6IFRoaXMgaXMgYSBtZWFzdXJlIG9mIHJlc2lzdGFuY2UgYXBwbGllZCBhIHNwcmluZy5cbiAqIDIuIERhbXBlbmluZywgYzogVGhpcyB2YWx1ZSBoYXMgdGhlIGVmZmVjdCBvZiByZWR1Y2luZyBvciBwcmV2ZW50aW5nIG9zY2lsbGF0aW9uLlxuICpcbiAqIFVzaW5nIHRoZXNlIHR3byB2YWx1ZXMsIHdlIGNhbiBjYWxjdWxhdGUgdGhlIFNwcmluZyBGb3JjZSBhbmQgdGhlIERhbXBlbmluZyBGb3JjZVxuICogdG8gY29tcHV0ZSB0aGUgdG90YWwgZm9yY2UgYXBwbGllZCB0byBhIHNwcmluZy5cbiAqXG4gKiBTcHJpbmcgRm9yY2U6IFRoaXMgZm9yY2UgcHVsbHMgYSBzcHJpbmcgYmFjayBpbnRvIGl0cyBlcXVpbGlicml1bSBwb3NpdGlvbi5cbiAqIEhvb2tlJ3MgTGF3IHRlbGxzIHVzIHRoYXQgdGhhdCBzcHJpbmcgZm9yY2UgKEZTKSA9IGtYLlxuICogayBpcyB0aGUgc3RpZmZuZXNzIG9mIGEgc3ByaW5nLCBhbmQgWCBpcyB0aGUgZGlzcGxhY2VtZW50IG9mIHRoZSBzcHJpbmcgZnJvbSBpdHNcbiAqIGVxdWlsaWJyaXVtIHBvc2l0aW9uLiBJbiB0aGlzIGNhc2UsIGl0IGlzIHRoZSBhbW91bnQgYnkgd2hpY2ggdGhlIGZyZWUgZW5kXG4gKiBvZiBhIHNwcmluZyB3YXMgZGlzcGxhY2VkIChzdHJldGNoZWQvcHVzaGVkKSBmcm9tIGl0cyBcInJlbGF4ZWRcIiBwb3NpdGlvbi5cbiAqXG4gKiBEYW1wZW5pbmcgRm9yY2U6IFRoaXMgZm9yY2Ugc2xvd3MgZG93biBtb3Rpb24uIFdpdGhvdXQgaXQsIGEgc3ByaW5nIHdvdWxkIG9zY2lsbGF0ZSBmb3JldmVyLlxuICogVGhlIGRhbXBlbmluZyBmb3JjZSwgRkQsIGNhbiBiZSBmb3VuZCB2aWEgdGhpcyBmb3JtdWxhOiBGRCA9IC1jdlxuICogd2hlcmUgYyB0aGUgZGFtcGVuaW5nIHZhbHVlIGFuZCB2IGlzIHZlbG9jaXR5LlxuICpcbiAqIFRoZXJlZm9yZSwgdGhlIHJlc3VsdGluZyBmb3JjZSB0aGF0IGlzIGV4ZXJ0ZWQgb24gdGhlIGJsb2NrIGlzOlxuICogRiA9IEZTICsgRkQgPSAta1ggLSBjdlxuICpcbiAqIE5ld3RvbidzIDJuZCBMYXcgdGVsbHMgdXMgdGhhdCBGID0gbWE6XG4gKiBtYSA9IC1rWCAtIGN2LlxuICpcbiAqIEZvciBJb25pYydzIHB1cnBvc2VzLCB3ZSBjYW4gYXNzdW1lIHRoYXQgbSA9IDE6XG4gKiBhID0gLWtYIC0gY3ZcbiAqXG4gKiBJbWFnaW5lIGEgYmxvY2sgYXR0YWNoZWQgdG8gdGhlIGVuZCBvZiBhIHNwcmluZy4gQXQgZXF1aWxpYnJpdW1cbiAqIHRoZSBibG9jayBpcyBhdCBwb3NpdGlvbiB4ID0gMS5cbiAqIFByZXNzaW5nIG9uIHRoZSBibG9jayBtb3ZlcyBpdCB0byBwb3NpdGlvbiB4ID0gMDtcbiAqIFNvLCB0byBjYWxjdWxhdGUgdGhlIGRpc3BsYWNlbWVudCwgd2UgbmVlZCB0byB0YWtlIHRoZVxuICogY3VycmVudCBwb3NpdGlvbiBhbmQgc3VidHJhY3QgdGhlIHByZXZpb3VzIHBvc2l0aW9uIGZyb20gaXQuXG4gKiBYID0geCAtIHgwID0gMCAtIDEgPSAtMS5cbiAqXG4gKiBGb3IgSW9uaWMncyBwdXJwb3Nlcywgd2UgYXJlIG9ubHkgcHVzaGluZyBvbiB0aGUgc3ByaW5nIG1vZGFsXG4gKiBzbyB3ZSBoYXZlIGEgbWF4IHBvc2l0aW9uIG9mIDEuXG4gKiBBcyBhIHJlc3VsdCwgd2UgY2FuIGV4cGFuZCBkaXNwbGFjZW1lbnQgdG8gdGhpcyBmb3JtdWxhOlxuICogWCA9IHggLSAxXG4gKlxuICogYSA9IC1rKHggLSAxKSAtIGN2XG4gKlxuICogV2UgY2FuIHJlcHJlc2VudCB0aGUgbW90aW9uIG9mIHNvbWV0aGluZyBhcyBhIGZ1bmN0aW9uIG9mIHRpbWU6IGYodCkgPSB4LlxuICogVGhlIGRlcml2YXRpdmUgb2YgcG9zaXRpb24gZ2l2ZXMgdXMgdGhlIHZlbG9jaXR5OiBmJyh0KVxuICogVGhlIGRlcml2YXRpdmUgb2YgdGhlIHZlbG9jaXR5IGdpdmVzIHVzIHRoZSBhY2NlbGVyYXRpb246IGYnJyh0KVxuICpcbiAqIFdlIGNhbiBzdWJzdGl0dXRlIHRoZSBmb3JtdWxhIGFib3ZlIHdpdGggdGhlc2UgdmFsdWVzOlxuICpcbiAqIGZcIih0KSA9IC1rICogKGYodCkgLSAxKSAtIGMgKiBmJyh0KVxuICpcbiAqIFRoaXMgaXMgY2FsbGVkIGEgZGlmZmVyZW50aWFsIGVxdWF0aW9uLlxuICpcbiAqIFdlIGtub3cgdGhhdCBhdCB0ID0gMCwgd2UgYXJlIGF0IHggPSAwIGJlY2F1c2UgdGhlIG1vZGFsIGRvZXMgbm90IG1vdmU6IGYoMCkgPSAwXG4gKiBUaGlzIG1lYW5zIG91ciB2ZWxvY2l0eSBpcyBhbHNvIHplcm86IGYnKDApID0gMC5cbiAqXG4gKiBXZSBjYW4gY2hlYXQgYSBiaXQgYW5kIHBsdWcgdGhlIGZvcm11bGEgaW50byBXb2xmcmFtIEFscGhhLlxuICogSG93ZXZlciwgd2UgbmVlZCB0byBwaWNrIHN0aWZmbmVzcyBhbmQgZGFtcGVuaW5nIHZhbHVlczpcbiAqIGsgPSAwLjU3XG4gKiBjID0gMTVcbiAqXG4gKiBJIHBpY2tlZCB0aGVzZSBhcyB0aGV5IGFyZSBmYWlybHkgY2xvc2UgdG8gbmF0aXZlIGlPUydzIHNwcmluZyBlZmZlY3RcbiAqIHdpdGggdGhlIG1vZGFsLlxuICpcbiAqIFdoYXQgd2UgcGx1ZyBpbiBpcyB0aGlzOiBmKDApID0gMDsgZicoMCkgPSAwOyBmJycodCkgPSAtMC41NyhmKHQpIC0gMSkgLSAxNWYnKHQpXG4gKlxuICogVGhlIHJlc3VsdCBpcyBhIGZvcm11bGEgdGhhdCBsZXRzIHVzIGNhbGN1bGF0ZSB0aGUgYWNjZWxlcmF0aW9uXG4gKiBmb3IgYSBnaXZlbiB0aW1lIHQuXG4gKiBOb3RlOiBUaGlzIGlzIHRoZSBhcHByb3hpbWF0ZSBmb3JtIG9mIHRoZSBzb2x1dGlvbi4gV29sZnJhbSBBbHBoYSB3aWxsXG4gKiBnaXZlIHlvdSBhIGNvbXBsZXggZGlmZmVyZW50aWFsIGVxdWF0aW9uIHRvby5cbiAqL1xuY29uc3QgY2FsY3VsYXRlU3ByaW5nU3RlcCA9ICh0KSA9PiB7XG4gIHJldHVybiAwLjAwMjU1Mjc1ICogMi43MTgyOCAqKiAoLTE0Ljk2MTkgKiB0KSAtIDEuMDAyNTUgKiAyLjcxODI4ICoqICgtMC4wMzgwOTY4ICogdCkgKyAxO1xufTtcblxuLy8gRGVmYXVsdHMgZm9yIHRoZSBjYXJkIHN3aXBlIGFuaW1hdGlvblxuY29uc3QgU3dpcGVUb0Nsb3NlRGVmYXVsdHMgPSB7XG4gIE1JTl9QUkVTRU5USU5HX1NDQUxFOiAwLjkzLFxufTtcbmNvbnN0IGNyZWF0ZVN3aXBlVG9DbG9zZUdlc3R1cmUgPSAoZWwsIGFuaW1hdGlvbiwgb25EaXNtaXNzKSA9PiB7XG4gIC8qKlxuICAgKiBUaGUgc3RlcCB2YWx1ZSBhdCB3aGljaCBhIGNhcmQgbW9kYWxcbiAgICogaXMgZWxpZ2libGUgZm9yIGRpc21pc3NpbmcgdmlhIGdlc3R1cmUuXG4gICAqL1xuICBjb25zdCBESVNNSVNTX1RIUkVTSE9MRCA9IDAuNTtcbiAgY29uc3QgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICBsZXQgaXNPcGVuID0gZmFsc2U7XG4gIGxldCBjYW5EaXNtaXNzQmxvY2tzR2VzdHVyZSA9IGZhbHNlO1xuICBsZXQgY29udGVudEVsID0gbnVsbDtcbiAgbGV0IHNjcm9sbEVsID0gbnVsbDtcbiAgY29uc3QgY2FuRGlzbWlzc01heFN0ZXAgPSAwLjI7XG4gIGxldCBpbml0aWFsU2Nyb2xsWSA9IHRydWU7XG4gIGxldCBsYXN0U3RlcCA9IDA7XG4gIGNvbnN0IGdldFNjcm9sbFkgPSAoKSA9PiB7XG4gICAgaWYgKGNvbnRlbnRFbCAmJiBpc0lvbkNvbnRlbnQoY29udGVudEVsKSkge1xuICAgICAgcmV0dXJuIGNvbnRlbnRFbC5zY3JvbGxZO1xuICAgICAgLyoqXG4gICAgICAgKiBDdXN0b20gc2Nyb2xsIGNvbnRhaW5lcnMgYXJlIGludGVuZGVkIHRvIGJlXG4gICAgICAgKiB1c2VkIHdpdGggdmlydHVhbCBzY3JvbGxpbmcsIHNvIHdlIGFzc3VtZVxuICAgICAgICogdGhlcmUgaXMgc2Nyb2xsaW5nIGluIHRoaXMgY2FzZS5cbiAgICAgICAqL1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2FuU3RhcnQgPSAoZGV0YWlsKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZGV0YWlsLmV2ZW50LnRhcmdldDtcbiAgICBpZiAodGFyZ2V0ID09PSBudWxsIHx8ICF0YXJnZXQuY2xvc2VzdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHdlIGFyZSBzd2lwaW5nIG9uIHRoZSBjb250ZW50LFxuICAgICAqIHN3aXBpbmcgc2hvdWxkIG9ubHkgYmUgcG9zc2libGUgaWZcbiAgICAgKiB0aGUgY29udGVudCBpcyBzY3JvbGxlZCBhbGwgdGhlIHdheVxuICAgICAqIHRvIHRoZSB0b3Agc28gdGhhdCB3ZSBkbyBub3QgaW50ZXJmZXJlXG4gICAgICogd2l0aCBzY3JvbGxpbmcuXG4gICAgICpcbiAgICAgKiBXZSBjYW5ub3QgYXNzdW1lIHRoYXQgdGhlIGBpb24tY29udGVudGBcbiAgICAgKiB0YXJnZXQgd2lsbCByZW1haW4gY29uc2lzdGVudCBiZXR3ZWVuXG4gICAgICogc3dpcGVzLiBGb3IgZXhhbXBsZSwgd2hlbiB1c2luZ1xuICAgICAqIGlvbi1uYXYgd2l0aGluIGEgY2FyZCBtb2RhbCBpdCBpc1xuICAgICAqIHBvc3NpYmxlIHRvIHN3aXBlLCBwdXNoIGEgdmlldywgYW5kIHRoZW5cbiAgICAgKiBzd2lwZSBhZ2Fpbi4gVGhlIHRhcmdldCBjb250ZW50IHdpbGwgbm90XG4gICAgICogYmUgdGhlIHNhbWUgYmV0d2VlbiBzd2lwZXMuXG4gICAgICovXG4gICAgY29udGVudEVsID0gZmluZENsb3Nlc3RJb25Db250ZW50KHRhcmdldCk7XG4gICAgaWYgKGNvbnRlbnRFbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2FyZCBzaG91bGQgbmV2ZXIgc3dpcGUgdG8gY2xvc2VcbiAgICAgICAqIG9uIHRoZSBjb250ZW50IHdpdGggYSByZWZyZXNoZXIuXG4gICAgICAgKiBOb3RlOiBXZSBjYW5ub3Qgc29sdmUgdGhpcyBieSBtYWtpbmcgdGhlXG4gICAgICAgKiBzd2lwZVRvQ2xvc2UgZ2VzdHVyZSBoYXZlIGEgaGlnaGVyIHByaW9yaXR5XG4gICAgICAgKiB0aGFuIHRoZSByZWZyZXNoZXIgZ2VzdHVyZSBhcyB0aGUgaU9TIG5hdGl2ZVxuICAgICAgICogcmVmcmVzaCBnZXN0dXJlIHVzZXMgYSBzY3JvbGwgbGlzdGVuZXIgaW5cbiAgICAgICAqIGFkZGl0aW9uIHRvIGEgZ2VzdHVyZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBEbyBub3QgdXNlIGdldFNjcm9sbEVsZW1lbnQgaGVyZVxuICAgICAgICogYmVjYXVzZSB3ZSBuZWVkIHRoaXMgdG8gYmUgYSBzeW5jaHJvbm91c1xuICAgICAgICogb3BlcmF0aW9uLCBhbmQgZ2V0U2Nyb2xsRWxlbWVudCBpc1xuICAgICAgICogYXN5bmNocm9ub3VzLlxuICAgICAgICovXG4gICAgICBpZiAoaXNJb25Db250ZW50KGNvbnRlbnRFbCkpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGdldEVsZW1lbnRSb290KGNvbnRlbnRFbCk7XG4gICAgICAgIHNjcm9sbEVsID0gcm9vdC5xdWVyeVNlbGVjdG9yKCcuaW5uZXItc2Nyb2xsJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2Nyb2xsRWwgPSBjb250ZW50RWw7XG4gICAgICB9XG4gICAgICBjb25zdCBoYXNSZWZyZXNoZXJJbkNvbnRlbnQgPSAhIWNvbnRlbnRFbC5xdWVyeVNlbGVjdG9yKCdpb24tcmVmcmVzaGVyJyk7XG4gICAgICByZXR1cm4gIWhhc1JlZnJlc2hlckluQ29udGVudCAmJiBzY3JvbGxFbC5zY3JvbGxUb3AgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcmQgc2hvdWxkIGJlIHN3aXBlYWJsZSBvbiBhbGxcbiAgICAgKiBwYXJ0cyBvZiB0aGUgbW9kYWwgZXhjZXB0IGZvciB0aGUgZm9vdGVyLlxuICAgICAqL1xuICAgIGNvbnN0IGZvb3RlciA9IHRhcmdldC5jbG9zZXN0KCdpb24tZm9vdGVyJyk7XG4gICAgaWYgKGZvb3RlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgY29uc3Qgb25TdGFydCA9IChkZXRhaWwpID0+IHtcbiAgICBjb25zdCB7IGRlbHRhWSB9ID0gZGV0YWlsO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5pdGlhbCBzY3JvbGxZIHZhbHVlIHNvXG4gICAgICogdGhhdCB3ZSBjYW4gY29ycmVjdGx5IHJlc2V0IHRoZSBzY3JvbGxZXG4gICAgICogcHJvcCB3aGVuIHRoZSBnZXN0dXJlIGVuZHMuXG4gICAgICovXG4gICAgaW5pdGlhbFNjcm9sbFkgPSBnZXRTY3JvbGxZKCk7XG4gICAgLyoqXG4gICAgICogSWYgY2FuRGlzbWlzcyBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGB0cnVlYFxuICAgICAqIHRoZW4gdXNlcnMgc2hvdWxkIGJlIGFibGUgdG8gc3dpcGUgZG93blxuICAgICAqIHVudGlsIGEgdGhyZXNob2xkIGlzIGhpdC4gQXQgdGhhdCBwb2ludCxcbiAgICAgKiB0aGUgY2FyZCBtb2RhbCBzaG91bGQgbm90IHByb2NlZWQgYW55IGZ1cnRoZXIuXG4gICAgICogVE9ETyAoRlctOTM3KVxuICAgICAqIFJlbW92ZSB1bmRlZmluZWQgY2hlY2tcbiAgICAgKi9cbiAgICBjYW5EaXNtaXNzQmxvY2tzR2VzdHVyZSA9IGVsLmNhbkRpc21pc3MgIT09IHVuZGVmaW5lZCAmJiBlbC5jYW5EaXNtaXNzICE9PSB0cnVlO1xuICAgIC8qKlxuICAgICAqIElmIHdlIGFyZSBwdWxsaW5nIGRvd24sIHRoZW5cbiAgICAgKiBpdCBpcyBwb3NzaWJsZSB3ZSBhcmUgcHVsbGluZyBvbiB0aGVcbiAgICAgKiBjb250ZW50LiBXZSBkbyBub3Qgd2FudCBzY3JvbGxpbmcgdG9cbiAgICAgKiBoYXBwZW4gYXQgdGhlIHNhbWUgdGltZSBhcyB0aGUgZ2VzdHVyZS5cbiAgICAgKi9cbiAgICBpZiAoZGVsdGFZID4gMCAmJiBjb250ZW50RWwpIHtcbiAgICAgIGRpc2FibGVDb250ZW50U2Nyb2xsWShjb250ZW50RWwpO1xuICAgIH1cbiAgICBhbmltYXRpb24ucHJvZ3Jlc3NTdGFydCh0cnVlLCBpc09wZW4gPyAxIDogMCk7XG4gIH07XG4gIGNvbnN0IG9uTW92ZSA9IChkZXRhaWwpID0+IHtcbiAgICBjb25zdCB7IGRlbHRhWSB9ID0gZGV0YWlsO1xuICAgIC8qKlxuICAgICAqIElmIHdlIGFyZSBwdWxsaW5nIGRvd24sIHRoZW5cbiAgICAgKiBpdCBpcyBwb3NzaWJsZSB3ZSBhcmUgcHVsbGluZyBvbiB0aGVcbiAgICAgKiBjb250ZW50LiBXZSBkbyBub3Qgd2FudCBzY3JvbGxpbmcgdG9cbiAgICAgKiBoYXBwZW4gYXQgdGhlIHNhbWUgdGltZSBhcyB0aGUgZ2VzdHVyZS5cbiAgICAgKi9cbiAgICBpZiAoZGVsdGFZID4gMCAmJiBjb250ZW50RWwpIHtcbiAgICAgIGRpc2FibGVDb250ZW50U2Nyb2xsWShjb250ZW50RWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBhcmUgc3dpcGluZyBvbiB0aGUgY29udGVudFxuICAgICAqIHRoZW4gdGhlIHN3aXBlIGdlc3R1cmUgc2hvdWxkIG9ubHlcbiAgICAgKiBoYXBwZW4gaWYgd2UgYXJlIHB1bGxpbmcgZG93bi5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIGlmIHdlIHB1bGwgdXAgYW5kXG4gICAgICogdGhlbiBkb3duIHN1Y2ggdGhhdCB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICogcmV0dXJucyB0byAwLCB3ZSBzaG91bGQgYmUgYWJsZSB0byBzd2lwZVxuICAgICAqIHRoZSBjYXJkLlxuICAgICAqL1xuICAgIGNvbnN0IHN0ZXAgPSBkZXRhaWwuZGVsdGFZIC8gaGVpZ2h0O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHVzZXIgaXMgc3dpcGluZyBkb3duIGFuZFxuICAgICAqIGlmIHdlIGhhdmUgYSBjYW5EaXNtaXNzIHZhbHVlIHRoYXRcbiAgICAgKiBzaG91bGQgYmxvY2sgdGhlIGdlc3R1cmUgZnJvbVxuICAgICAqIHByb2NlZWRpbmcsXG4gICAgICovXG4gICAgY29uc3QgaXNBdHRlbXBpbmdEaXNtaXNzV2l0aENhbkRpc21pc3MgPSBzdGVwID49IDAgJiYgY2FuRGlzbWlzc0Jsb2Nrc0dlc3R1cmU7XG4gICAgLyoqXG4gICAgICogSWYgd2UgYXJlIGJsb2NraW5nIHRoZSBnZXN0dXJlIGZyb20gZGlzbWlzc2luZyxcbiAgICAgKiBzZXQgdGhlIG1heCBzdGVwIHZhbHVlIHNvIHRoYXQgdGhlIHNoZWV0IGNhbm5vdCBiZVxuICAgICAqIGNvbXBsZXRlbHkgaGlkZGVuLlxuICAgICAqL1xuICAgIGNvbnN0IG1heFN0ZXAgPSBpc0F0dGVtcGluZ0Rpc21pc3NXaXRoQ2FuRGlzbWlzcyA/IGNhbkRpc21pc3NNYXhTdGVwIDogMC45OTk5O1xuICAgIC8qKlxuICAgICAqIElmIHdlIGFyZSBibG9ja2luZyB0aGUgZ2VzdHVyZSBmcm9tXG4gICAgICogZGlzbWlzc2luZywgY2FsY3VsYXRlIHRoZSBzcHJpbmcgbW9kaWZpZXIgdmFsdWVcbiAgICAgKiB0aGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHN0YXJ0aW5nIGJyZWFrcG9pbnRcbiAgICAgKiB2YWx1ZSB0byBnaXZlIHRoZSBnZXN0dXJlIGEgc3ByaW5nLWxpa2UgZmVlbGluZy5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIHN0YXJ0aW5nIGJyZWFrcG9pbnQgaXMgYWx3YXlzIDAsXG4gICAgICogc28gd2Ugb21pdCBhZGRpbmcgMCB0byB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIGNvbnN0IHByb2Nlc3NlZFN0ZXAgPSBpc0F0dGVtcGluZ0Rpc21pc3NXaXRoQ2FuRGlzbWlzcyA/IGNhbGN1bGF0ZVNwcmluZ1N0ZXAoc3RlcCAvIG1heFN0ZXApIDogc3RlcDtcbiAgICBjb25zdCBjbGFtcGVkU3RlcCA9IGNsYW1wKDAuMDAwMSwgcHJvY2Vzc2VkU3RlcCwgbWF4U3RlcCk7XG4gICAgYW5pbWF0aW9uLnByb2dyZXNzU3RlcChjbGFtcGVkU3RlcCk7XG4gICAgLyoqXG4gICAgICogV2hlbiBzd2lwaW5nIGRvd24gaGFsZiB3YXksIHRoZSBzdGF0dXMgYmFyIHN0eWxlXG4gICAgICogc2hvdWxkIGJlIHJlc2V0IHRvIGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAqXG4gICAgICogV2UgdHJhY2sgbGFzdFN0ZXAgc28gdGhhdCB3ZSBkbyBub3QgZmlyZSB0aGVzZVxuICAgICAqIGZ1bmN0aW9ucyBvbiBldmVyeSBvbk1vdmUsIG9ubHkgd2hlbiB0aGUgdXNlciBoYXNcbiAgICAgKiBjcm9zc2VkIGEgY2VydGFpbiB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgaWYgKGNsYW1wZWRTdGVwID49IERJU01JU1NfVEhSRVNIT0xEICYmIGxhc3RTdGVwIDwgRElTTUlTU19USFJFU0hPTEQpIHtcbiAgICAgIHNldENhcmRTdGF0dXNCYXJEZWZhdWx0KCk7XG4gICAgICAvKipcbiAgICAgICAqIEhvd2V2ZXIsIGlmIHdlIHN3aXBlIGJhY2sgdXAsIHRoZW4gdGhlXG4gICAgICAgKiBzdGF0dXMgYmFyIHN0eWxlIHNob3VsZCBiZSBzZXQgdG8gaGF2ZSBsaWdodFxuICAgICAgICogdGV4dCBvbiBhIGRhcmsgYmFja2dyb3VuZC5cbiAgICAgICAqL1xuICAgIH1cbiAgICBlbHNlIGlmIChjbGFtcGVkU3RlcCA8IERJU01JU1NfVEhSRVNIT0xEICYmIGxhc3RTdGVwID49IERJU01JU1NfVEhSRVNIT0xEKSB7XG4gICAgICBzZXRDYXJkU3RhdHVzQmFyRGFyaygpO1xuICAgIH1cbiAgICBsYXN0U3RlcCA9IGNsYW1wZWRTdGVwO1xuICB9O1xuICBjb25zdCBvbkVuZCA9IChkZXRhaWwpID0+IHtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IGRldGFpbC52ZWxvY2l0eVk7XG4gICAgY29uc3Qgc3RlcCA9IGRldGFpbC5kZWx0YVkgLyBoZWlnaHQ7XG4gICAgY29uc3QgaXNBdHRlbXBpbmdEaXNtaXNzV2l0aENhbkRpc21pc3MgPSBzdGVwID49IDAgJiYgY2FuRGlzbWlzc0Jsb2Nrc0dlc3R1cmU7XG4gICAgY29uc3QgbWF4U3RlcCA9IGlzQXR0ZW1waW5nRGlzbWlzc1dpdGhDYW5EaXNtaXNzID8gY2FuRGlzbWlzc01heFN0ZXAgOiAwLjk5OTk7XG4gICAgY29uc3QgcHJvY2Vzc2VkU3RlcCA9IGlzQXR0ZW1waW5nRGlzbWlzc1dpdGhDYW5EaXNtaXNzID8gY2FsY3VsYXRlU3ByaW5nU3RlcChzdGVwIC8gbWF4U3RlcCkgOiBzdGVwO1xuICAgIGNvbnN0IGNsYW1wZWRTdGVwID0gY2xhbXAoMC4wMDAxLCBwcm9jZXNzZWRTdGVwLCBtYXhTdGVwKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAoZGV0YWlsLmRlbHRhWSArIHZlbG9jaXR5ICogMTAwMCkgLyBoZWlnaHQ7XG4gICAgLyoqXG4gICAgICogSWYgY2FuRGlzbWlzcyBibG9ja3NcbiAgICAgKiB0aGUgc3dpcGUgZ2VzdHVyZSwgdGhlbiB0aGVcbiAgICAgKiBhbmltYXRpb24gY2FuIG5ldmVyIGNvbXBsZXRlIHVudGlsXG4gICAgICogY2FuRGlzbWlzcyBpcyBjaGVja2VkLlxuICAgICAqL1xuICAgIGNvbnN0IHNob3VsZENvbXBsZXRlID0gIWlzQXR0ZW1waW5nRGlzbWlzc1dpdGhDYW5EaXNtaXNzICYmIHRocmVzaG9sZCA+PSBESVNNSVNTX1RIUkVTSE9MRDtcbiAgICBsZXQgbmV3U3RlcFZhbHVlID0gc2hvdWxkQ29tcGxldGUgPyAtMC4wMDEgOiAwLjAwMTtcbiAgICBpZiAoIXNob3VsZENvbXBsZXRlKSB7XG4gICAgICBhbmltYXRpb24uZWFzaW5nKCdjdWJpYy1iZXppZXIoMSwgMCwgMC42OCwgMC4yOCknKTtcbiAgICAgIG5ld1N0ZXBWYWx1ZSArPSBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbihbMCwgMF0sIFsxLCAwXSwgWzAuNjgsIDAuMjhdLCBbMSwgMV0sIGNsYW1wZWRTdGVwKVswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhbmltYXRpb24uZWFzaW5nKCdjdWJpYy1iZXppZXIoMC4zMiwgMC43MiwgMCwgMSknKTtcbiAgICAgIG5ld1N0ZXBWYWx1ZSArPSBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbihbMCwgMF0sIFswLjMyLCAwLjcyXSwgWzAsIDFdLCBbMSwgMV0sIGNsYW1wZWRTdGVwKVswXTtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSBzaG91bGRDb21wbGV0ZVxuICAgICAgPyBjb21wdXRlRHVyYXRpb24oc3RlcCAqIGhlaWdodCwgdmVsb2NpdHkpXG4gICAgICA6IGNvbXB1dGVEdXJhdGlvbigoMSAtIGNsYW1wZWRTdGVwKSAqIGhlaWdodCwgdmVsb2NpdHkpO1xuICAgIGlzT3BlbiA9IHNob3VsZENvbXBsZXRlO1xuICAgIGdlc3R1cmUuZW5hYmxlKGZhbHNlKTtcbiAgICBpZiAoY29udGVudEVsKSB7XG4gICAgICByZXNldENvbnRlbnRTY3JvbGxZKGNvbnRlbnRFbCwgaW5pdGlhbFNjcm9sbFkpO1xuICAgIH1cbiAgICBhbmltYXRpb25cbiAgICAgIC5vbkZpbmlzaCgoKSA9PiB7XG4gICAgICBpZiAoIXNob3VsZENvbXBsZXRlKSB7XG4gICAgICAgIGdlc3R1cmUuZW5hYmxlKHRydWUpO1xuICAgICAgfVxuICAgIH0pXG4gICAgICAucHJvZ3Jlc3NFbmQoc2hvdWxkQ29tcGxldGUgPyAxIDogMCwgbmV3U3RlcFZhbHVlLCBkdXJhdGlvbik7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGNhbkRpc21pc3MgdmFsdWUgYmxvY2tlZCB0aGUgZ2VzdHVyZVxuICAgICAqIGZyb20gcHJvY2VlZGluZywgdGhlbiB3ZSBzaG91bGQgaWdub3JlIHdoYXRldmVyXG4gICAgICogc2hvdWxkQ29tcGxldGUgaXMuIFdoZXRoZXIgb3Igbm90IHRoZSBtb2RhbFxuICAgICAqIGFuaW1hdGlvbiBzaG91bGQgY29tcGxldGUgaXMgbm93IGRldGVybWluZWQgYnlcbiAgICAgKiBjYW5EaXNtaXNzLlxuICAgICAqXG4gICAgICogSWYgdGhlIHVzZXIgc3dpcGVkID4yNSUgb2YgdGhlIHdheVxuICAgICAqIHRvIHRoZSBtYXggc3RlcCwgdGhlbiB3ZSBzaG91bGRcbiAgICAgKiBjaGVjayBjYW5EaXNtaXNzLiAyNSUgd2FzIGNob3NlblxuICAgICAqIHRvIGF2b2lkIGFjY2lkZW50YWwgc3dpcGVzLlxuICAgICAqL1xuICAgIGlmIChpc0F0dGVtcGluZ0Rpc21pc3NXaXRoQ2FuRGlzbWlzcyAmJiBjbGFtcGVkU3RlcCA+IG1heFN0ZXAgLyA0KSB7XG4gICAgICBoYW5kbGVDYW5EaXNtaXNzKGVsLCBhbmltYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaG91bGRDb21wbGV0ZSkge1xuICAgICAgb25EaXNtaXNzKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXN0dXJlID0gY3JlYXRlR2VzdHVyZSh7XG4gICAgZWwsXG4gICAgZ2VzdHVyZU5hbWU6ICdtb2RhbFN3aXBlVG9DbG9zZScsXG4gICAgZ2VzdHVyZVByaW9yaXR5OiAzOSxcbiAgICBkaXJlY3Rpb246ICd5JyxcbiAgICB0aHJlc2hvbGQ6IDEwLFxuICAgIGNhblN0YXJ0LFxuICAgIG9uU3RhcnQsXG4gICAgb25Nb3ZlLFxuICAgIG9uRW5kLFxuICB9KTtcbiAgcmV0dXJuIGdlc3R1cmU7XG59O1xuY29uc3QgY29tcHV0ZUR1cmF0aW9uID0gKHJlbWFpbmluZywgdmVsb2NpdHkpID0+IHtcbiAgcmV0dXJuIGNsYW1wKDQwMCwgcmVtYWluaW5nIC8gTWF0aC5hYnModmVsb2NpdHkgKiAxLjEpLCA1MDApO1xufTtcblxuY29uc3QgY3JlYXRlU2hlZXRFbnRlckFuaW1hdGlvbiA9IChvcHRzKSA9PiB7XG4gIGNvbnN0IHsgY3VycmVudEJyZWFrcG9pbnQsIGJhY2tkcm9wQnJlYWtwb2ludCB9ID0gb3B0cztcbiAgLyoqXG4gICAqIElmIHRoZSBiYWNrZHJvcEJyZWFrcG9pbnQgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBiYWNrZHJvcFxuICAgKiBzaG91bGQgYWx3YXlzIGZhZGUgaW4uIElmIHRoZSBiYWNrZHJvcEJyZWFrcG9pbnQgY2FtZSBiZWZvcmUgdGhlXG4gICAqIGN1cnJlbnQgYnJlYWtwb2ludCwgdGhlbiB0aGUgYmFja2Ryb3Agc2hvdWxkIGJlIGZhZGluZyBpbi5cbiAgICovXG4gIGNvbnN0IHNob3VsZFNob3dCYWNrZHJvcCA9IGJhY2tkcm9wQnJlYWtwb2ludCA9PT0gdW5kZWZpbmVkIHx8IGJhY2tkcm9wQnJlYWtwb2ludCA8IGN1cnJlbnRCcmVha3BvaW50O1xuICBjb25zdCBpbml0aWFsQmFja2Ryb3AgPSBzaG91bGRTaG93QmFja2Ryb3AgPyBgY2FsYyh2YXIoLS1iYWNrZHJvcC1vcGFjaXR5KSAqICR7Y3VycmVudEJyZWFrcG9pbnR9KWAgOiAnMCc7XG4gIGNvbnN0IGJhY2tkcm9wQW5pbWF0aW9uID0gY3JlYXRlQW5pbWF0aW9uKCdiYWNrZHJvcEFuaW1hdGlvbicpLmZyb21Ubygnb3BhY2l0eScsIDAsIGluaXRpYWxCYWNrZHJvcCk7XG4gIGlmIChzaG91bGRTaG93QmFja2Ryb3ApIHtcbiAgICBiYWNrZHJvcEFuaW1hdGlvblxuICAgICAgLmJlZm9yZVN0eWxlcyh7XG4gICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZScsXG4gICAgfSlcbiAgICAgIC5hZnRlckNsZWFyU3R5bGVzKFsncG9pbnRlci1ldmVudHMnXSk7XG4gIH1cbiAgY29uc3Qgd3JhcHBlckFuaW1hdGlvbiA9IGNyZWF0ZUFuaW1hdGlvbignd3JhcHBlckFuaW1hdGlvbicpLmtleWZyYW1lcyhbXG4gICAgeyBvZmZzZXQ6IDAsIG9wYWNpdHk6IDEsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMTAwJSknIH0sXG4gICAgeyBvZmZzZXQ6IDEsIG9wYWNpdHk6IDEsIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVkoJHsxMDAgLSBjdXJyZW50QnJlYWtwb2ludCAqIDEwMH0lKWAgfSxcbiAgXSk7XG4gIHJldHVybiB7IHdyYXBwZXJBbmltYXRpb24sIGJhY2tkcm9wQW5pbWF0aW9uIH07XG59O1xuY29uc3QgY3JlYXRlU2hlZXRMZWF2ZUFuaW1hdGlvbiA9IChvcHRzKSA9PiB7XG4gIGNvbnN0IHsgY3VycmVudEJyZWFrcG9pbnQsIGJhY2tkcm9wQnJlYWtwb2ludCB9ID0gb3B0cztcbiAgLyoqXG4gICAqIEJhY2tkcm9wIGRvZXMgbm90IGFsd2F5cyBmYWRlIGluIGZyb20gMCB0byAxIGlmIGJhY2tkcm9wQnJlYWtwb2ludFxuICAgKiBpcyBkZWZpbmVkLCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoYXQgb2Zmc2V0IGJ5IGZpZ3VyaW5nIG91dFxuICAgKiB3aGF0IHRoZSBjdXJyZW50IGJhY2tkcm9wIHZhbHVlIHNob3VsZCBiZS5cbiAgICovXG4gIGNvbnN0IGJhY2tkcm9wVmFsdWUgPSBgY2FsYyh2YXIoLS1iYWNrZHJvcC1vcGFjaXR5KSAqICR7Z2V0QmFja2Ryb3BWYWx1ZUZvclNoZWV0KGN1cnJlbnRCcmVha3BvaW50LCBiYWNrZHJvcEJyZWFrcG9pbnQpfSlgO1xuICBjb25zdCBkZWZhdWx0QmFja2Ryb3AgPSBbXG4gICAgeyBvZmZzZXQ6IDAsIG9wYWNpdHk6IGJhY2tkcm9wVmFsdWUgfSxcbiAgICB7IG9mZnNldDogMSwgb3BhY2l0eTogMCB9LFxuICBdO1xuICBjb25zdCBjdXN0b21CYWNrZHJvcCA9IFtcbiAgICB7IG9mZnNldDogMCwgb3BhY2l0eTogYmFja2Ryb3BWYWx1ZSB9LFxuICAgIHsgb2Zmc2V0OiBiYWNrZHJvcEJyZWFrcG9pbnQsIG9wYWNpdHk6IDAgfSxcbiAgICB7IG9mZnNldDogMSwgb3BhY2l0eTogMCB9LFxuICBdO1xuICBjb25zdCBiYWNrZHJvcEFuaW1hdGlvbiA9IGNyZWF0ZUFuaW1hdGlvbignYmFja2Ryb3BBbmltYXRpb24nKS5rZXlmcmFtZXMoYmFja2Ryb3BCcmVha3BvaW50ICE9PSAwID8gY3VzdG9tQmFja2Ryb3AgOiBkZWZhdWx0QmFja2Ryb3ApO1xuICBjb25zdCB3cmFwcGVyQW5pbWF0aW9uID0gY3JlYXRlQW5pbWF0aW9uKCd3cmFwcGVyQW5pbWF0aW9uJykua2V5ZnJhbWVzKFtcbiAgICB7IG9mZnNldDogMCwgb3BhY2l0eTogMSwgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWSgkezEwMCAtIGN1cnJlbnRCcmVha3BvaW50ICogMTAwfSUpYCB9LFxuICAgIHsgb2Zmc2V0OiAxLCBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKDEwMCUpYCB9LFxuICBdKTtcbiAgcmV0dXJuIHsgd3JhcHBlckFuaW1hdGlvbiwgYmFja2Ryb3BBbmltYXRpb24gfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUVudGVyQW5pbWF0aW9uJDEgPSAoKSA9PiB7XG4gIGNvbnN0IGJhY2tkcm9wQW5pbWF0aW9uID0gY3JlYXRlQW5pbWF0aW9uKClcbiAgICAuZnJvbVRvKCdvcGFjaXR5JywgMC4wMSwgJ3ZhcigtLWJhY2tkcm9wLW9wYWNpdHkpJylcbiAgICAuYmVmb3JlU3R5bGVzKHtcbiAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZScsXG4gIH0pXG4gICAgLmFmdGVyQ2xlYXJTdHlsZXMoWydwb2ludGVyLWV2ZW50cyddKTtcbiAgY29uc3Qgd3JhcHBlckFuaW1hdGlvbiA9IGNyZWF0ZUFuaW1hdGlvbigpLmZyb21UbygndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVkoMTAwdmgpJywgJ3RyYW5zbGF0ZVkoMHZoKScpO1xuICByZXR1cm4geyBiYWNrZHJvcEFuaW1hdGlvbiwgd3JhcHBlckFuaW1hdGlvbiB9O1xufTtcbi8qKlxuICogaU9TIE1vZGFsIEVudGVyIEFuaW1hdGlvbiBmb3IgdGhlIENhcmQgcHJlc2VudGF0aW9uIHN0eWxlXG4gKi9cbmNvbnN0IGlvc0VudGVyQW5pbWF0aW9uID0gKGJhc2VFbCwgb3B0cykgPT4ge1xuICBjb25zdCB7IHByZXNlbnRpbmdFbCwgY3VycmVudEJyZWFrcG9pbnQgfSA9IG9wdHM7XG4gIGNvbnN0IHJvb3QgPSBnZXRFbGVtZW50Um9vdChiYXNlRWwpO1xuICBjb25zdCB7IHdyYXBwZXJBbmltYXRpb24sIGJhY2tkcm9wQW5pbWF0aW9uIH0gPSBjdXJyZW50QnJlYWtwb2ludCAhPT0gdW5kZWZpbmVkID8gY3JlYXRlU2hlZXRFbnRlckFuaW1hdGlvbihvcHRzKSA6IGNyZWF0ZUVudGVyQW5pbWF0aW9uJDEoKTtcbiAgYmFja2Ryb3BBbmltYXRpb24uYWRkRWxlbWVudChyb290LnF1ZXJ5U2VsZWN0b3IoJ2lvbi1iYWNrZHJvcCcpKTtcbiAgd3JhcHBlckFuaW1hdGlvbi5hZGRFbGVtZW50KHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLm1vZGFsLXdyYXBwZXIsIC5tb2RhbC1zaGFkb3cnKSkuYmVmb3JlU3R5bGVzKHsgb3BhY2l0eTogMSB9KTtcbiAgY29uc3QgYmFzZUFuaW1hdGlvbiA9IGNyZWF0ZUFuaW1hdGlvbignZW50ZXJpbmctYmFzZScpXG4gICAgLmFkZEVsZW1lbnQoYmFzZUVsKVxuICAgIC5lYXNpbmcoJ2N1YmljLWJlemllcigwLjMyLDAuNzIsMCwxKScpXG4gICAgLmR1cmF0aW9uKDUwMClcbiAgICAuYWRkQW5pbWF0aW9uKHdyYXBwZXJBbmltYXRpb24pO1xuICBpZiAocHJlc2VudGluZ0VsKSB7XG4gICAgY29uc3QgaXNNb2JpbGUgPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2ODtcbiAgICBjb25zdCBoYXNDYXJkTW9kYWwgPSBwcmVzZW50aW5nRWwudGFnTmFtZSA9PT0gJ0lPTi1NT0RBTCcgJiYgcHJlc2VudGluZ0VsLnByZXNlbnRpbmdFbGVtZW50ICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJlc2VudGluZ0VsUm9vdCA9IGdldEVsZW1lbnRSb290KHByZXNlbnRpbmdFbCk7XG4gICAgY29uc3QgcHJlc2VudGluZ0FuaW1hdGlvbiA9IGNyZWF0ZUFuaW1hdGlvbigpLmJlZm9yZVN0eWxlcyh7XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDApJyxcbiAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogJ3RvcCBjZW50ZXInLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIH0pO1xuICAgIGNvbnN0IGJvZHlFbCA9IGRvY3VtZW50LmJvZHk7XG4gICAgaWYgKGlzTW9iaWxlKSB7XG4gICAgICAvKipcbiAgICAgICAqIEZhbGxiYWNrIGZvciBicm93c2VycyB0aGF0IGRvZXMgbm90IHN1cHBvcnQgYG1heCgpYCAoZXg6IEZpcmVmb3gpXG4gICAgICAgKiBObyBuZWVkIHRvIHdvcnJ5IGFib3V0IHN0YXR1c2JhciBwYWRkaW5nIHNpbmNlIGVuZ2luZXMgbGlrZSBHZWNrb1xuICAgICAgICogYXJlIG5vdCB1c2VkIGFzIHRoZSBlbmdpbmUgZm9yIHN0YW5kYWxvbmUgQ29yZG92YS9DYXBhY2l0b3IgYXBwc1xuICAgICAgICovXG4gICAgICBjb25zdCB0cmFuc2Zvcm1PZmZzZXQgPSAhQ1NTLnN1cHBvcnRzKCd3aWR0aCcsICdtYXgoMHB4LCAxcHgpJykgPyAnMzBweCcgOiAnbWF4KDMwcHgsIHZhcigtLWlvbi1zYWZlLWFyZWEtdG9wKSknO1xuICAgICAgY29uc3QgbW9kYWxUcmFuc2Zvcm0gPSBoYXNDYXJkTW9kYWwgPyAnLTEwcHgnIDogdHJhbnNmb3JtT2Zmc2V0O1xuICAgICAgY29uc3QgdG9QcmVzZW50aW5nU2NhbGUgPSBTd2lwZVRvQ2xvc2VEZWZhdWx0cy5NSU5fUFJFU0VOVElOR19TQ0FMRTtcbiAgICAgIGNvbnN0IGZpbmFsVHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHttb2RhbFRyYW5zZm9ybX0pIHNjYWxlKCR7dG9QcmVzZW50aW5nU2NhbGV9KWA7XG4gICAgICBwcmVzZW50aW5nQW5pbWF0aW9uXG4gICAgICAgIC5hZnRlclN0eWxlcyh7XG4gICAgICAgIHRyYW5zZm9ybTogZmluYWxUcmFuc2Zvcm0sXG4gICAgICB9KVxuICAgICAgICAuYmVmb3JlQWRkV3JpdGUoKCkgPT4gYm9keUVsLnN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgJ2JsYWNrJykpXG4gICAgICAgIC5hZGRFbGVtZW50KHByZXNlbnRpbmdFbClcbiAgICAgICAgLmtleWZyYW1lcyhbXG4gICAgICAgIHsgb2Zmc2V0OiAwLCBmaWx0ZXI6ICdjb250cmFzdCgxKScsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMHB4KSBzY2FsZSgxKScsIGJvcmRlclJhZGl1czogJzBweCcgfSxcbiAgICAgICAgeyBvZmZzZXQ6IDEsIGZpbHRlcjogJ2NvbnRyYXN0KDAuODUpJywgdHJhbnNmb3JtOiBmaW5hbFRyYW5zZm9ybSwgYm9yZGVyUmFkaXVzOiAnMTBweCAxMHB4IDAgMCcgfSxcbiAgICAgIF0pO1xuICAgICAgYmFzZUFuaW1hdGlvbi5hZGRBbmltYXRpb24ocHJlc2VudGluZ0FuaW1hdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYmFzZUFuaW1hdGlvbi5hZGRBbmltYXRpb24oYmFja2Ryb3BBbmltYXRpb24pO1xuICAgICAgaWYgKCFoYXNDYXJkTW9kYWwpIHtcbiAgICAgICAgd3JhcHBlckFuaW1hdGlvbi5mcm9tVG8oJ29wYWNpdHknLCAnMCcsICcxJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdG9QcmVzZW50aW5nU2NhbGUgPSBoYXNDYXJkTW9kYWwgPyBTd2lwZVRvQ2xvc2VEZWZhdWx0cy5NSU5fUFJFU0VOVElOR19TQ0FMRSA6IDE7XG4gICAgICAgIGNvbnN0IGZpbmFsVHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoLTEwcHgpIHNjYWxlKCR7dG9QcmVzZW50aW5nU2NhbGV9KWA7XG4gICAgICAgIHByZXNlbnRpbmdBbmltYXRpb25cbiAgICAgICAgICAuYWZ0ZXJTdHlsZXMoe1xuICAgICAgICAgIHRyYW5zZm9ybTogZmluYWxUcmFuc2Zvcm0sXG4gICAgICAgIH0pXG4gICAgICAgICAgLmFkZEVsZW1lbnQocHJlc2VudGluZ0VsUm9vdC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtd3JhcHBlcicpKVxuICAgICAgICAgIC5rZXlmcmFtZXMoW1xuICAgICAgICAgIHsgb2Zmc2V0OiAwLCBmaWx0ZXI6ICdjb250cmFzdCgxKScsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMCkgc2NhbGUoMSknIH0sXG4gICAgICAgICAgeyBvZmZzZXQ6IDEsIGZpbHRlcjogJ2NvbnRyYXN0KDAuODUpJywgdHJhbnNmb3JtOiBmaW5hbFRyYW5zZm9ybSB9LFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3Qgc2hhZG93QW5pbWF0aW9uID0gY3JlYXRlQW5pbWF0aW9uKClcbiAgICAgICAgICAuYWZ0ZXJTdHlsZXMoe1xuICAgICAgICAgIHRyYW5zZm9ybTogZmluYWxUcmFuc2Zvcm0sXG4gICAgICAgIH0pXG4gICAgICAgICAgLmFkZEVsZW1lbnQocHJlc2VudGluZ0VsUm9vdC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtc2hhZG93JykpXG4gICAgICAgICAgLmtleWZyYW1lcyhbXG4gICAgICAgICAgeyBvZmZzZXQ6IDAsIG9wYWNpdHk6ICcxJywgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwKSBzY2FsZSgxKScgfSxcbiAgICAgICAgICB7IG9mZnNldDogMSwgb3BhY2l0eTogJzAnLCB0cmFuc2Zvcm06IGZpbmFsVHJhbnNmb3JtIH0sXG4gICAgICAgIF0pO1xuICAgICAgICBiYXNlQW5pbWF0aW9uLmFkZEFuaW1hdGlvbihbcHJlc2VudGluZ0FuaW1hdGlvbiwgc2hhZG93QW5pbWF0aW9uXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGJhc2VBbmltYXRpb24uYWRkQW5pbWF0aW9uKGJhY2tkcm9wQW5pbWF0aW9uKTtcbiAgfVxuICByZXR1cm4gYmFzZUFuaW1hdGlvbjtcbn07XG5cbmNvbnN0IGNyZWF0ZUxlYXZlQW5pbWF0aW9uJDEgPSAoKSA9PiB7XG4gIGNvbnN0IGJhY2tkcm9wQW5pbWF0aW9uID0gY3JlYXRlQW5pbWF0aW9uKCkuZnJvbVRvKCdvcGFjaXR5JywgJ3ZhcigtLWJhY2tkcm9wLW9wYWNpdHkpJywgMCk7XG4gIGNvbnN0IHdyYXBwZXJBbmltYXRpb24gPSBjcmVhdGVBbmltYXRpb24oKS5mcm9tVG8oJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVZKDB2aCknLCAndHJhbnNsYXRlWSgxMDB2aCknKTtcbiAgcmV0dXJuIHsgYmFja2Ryb3BBbmltYXRpb24sIHdyYXBwZXJBbmltYXRpb24gfTtcbn07XG4vKipcbiAqIGlPUyBNb2RhbCBMZWF2ZSBBbmltYXRpb25cbiAqL1xuY29uc3QgaW9zTGVhdmVBbmltYXRpb24gPSAoYmFzZUVsLCBvcHRzLCBkdXJhdGlvbiA9IDUwMCkgPT4ge1xuICBjb25zdCB7IHByZXNlbnRpbmdFbCwgY3VycmVudEJyZWFrcG9pbnQgfSA9IG9wdHM7XG4gIGNvbnN0IHJvb3QgPSBnZXRFbGVtZW50Um9vdChiYXNlRWwpO1xuICBjb25zdCB7IHdyYXBwZXJBbmltYXRpb24sIGJhY2tkcm9wQW5pbWF0aW9uIH0gPSBjdXJyZW50QnJlYWtwb2ludCAhPT0gdW5kZWZpbmVkID8gY3JlYXRlU2hlZXRMZWF2ZUFuaW1hdGlvbihvcHRzKSA6IGNyZWF0ZUxlYXZlQW5pbWF0aW9uJDEoKTtcbiAgYmFja2Ryb3BBbmltYXRpb24uYWRkRWxlbWVudChyb290LnF1ZXJ5U2VsZWN0b3IoJ2lvbi1iYWNrZHJvcCcpKTtcbiAgd3JhcHBlckFuaW1hdGlvbi5hZGRFbGVtZW50KHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLm1vZGFsLXdyYXBwZXIsIC5tb2RhbC1zaGFkb3cnKSkuYmVmb3JlU3R5bGVzKHsgb3BhY2l0eTogMSB9KTtcbiAgY29uc3QgYmFzZUFuaW1hdGlvbiA9IGNyZWF0ZUFuaW1hdGlvbignbGVhdmluZy1iYXNlJylcbiAgICAuYWRkRWxlbWVudChiYXNlRWwpXG4gICAgLmVhc2luZygnY3ViaWMtYmV6aWVyKDAuMzIsMC43MiwwLDEpJylcbiAgICAuZHVyYXRpb24oZHVyYXRpb24pXG4gICAgLmFkZEFuaW1hdGlvbih3cmFwcGVyQW5pbWF0aW9uKTtcbiAgaWYgKHByZXNlbnRpbmdFbCkge1xuICAgIGNvbnN0IGlzTW9iaWxlID0gd2luZG93LmlubmVyV2lkdGggPCA3Njg7XG4gICAgY29uc3QgaGFzQ2FyZE1vZGFsID0gcHJlc2VudGluZ0VsLnRhZ05hbWUgPT09ICdJT04tTU9EQUwnICYmIHByZXNlbnRpbmdFbC5wcmVzZW50aW5nRWxlbWVudCAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByZXNlbnRpbmdFbFJvb3QgPSBnZXRFbGVtZW50Um9vdChwcmVzZW50aW5nRWwpO1xuICAgIGNvbnN0IHByZXNlbnRpbmdBbmltYXRpb24gPSBjcmVhdGVBbmltYXRpb24oKVxuICAgICAgLmJlZm9yZUNsZWFyU3R5bGVzKFsndHJhbnNmb3JtJ10pXG4gICAgICAuYWZ0ZXJDbGVhclN0eWxlcyhbJ3RyYW5zZm9ybSddKVxuICAgICAgLm9uRmluaXNoKChjdXJyZW50U3RlcCkgPT4ge1xuICAgICAgLy8gb25seSByZXNldCBiYWNrZ3JvdW5kIGNvbG9yIGlmIHRoaXMgaXMgdGhlIGxhc3QgY2FyZC1zdHlsZSBtb2RhbFxuICAgICAgaWYgKGN1cnJlbnRTdGVwICE9PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXNlbnRpbmdFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnb3ZlcmZsb3cnLCAnJyk7XG4gICAgICBjb25zdCBudW1Nb2RhbHMgPSBBcnJheS5mcm9tKGJvZHlFbC5xdWVyeVNlbGVjdG9yQWxsKCdpb24tbW9kYWwnKSkuZmlsdGVyKChtKSA9PiBtLnByZXNlbnRpbmdFbGVtZW50ICE9PSB1bmRlZmluZWQpLmxlbmd0aDtcbiAgICAgIGlmIChudW1Nb2RhbHMgPD0gMSkge1xuICAgICAgICBib2R5RWwuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtY29sb3InLCAnJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYm9keUVsID0gZG9jdW1lbnQuYm9keTtcbiAgICBpZiAoaXNNb2JpbGUpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybU9mZnNldCA9ICFDU1Muc3VwcG9ydHMoJ3dpZHRoJywgJ21heCgwcHgsIDFweCknKSA/ICczMHB4JyA6ICdtYXgoMzBweCwgdmFyKC0taW9uLXNhZmUtYXJlYS10b3ApKSc7XG4gICAgICBjb25zdCBtb2RhbFRyYW5zZm9ybSA9IGhhc0NhcmRNb2RhbCA/ICctMTBweCcgOiB0cmFuc2Zvcm1PZmZzZXQ7XG4gICAgICBjb25zdCB0b1ByZXNlbnRpbmdTY2FsZSA9IFN3aXBlVG9DbG9zZURlZmF1bHRzLk1JTl9QUkVTRU5USU5HX1NDQUxFO1xuICAgICAgY29uc3QgZmluYWxUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke21vZGFsVHJhbnNmb3JtfSkgc2NhbGUoJHt0b1ByZXNlbnRpbmdTY2FsZX0pYDtcbiAgICAgIHByZXNlbnRpbmdBbmltYXRpb24uYWRkRWxlbWVudChwcmVzZW50aW5nRWwpLmtleWZyYW1lcyhbXG4gICAgICAgIHsgb2Zmc2V0OiAwLCBmaWx0ZXI6ICdjb250cmFzdCgwLjg1KScsIHRyYW5zZm9ybTogZmluYWxUcmFuc2Zvcm0sIGJvcmRlclJhZGl1czogJzEwcHggMTBweCAwIDAnIH0sXG4gICAgICAgIHsgb2Zmc2V0OiAxLCBmaWx0ZXI6ICdjb250cmFzdCgxKScsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMHB4KSBzY2FsZSgxKScsIGJvcmRlclJhZGl1czogJzBweCcgfSxcbiAgICAgIF0pO1xuICAgICAgYmFzZUFuaW1hdGlvbi5hZGRBbmltYXRpb24ocHJlc2VudGluZ0FuaW1hdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYmFzZUFuaW1hdGlvbi5hZGRBbmltYXRpb24oYmFja2Ryb3BBbmltYXRpb24pO1xuICAgICAgaWYgKCFoYXNDYXJkTW9kYWwpIHtcbiAgICAgICAgd3JhcHBlckFuaW1hdGlvbi5mcm9tVG8oJ29wYWNpdHknLCAnMScsICcwJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdG9QcmVzZW50aW5nU2NhbGUgPSBoYXNDYXJkTW9kYWwgPyBTd2lwZVRvQ2xvc2VEZWZhdWx0cy5NSU5fUFJFU0VOVElOR19TQ0FMRSA6IDE7XG4gICAgICAgIGNvbnN0IGZpbmFsVHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoLTEwcHgpIHNjYWxlKCR7dG9QcmVzZW50aW5nU2NhbGV9KWA7XG4gICAgICAgIHByZXNlbnRpbmdBbmltYXRpb25cbiAgICAgICAgICAuYWRkRWxlbWVudChwcmVzZW50aW5nRWxSb290LnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC13cmFwcGVyJykpXG4gICAgICAgICAgLmFmdGVyU3R5bGVzKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgIH0pXG4gICAgICAgICAgLmtleWZyYW1lcyhbXG4gICAgICAgICAgeyBvZmZzZXQ6IDAsIGZpbHRlcjogJ2NvbnRyYXN0KDAuODUpJywgdHJhbnNmb3JtOiBmaW5hbFRyYW5zZm9ybSB9LFxuICAgICAgICAgIHsgb2Zmc2V0OiAxLCBmaWx0ZXI6ICdjb250cmFzdCgxKScsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMCkgc2NhbGUoMSknIH0sXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBzaGFkb3dBbmltYXRpb24gPSBjcmVhdGVBbmltYXRpb24oKVxuICAgICAgICAgIC5hZGRFbGVtZW50KHByZXNlbnRpbmdFbFJvb3QucXVlcnlTZWxlY3RvcignLm1vZGFsLXNoYWRvdycpKVxuICAgICAgICAgIC5hZnRlclN0eWxlcyh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwKSBzY2FsZSgxKScsXG4gICAgICAgIH0pXG4gICAgICAgICAgLmtleWZyYW1lcyhbXG4gICAgICAgICAgeyBvZmZzZXQ6IDAsIG9wYWNpdHk6ICcwJywgdHJhbnNmb3JtOiBmaW5hbFRyYW5zZm9ybSB9LFxuICAgICAgICAgIHsgb2Zmc2V0OiAxLCBvcGFjaXR5OiAnMScsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMCkgc2NhbGUoMSknIH0sXG4gICAgICAgIF0pO1xuICAgICAgICBiYXNlQW5pbWF0aW9uLmFkZEFuaW1hdGlvbihbcHJlc2VudGluZ0FuaW1hdGlvbiwgc2hhZG93QW5pbWF0aW9uXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGJhc2VBbmltYXRpb24uYWRkQW5pbWF0aW9uKGJhY2tkcm9wQW5pbWF0aW9uKTtcbiAgfVxuICByZXR1cm4gYmFzZUFuaW1hdGlvbjtcbn07XG5cbmNvbnN0IGNyZWF0ZUVudGVyQW5pbWF0aW9uID0gKCkgPT4ge1xuICBjb25zdCBiYWNrZHJvcEFuaW1hdGlvbiA9IGNyZWF0ZUFuaW1hdGlvbigpXG4gICAgLmZyb21Ubygnb3BhY2l0eScsIDAuMDEsICd2YXIoLS1iYWNrZHJvcC1vcGFjaXR5KScpXG4gICAgLmJlZm9yZVN0eWxlcyh7XG4gICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnLFxuICB9KVxuICAgIC5hZnRlckNsZWFyU3R5bGVzKFsncG9pbnRlci1ldmVudHMnXSk7XG4gIGNvbnN0IHdyYXBwZXJBbmltYXRpb24gPSBjcmVhdGVBbmltYXRpb24oKS5rZXlmcmFtZXMoW1xuICAgIHsgb2Zmc2V0OiAwLCBvcGFjaXR5OiAwLjAxLCB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDQwcHgpJyB9LFxuICAgIHsgb2Zmc2V0OiAxLCBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06IGB0cmFuc2xhdGVZKDBweClgIH0sXG4gIF0pO1xuICByZXR1cm4geyBiYWNrZHJvcEFuaW1hdGlvbiwgd3JhcHBlckFuaW1hdGlvbiB9O1xufTtcbi8qKlxuICogTWQgTW9kYWwgRW50ZXIgQW5pbWF0aW9uXG4gKi9cbmNvbnN0IG1kRW50ZXJBbmltYXRpb24gPSAoYmFzZUVsLCBvcHRzKSA9PiB7XG4gIGNvbnN0IHsgY3VycmVudEJyZWFrcG9pbnQgfSA9IG9wdHM7XG4gIGNvbnN0IHJvb3QgPSBnZXRFbGVtZW50Um9vdChiYXNlRWwpO1xuICBjb25zdCB7IHdyYXBwZXJBbmltYXRpb24sIGJhY2tkcm9wQW5pbWF0aW9uIH0gPSBjdXJyZW50QnJlYWtwb2ludCAhPT0gdW5kZWZpbmVkID8gY3JlYXRlU2hlZXRFbnRlckFuaW1hdGlvbihvcHRzKSA6IGNyZWF0ZUVudGVyQW5pbWF0aW9uKCk7XG4gIGJhY2tkcm9wQW5pbWF0aW9uLmFkZEVsZW1lbnQocm9vdC5xdWVyeVNlbGVjdG9yKCdpb24tYmFja2Ryb3AnKSk7XG4gIHdyYXBwZXJBbmltYXRpb24uYWRkRWxlbWVudChyb290LnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbC13cmFwcGVyJykpO1xuICByZXR1cm4gY3JlYXRlQW5pbWF0aW9uKClcbiAgICAuYWRkRWxlbWVudChiYXNlRWwpXG4gICAgLmVhc2luZygnY3ViaWMtYmV6aWVyKDAuMzYsMC42NiwwLjA0LDEpJylcbiAgICAuZHVyYXRpb24oMjgwKVxuICAgIC5hZGRBbmltYXRpb24oW2JhY2tkcm9wQW5pbWF0aW9uLCB3cmFwcGVyQW5pbWF0aW9uXSk7XG59O1xuXG5jb25zdCBjcmVhdGVMZWF2ZUFuaW1hdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgYmFja2Ryb3BBbmltYXRpb24gPSBjcmVhdGVBbmltYXRpb24oKS5mcm9tVG8oJ29wYWNpdHknLCAndmFyKC0tYmFja2Ryb3Atb3BhY2l0eSknLCAwKTtcbiAgY29uc3Qgd3JhcHBlckFuaW1hdGlvbiA9IGNyZWF0ZUFuaW1hdGlvbigpLmtleWZyYW1lcyhbXG4gICAgeyBvZmZzZXQ6IDAsIG9wYWNpdHk6IDAuOTksIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVkoMHB4KWAgfSxcbiAgICB7IG9mZnNldDogMSwgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSg0MHB4KScgfSxcbiAgXSk7XG4gIHJldHVybiB7IGJhY2tkcm9wQW5pbWF0aW9uLCB3cmFwcGVyQW5pbWF0aW9uIH07XG59O1xuLyoqXG4gKiBNZCBNb2RhbCBMZWF2ZSBBbmltYXRpb25cbiAqL1xuY29uc3QgbWRMZWF2ZUFuaW1hdGlvbiA9IChiYXNlRWwsIG9wdHMpID0+IHtcbiAgY29uc3QgeyBjdXJyZW50QnJlYWtwb2ludCB9ID0gb3B0cztcbiAgY29uc3Qgcm9vdCA9IGdldEVsZW1lbnRSb290KGJhc2VFbCk7XG4gIGNvbnN0IHsgd3JhcHBlckFuaW1hdGlvbiwgYmFja2Ryb3BBbmltYXRpb24gfSA9IGN1cnJlbnRCcmVha3BvaW50ICE9PSB1bmRlZmluZWQgPyBjcmVhdGVTaGVldExlYXZlQW5pbWF0aW9uKG9wdHMpIDogY3JlYXRlTGVhdmVBbmltYXRpb24oKTtcbiAgYmFja2Ryb3BBbmltYXRpb24uYWRkRWxlbWVudChyb290LnF1ZXJ5U2VsZWN0b3IoJ2lvbi1iYWNrZHJvcCcpKTtcbiAgd3JhcHBlckFuaW1hdGlvbi5hZGRFbGVtZW50KHJvb3QucXVlcnlTZWxlY3RvcignLm1vZGFsLXdyYXBwZXInKSk7XG4gIHJldHVybiBjcmVhdGVBbmltYXRpb24oKVxuICAgIC5lYXNpbmcoJ2N1YmljLWJlemllcigwLjQ3LDAsMC43NDUsMC43MTUpJylcbiAgICAuZHVyYXRpb24oMjAwKVxuICAgIC5hZGRBbmltYXRpb24oW2JhY2tkcm9wQW5pbWF0aW9uLCB3cmFwcGVyQW5pbWF0aW9uXSk7XG59O1xuXG5jb25zdCBjcmVhdGVTaGVldEdlc3R1cmUgPSAoYmFzZUVsLCBiYWNrZHJvcEVsLCB3cmFwcGVyRWwsIGluaXRpYWxCcmVha3BvaW50LCBiYWNrZHJvcEJyZWFrcG9pbnQsIGFuaW1hdGlvbiwgYnJlYWtwb2ludHMgPSBbXSwgZ2V0Q3VycmVudEJyZWFrcG9pbnQsIG9uRGlzbWlzcywgb25CcmVha3BvaW50Q2hhbmdlKSA9PiB7XG4gIC8vIERlZmF1bHRzIGZvciB0aGUgc2hlZXQgc3dpcGUgYW5pbWF0aW9uXG4gIGNvbnN0IGRlZmF1bHRCYWNrZHJvcCA9IFtcbiAgICB7IG9mZnNldDogMCwgb3BhY2l0eTogJ3ZhcigtLWJhY2tkcm9wLW9wYWNpdHkpJyB9LFxuICAgIHsgb2Zmc2V0OiAxLCBvcGFjaXR5OiAwLjAxIH0sXG4gIF07XG4gIGNvbnN0IGN1c3RvbUJhY2tkcm9wID0gW1xuICAgIHsgb2Zmc2V0OiAwLCBvcGFjaXR5OiAndmFyKC0tYmFja2Ryb3Atb3BhY2l0eSknIH0sXG4gICAgeyBvZmZzZXQ6IDEgLSBiYWNrZHJvcEJyZWFrcG9pbnQsIG9wYWNpdHk6IDAgfSxcbiAgICB7IG9mZnNldDogMSwgb3BhY2l0eTogMCB9LFxuICBdO1xuICBjb25zdCBTaGVldERlZmF1bHRzID0ge1xuICAgIFdSQVBQRVJfS0VZRlJBTUVTOiBbXG4gICAgICB7IG9mZnNldDogMCwgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwJSknIH0sXG4gICAgICB7IG9mZnNldDogMSwgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgxMDAlKScgfSxcbiAgICBdLFxuICAgIEJBQ0tEUk9QX0tFWUZSQU1FUzogYmFja2Ryb3BCcmVha3BvaW50ICE9PSAwID8gY3VzdG9tQmFja2Ryb3AgOiBkZWZhdWx0QmFja2Ryb3AsXG4gIH07XG4gIGNvbnN0IGNvbnRlbnRFbCA9IGJhc2VFbC5xdWVyeVNlbGVjdG9yKCdpb24tY29udGVudCcpO1xuICBjb25zdCBoZWlnaHQgPSB3cmFwcGVyRWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgY3VycmVudEJyZWFrcG9pbnQgPSBpbml0aWFsQnJlYWtwb2ludDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGxldCBjYW5EaXNtaXNzQmxvY2tzR2VzdHVyZSA9IGZhbHNlO1xuICBjb25zdCBjYW5EaXNtaXNzTWF4U3RlcCA9IDAuOTU7XG4gIGNvbnN0IHdyYXBwZXJBbmltYXRpb24gPSBhbmltYXRpb24uY2hpbGRBbmltYXRpb25zLmZpbmQoKGFuaSkgPT4gYW5pLmlkID09PSAnd3JhcHBlckFuaW1hdGlvbicpO1xuICBjb25zdCBiYWNrZHJvcEFuaW1hdGlvbiA9IGFuaW1hdGlvbi5jaGlsZEFuaW1hdGlvbnMuZmluZCgoYW5pKSA9PiBhbmkuaWQgPT09ICdiYWNrZHJvcEFuaW1hdGlvbicpO1xuICBjb25zdCBtYXhCcmVha3BvaW50ID0gYnJlYWtwb2ludHNbYnJlYWtwb2ludHMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IG1pbkJyZWFrcG9pbnQgPSBicmVha3BvaW50c1swXTtcbiAgY29uc3QgZW5hYmxlQmFja2Ryb3AgPSAoKSA9PiB7XG4gICAgYmFzZUVsLnN0eWxlLnNldFByb3BlcnR5KCdwb2ludGVyLWV2ZW50cycsICdhdXRvJyk7XG4gICAgYmFja2Ryb3BFbC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCAnYXV0bycpO1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIGJhY2tkcm9wIGlzIGVuYWJsZWQsIGVsZW1lbnRzIHN1Y2hcbiAgICAgKiBhcyBpbnB1dHMgc2hvdWxkIG5vdCBiZSBmb2N1c2FibGUgb3V0c2lkZVxuICAgICAqIHRoZSBzaGVldC5cbiAgICAgKi9cbiAgICBiYXNlRWwuY2xhc3NMaXN0LnJlbW92ZSgnaW9uLWRpc2FibGUtZm9jdXMtdHJhcCcpO1xuICB9O1xuICBjb25zdCBkaXNhYmxlQmFja2Ryb3AgPSAoKSA9PiB7XG4gICAgYmFzZUVsLnN0eWxlLnNldFByb3BlcnR5KCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG4gICAgYmFja2Ryb3BFbC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIGJhY2tkcm9wIGlzIGVuYWJsZWQsIGVsZW1lbnRzIHN1Y2hcbiAgICAgKiBhcyBpbnB1dHMgc2hvdWxkIG5vdCBiZSBmb2N1c2FibGUgb3V0c2lkZVxuICAgICAqIHRoZSBzaGVldC5cbiAgICAgKiBBZGRpbmcgdGhpcyBjbGFzcyBkaXNhYmxlcyBmb2N1cyB0cmFwcGluZ1xuICAgICAqIGZvciB0aGUgc2hlZXQgdGVtcG9yYXJpbHkuXG4gICAgICovXG4gICAgYmFzZUVsLmNsYXNzTGlzdC5hZGQoJ2lvbi1kaXNhYmxlLWZvY3VzLXRyYXAnKTtcbiAgfTtcbiAgLyoqXG4gICAqIEFmdGVyIHRoZSBlbnRlcmluZyBhbmltYXRpb24gY29tcGxldGVzLFxuICAgKiB3ZSBuZWVkIHRvIHNldCB0aGUgYW5pbWF0aW9uIHRvIGdvIGZyb21cbiAgICogb2Zmc2V0IDAgdG8gb2Zmc2V0IDEgc28gdGhhdCB1c2VycyBjYW5cbiAgICogc3dpcGUgaW4gYW55IGRpcmVjdGlvbi4gV2UgdGhlbiBzZXQgdGhlXG4gICAqIGFuaW1hdGlvbiBvZmZzZXQgdG8gdGhlIGN1cnJlbnQgYnJlYWtwb2ludFxuICAgKiBzbyB0aGVyZSBpcyBubyBmbGlja2VyaW5nLlxuICAgKi9cbiAgaWYgKHdyYXBwZXJBbmltYXRpb24gJiYgYmFja2Ryb3BBbmltYXRpb24pIHtcbiAgICB3cmFwcGVyQW5pbWF0aW9uLmtleWZyYW1lcyhbLi4uU2hlZXREZWZhdWx0cy5XUkFQUEVSX0tFWUZSQU1FU10pO1xuICAgIGJhY2tkcm9wQW5pbWF0aW9uLmtleWZyYW1lcyhbLi4uU2hlZXREZWZhdWx0cy5CQUNLRFJPUF9LRVlGUkFNRVNdKTtcbiAgICBhbmltYXRpb24ucHJvZ3Jlc3NTdGFydCh0cnVlLCAxIC0gY3VycmVudEJyZWFrcG9pbnQpO1xuICAgIC8qKlxuICAgICAqIElmIGJhY2tkcm9wIGlzIG5vdCBlbmFibGVkLCB0aGVuIGNvbnRlbnRcbiAgICAgKiBiZWhpbmQgbW9kYWwgc2hvdWxkIGJlIGNsaWNrYWJsZS4gVG8gZG8gdGhpcywgd2UgbmVlZFxuICAgICAqIHRvIHJlbW92ZSBwb2ludGVyLWV2ZW50cyBmcm9tIGlvbi1tb2RhbCBhcyBhIHdob2xlLlxuICAgICAqIGlvbi1iYWNrZHJvcCBhbmQgLm1vZGFsLXdyYXBwZXIgYWx3YXlzIGhhdmUgcG9pbnRlci1ldmVudHM6IGF1dG9cbiAgICAgKiBhcHBsaWVkLCBzbyB0aGUgbW9kYWwgY29udGVudCBjYW4gc3RpbGwgYmUgaW50ZXJhY3RlZCB3aXRoLlxuICAgICAqL1xuICAgIGNvbnN0IHNob3VsZEVuYWJsZUJhY2tkcm9wID0gY3VycmVudEJyZWFrcG9pbnQgPiBiYWNrZHJvcEJyZWFrcG9pbnQ7XG4gICAgaWYgKHNob3VsZEVuYWJsZUJhY2tkcm9wKSB7XG4gICAgICBlbmFibGVCYWNrZHJvcCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRpc2FibGVCYWNrZHJvcCgpO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudEVsICYmIGN1cnJlbnRCcmVha3BvaW50ICE9PSBtYXhCcmVha3BvaW50KSB7XG4gICAgY29udGVudEVsLnNjcm9sbFkgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjYW5TdGFydCA9IChkZXRhaWwpID0+IHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc2hlZXQgaXMgZnVsbHkgZXhwYW5kZWQgYW5kXG4gICAgICogdGhlIHVzZXIgaXMgc3dpcGluZyBvbiB0aGUgY29udGVudCxcbiAgICAgKiB0aGUgZ2VzdHVyZSBzaG91bGQgbm90IHN0YXJ0IHRvXG4gICAgICogYWxsb3cgZm9yIHNjcm9sbGluZyBvbiB0aGUgY29udGVudC5cbiAgICAgKi9cbiAgICBjb25zdCBjb250ZW50ID0gZGV0YWlsLmV2ZW50LnRhcmdldC5jbG9zZXN0KCdpb24tY29udGVudCcpO1xuICAgIGN1cnJlbnRCcmVha3BvaW50ID0gZ2V0Q3VycmVudEJyZWFrcG9pbnQoKTtcbiAgICBpZiAoY3VycmVudEJyZWFrcG9pbnQgPT09IDEgJiYgY29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3Qgb25TdGFydCA9ICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBJZiBjYW5EaXNtaXNzIGlzIGFueXRoaW5nIG90aGVyIHRoYW4gYHRydWVgXG4gICAgICogdGhlbiB1c2VycyBzaG91bGQgYmUgYWJsZSB0byBzd2lwZSBkb3duXG4gICAgICogdW50aWwgYSB0aHJlc2hvbGQgaXMgaGl0LiBBdCB0aGF0IHBvaW50LFxuICAgICAqIHRoZSBjYXJkIG1vZGFsIHNob3VsZCBub3QgcHJvY2VlZCBhbnkgZnVydGhlci5cbiAgICAgKlxuICAgICAqIGNhbkRpc21pc3MgaXMgbmV2ZXIgZmlyZWQgdmlhIGdlc3R1cmUgaWYgdGhlcmUgaXNcbiAgICAgKiBubyAwIGJyZWFrcG9pbnQuIEhvd2V2ZXIsIGl0IGNhbiBiZSBmaXJlZCBpZiB0aGUgdXNlclxuICAgICAqIHByZXNzZXMgRXNjIG9yIHRoZSBoYXJkd2FyZSBiYWNrIGJ1dHRvbi5cbiAgICAgKiBUT0RPIChGVy05MzcpXG4gICAgICogUmVtb3ZlIHVuZGVmaW5lZCBjaGVja1xuICAgICAqL1xuICAgIGNhbkRpc21pc3NCbG9ja3NHZXN0dXJlID0gYmFzZUVsLmNhbkRpc21pc3MgIT09IHVuZGVmaW5lZCAmJiBiYXNlRWwuY2FuRGlzbWlzcyAhPT0gdHJ1ZSAmJiBtaW5CcmVha3BvaW50ID09PSAwO1xuICAgIC8qKlxuICAgICAqIElmIHN3aXBpbmcgb24gdGhlIGNvbnRlbnRcbiAgICAgKiB3ZSBzaG91bGQgZGlzYWJsZSBzY3JvbGxpbmcgb3RoZXJ3aXNlXG4gICAgICogdGhlIHNoZWV0IHdpbGwgZXhwYW5kIGFuZCB0aGUgY29udGVudCB3aWxsIHNjcm9sbC5cbiAgICAgKi9cbiAgICBpZiAoY29udGVudEVsKSB7XG4gICAgICBjb250ZW50RWwuc2Nyb2xsWSA9IGZhbHNlO1xuICAgIH1cbiAgICByYWYoKCkgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBEaXNtaXNzZXMgdGhlIG9wZW4ga2V5Ym9hcmQgd2hlbiB0aGUgc2hlZXQgZHJhZyBnZXN0dXJlIGlzIHN0YXJ0ZWQuXG4gICAgICAgKiBTZXRzIHRoZSBmb2N1cyBvbnRvIHRoZSBtb2RhbCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBiYXNlRWwuZm9jdXMoKTtcbiAgICB9KTtcbiAgICBhbmltYXRpb24ucHJvZ3Jlc3NTdGFydCh0cnVlLCAxIC0gY3VycmVudEJyZWFrcG9pbnQpO1xuICB9O1xuICBjb25zdCBvbk1vdmUgPSAoZGV0YWlsKSA9PiB7XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIGNoYW5nZSBpbiBnZXN0dXJlIHBvc2l0aW9uIG9uIHRoZSBZIGF4aXMsXG4gICAgICogY29tcHV0ZSB3aGVyZSB0aGUgb2Zmc2V0IG9mIHRoZSBhbmltYXRpb24gc2hvdWxkIGJlXG4gICAgICogcmVsYXRpdmUgdG8gd2hlcmUgdGhlIHVzZXIgZHJhZ2dlZC5cbiAgICAgKi9cbiAgICBjb25zdCBpbml0aWFsU3RlcCA9IDEgLSBjdXJyZW50QnJlYWtwb2ludDtcbiAgICBjb25zdCBzZWNvbmRUb0xhc3RCcmVha3BvaW50ID0gYnJlYWtwb2ludHMubGVuZ3RoID4gMSA/IDEgLSBicmVha3BvaW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzdGVwID0gaW5pdGlhbFN0ZXAgKyBkZXRhaWwuZGVsdGFZIC8gaGVpZ2h0O1xuICAgIGNvbnN0IGlzQXR0ZW1wdGluZ0Rpc21pc3NXaXRoQ2FuRGlzbWlzcyA9IHNlY29uZFRvTGFzdEJyZWFrcG9pbnQgIT09IHVuZGVmaW5lZCAmJiBzdGVwID49IHNlY29uZFRvTGFzdEJyZWFrcG9pbnQgJiYgY2FuRGlzbWlzc0Jsb2Nrc0dlc3R1cmU7XG4gICAgLyoqXG4gICAgICogSWYgd2UgYXJlIGJsb2NraW5nIHRoZSBnZXN0dXJlIGZyb20gZGlzbWlzc2luZyxcbiAgICAgKiBzZXQgdGhlIG1heCBzdGVwIHZhbHVlIHNvIHRoYXQgdGhlIHNoZWV0IGNhbm5vdCBiZVxuICAgICAqIGNvbXBsZXRlbHkgaGlkZGVuLlxuICAgICAqL1xuICAgIGNvbnN0IG1heFN0ZXAgPSBpc0F0dGVtcHRpbmdEaXNtaXNzV2l0aENhbkRpc21pc3MgPyBjYW5EaXNtaXNzTWF4U3RlcCA6IDAuOTk5OTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBhcmUgYmxvY2tpbmcgdGhlIGdlc3R1cmUgZnJvbVxuICAgICAqIGRpc21pc3NpbmcsIGNhbGN1bGF0ZSB0aGUgc3ByaW5nIG1vZGlmaWVyIHZhbHVlXG4gICAgICogdGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzdGFydGluZyBicmVha3BvaW50XG4gICAgICogdmFsdWUgdG8gZ2l2ZSB0aGUgZ2VzdHVyZSBhIHNwcmluZy1saWtlIGZlZWxpbmcuXG4gICAgICogTm90ZSB0aGF0IHdoZW4gaXNBdHRlbXB0aW5nRGlzbWlzc1dpdGhDYW5EaXNtaXNzIGlzIHRydWUsXG4gICAgICogdGhlIG1vZGlmaWVyIGlzIGFsd2F5cyBhZGRlZCB0byB0aGUgYnJlYWtwb2ludCB0aGF0XG4gICAgICogYXBwZWFycyByaWdodCBhZnRlciB0aGUgMCBicmVha3BvaW50LlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgaXMgZXNzZW50aWFsbHkgdGhlIHByb2dyZXNzaW9uXG4gICAgICogYmV0d2VlbiBzZWNvbmRUb0xhc3RCcmVha3BvaW50IGFuZCBtYXhTdGVwIHdoaWNoIGlzXG4gICAgICogd2h5IHdlIHN1YnRyYWN0IHNlY29uZFRvTGFzdEJyZWFrcG9pbnQuIFRoaXMgbGV0cyB1cyBnZXRcbiAgICAgKiB0aGUgcmVzdWx0IGFzIGEgdmFsdWUgZnJvbSAwIHRvIDEuXG4gICAgICovXG4gICAgY29uc3QgcHJvY2Vzc2VkU3RlcCA9IGlzQXR0ZW1wdGluZ0Rpc21pc3NXaXRoQ2FuRGlzbWlzcyAmJiBzZWNvbmRUb0xhc3RCcmVha3BvaW50ICE9PSB1bmRlZmluZWRcbiAgICAgID8gc2Vjb25kVG9MYXN0QnJlYWtwb2ludCArXG4gICAgICAgIGNhbGN1bGF0ZVNwcmluZ1N0ZXAoKHN0ZXAgLSBzZWNvbmRUb0xhc3RCcmVha3BvaW50KSAvIChtYXhTdGVwIC0gc2Vjb25kVG9MYXN0QnJlYWtwb2ludCkpXG4gICAgICA6IHN0ZXA7XG4gICAgb2Zmc2V0ID0gY2xhbXAoMC4wMDAxLCBwcm9jZXNzZWRTdGVwLCBtYXhTdGVwKTtcbiAgICBhbmltYXRpb24ucHJvZ3Jlc3NTdGVwKG9mZnNldCk7XG4gIH07XG4gIGNvbnN0IG9uRW5kID0gKGRldGFpbCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIGdlc3R1cmUgcmVsZWFzZXMsIHdlIG5lZWQgdG8gZGV0ZXJtaW5lXG4gICAgICogdGhlIGNsb3Nlc3QgYnJlYWtwb2ludCB0byBzbmFwIHRvLlxuICAgICAqL1xuICAgIGNvbnN0IHZlbG9jaXR5ID0gZGV0YWlsLnZlbG9jaXR5WTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAoZGV0YWlsLmRlbHRhWSArIHZlbG9jaXR5ICogMzUwKSAvIGhlaWdodDtcbiAgICBjb25zdCBkaWZmID0gY3VycmVudEJyZWFrcG9pbnQgLSB0aHJlc2hvbGQ7XG4gICAgY29uc3QgY2xvc2VzdCA9IGJyZWFrcG9pbnRzLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKGIgLSBkaWZmKSA8IE1hdGguYWJzKGEgLSBkaWZmKSA/IGIgOiBhO1xuICAgIH0pO1xuICAgIG1vdmVTaGVldFRvQnJlYWtwb2ludCh7XG4gICAgICBicmVha3BvaW50OiBjbG9zZXN0LFxuICAgICAgYnJlYWtwb2ludE9mZnNldDogb2Zmc2V0LFxuICAgICAgY2FuRGlzbWlzczogY2FuRGlzbWlzc0Jsb2Nrc0dlc3R1cmUsXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IG1vdmVTaGVldFRvQnJlYWtwb2ludCA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBicmVha3BvaW50LCBjYW5EaXNtaXNzLCBicmVha3BvaW50T2Zmc2V0IH0gPSBvcHRpb25zO1xuICAgIC8qKlxuICAgICAqIGNhbkRpc21pc3Mgc2hvdWxkIG9ubHkgcHJldmVudCBzbmFwcGluZ1xuICAgICAqIHdoZW4gdXNlcnMgYXJlIHRyeWluZyB0byBkaXNtaXNzLiBJZiBjYW5EaXNtaXNzXG4gICAgICogaXMgcHJlc2VudCBidXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHN3aXBlIHVwd2FyZHMsXG4gICAgICogd2Ugc2hvdWxkIGFsbG93IHRoYXQgdG8gaGFwcGVuLFxuICAgICAqL1xuICAgIGNvbnN0IHNob3VsZFByZXZlbnREaXNtaXNzID0gY2FuRGlzbWlzcyAmJiBicmVha3BvaW50ID09PSAwO1xuICAgIGNvbnN0IHNuYXBUb0JyZWFrcG9pbnQgPSBzaG91bGRQcmV2ZW50RGlzbWlzcyA/IGN1cnJlbnRCcmVha3BvaW50IDogYnJlYWtwb2ludDtcbiAgICBjb25zdCBzaG91bGRSZW1haW5PcGVuID0gc25hcFRvQnJlYWtwb2ludCAhPT0gMDtcbiAgICBjdXJyZW50QnJlYWtwb2ludCA9IDA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBhbmltYXRpb24gc28gdGhhdCBpdCBwbGF5cyBmcm9tXG4gICAgICogdGhlIGxhc3Qgb2Zmc2V0IHRvIHRoZSBjbG9zZXN0IHNuYXAgcG9pbnQuXG4gICAgICovXG4gICAgaWYgKHdyYXBwZXJBbmltYXRpb24gJiYgYmFja2Ryb3BBbmltYXRpb24pIHtcbiAgICAgIHdyYXBwZXJBbmltYXRpb24ua2V5ZnJhbWVzKFtcbiAgICAgICAgeyBvZmZzZXQ6IDAsIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVkoJHticmVha3BvaW50T2Zmc2V0ICogMTAwfSUpYCB9LFxuICAgICAgICB7IG9mZnNldDogMSwgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWSgkeygxIC0gc25hcFRvQnJlYWtwb2ludCkgKiAxMDB9JSlgIH0sXG4gICAgICBdKTtcbiAgICAgIGJhY2tkcm9wQW5pbWF0aW9uLmtleWZyYW1lcyhbXG4gICAgICAgIHtcbiAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgb3BhY2l0eTogYGNhbGModmFyKC0tYmFja2Ryb3Atb3BhY2l0eSkgKiAke2dldEJhY2tkcm9wVmFsdWVGb3JTaGVldCgxIC0gYnJlYWtwb2ludE9mZnNldCwgYmFja2Ryb3BCcmVha3BvaW50KX0pYCxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICBvcGFjaXR5OiBgY2FsYyh2YXIoLS1iYWNrZHJvcC1vcGFjaXR5KSAqICR7Z2V0QmFja2Ryb3BWYWx1ZUZvclNoZWV0KHNuYXBUb0JyZWFrcG9pbnQsIGJhY2tkcm9wQnJlYWtwb2ludCl9KWAsXG4gICAgICAgIH0sXG4gICAgICBdKTtcbiAgICAgIGFuaW1hdGlvbi5wcm9ncmVzc1N0ZXAoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlc3R1cmUgc2hvdWxkIHJlbWFpbiBkaXNhYmxlZCB1bnRpbCB0aGVcbiAgICAgKiBzbmFwcGluZyBhbmltYXRpb24gY29tcGxldGVzLlxuICAgICAqL1xuICAgIGdlc3R1cmUuZW5hYmxlKGZhbHNlKTtcbiAgICBpZiAoc2hvdWxkUHJldmVudERpc21pc3MpIHtcbiAgICAgIGhhbmRsZUNhbkRpc21pc3MoYmFzZUVsLCBhbmltYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2hvdWxkUmVtYWluT3Blbikge1xuICAgICAgb25EaXNtaXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgYW5pbWF0aW9uXG4gICAgICAgIC5vbkZpbmlzaCgoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRSZW1haW5PcGVuKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogT25jZSB0aGUgc25hcHBpbmcgYW5pbWF0aW9uIGNvbXBsZXRlcyxcbiAgICAgICAgICAgKiB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBhbmltYXRpb24gdG8gZ29cbiAgICAgICAgICAgKiBmcm9tIDAgdG8gMSBzbyB1c2VycyBjYW4gc3dpcGUgaW4gYW55IGRpcmVjdGlvbi5cbiAgICAgICAgICAgKiBXZSB0aGVuIHNldCB0aGUgYW5pbWF0aW9uIG9mZnNldCB0byB0aGUgY3VycmVudFxuICAgICAgICAgICAqIGJyZWFrcG9pbnQgc28gdGhhdCBpdCBzdGFydHMgYXQgdGhlIHNuYXBwZWQgcG9zaXRpb24uXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKHdyYXBwZXJBbmltYXRpb24gJiYgYmFja2Ryb3BBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJhZigoKSA9PiB7XG4gICAgICAgICAgICAgIHdyYXBwZXJBbmltYXRpb24ua2V5ZnJhbWVzKFsuLi5TaGVldERlZmF1bHRzLldSQVBQRVJfS0VZRlJBTUVTXSk7XG4gICAgICAgICAgICAgIGJhY2tkcm9wQW5pbWF0aW9uLmtleWZyYW1lcyhbLi4uU2hlZXREZWZhdWx0cy5CQUNLRFJPUF9LRVlGUkFNRVNdKTtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uLnByb2dyZXNzU3RhcnQodHJ1ZSwgMSAtIHNuYXBUb0JyZWFrcG9pbnQpO1xuICAgICAgICAgICAgICBjdXJyZW50QnJlYWtwb2ludCA9IHNuYXBUb0JyZWFrcG9pbnQ7XG4gICAgICAgICAgICAgIG9uQnJlYWtwb2ludENoYW5nZShjdXJyZW50QnJlYWtwb2ludCk7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBJZiB0aGUgc2hlZXQgaXMgZnVsbHkgZXhwYW5kZWQsIHdlIGNhbiBzYWZlbHlcbiAgICAgICAgICAgICAgICogZW5hYmxlIHNjcm9sbGluZyBhZ2Fpbi5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGlmIChjb250ZW50RWwgJiYgY3VycmVudEJyZWFrcG9pbnQgPT09IGJyZWFrcG9pbnRzW2JyZWFrcG9pbnRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgY29udGVudEVsLnNjcm9sbFkgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBCYWNrZHJvcCBzaG91bGQgYmVjb21lIGVuYWJsZWRcbiAgICAgICAgICAgICAgICogYWZ0ZXIgdGhlIGJhY2tkcm9wQnJlYWtwb2ludCB2YWx1ZVxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkRW5hYmxlQmFja2Ryb3AgPSBjdXJyZW50QnJlYWtwb2ludCA+IGJhY2tkcm9wQnJlYWtwb2ludDtcbiAgICAgICAgICAgICAgaWYgKHNob3VsZEVuYWJsZUJhY2tkcm9wKSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlQmFja2Ryb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlQmFja2Ryb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBnZXN0dXJlLmVuYWJsZSh0cnVlKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VzdHVyZS5lbmFibGUodHJ1ZSk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtdXN0IGJlIGEgb25lIHRpbWUgY2FsbGJhY2tcbiAgICAgICAgICogb3RoZXJ3aXNlIGEgbmV3IGNhbGxiYWNrIHdpbGxcbiAgICAgICAgICogYmUgYWRkZWQgZXZlcnkgdGltZSBvbkVuZCBydW5zLlxuICAgICAgICAgKi9cbiAgICAgIH0sIHsgb25lVGltZUNhbGxiYWNrOiB0cnVlIH0pXG4gICAgICAgIC5wcm9ncmVzc0VuZCgxLCAwLCA1MDApO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBnZXN0dXJlID0gY3JlYXRlR2VzdHVyZSh7XG4gICAgZWw6IHdyYXBwZXJFbCxcbiAgICBnZXN0dXJlTmFtZTogJ21vZGFsU2hlZXQnLFxuICAgIGdlc3R1cmVQcmlvcml0eTogNDAsXG4gICAgZGlyZWN0aW9uOiAneScsXG4gICAgdGhyZXNob2xkOiAxMCxcbiAgICBjYW5TdGFydCxcbiAgICBvblN0YXJ0LFxuICAgIG9uTW92ZSxcbiAgICBvbkVuZCxcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZ2VzdHVyZSxcbiAgICBtb3ZlU2hlZXRUb0JyZWFrcG9pbnQsXG4gIH07XG59O1xuXG5jb25zdCBtb2RhbElvc0NzcyA9IFwiOmhvc3R7LS13aWR0aDoxMDAlOy0tbWluLXdpZHRoOmF1dG87LS1tYXgtd2lkdGg6YXV0bzstLWhlaWdodDoxMDAlOy0tbWluLWhlaWdodDphdXRvOy0tbWF4LWhlaWdodDphdXRvOy0tb3ZlcmZsb3c6aGlkZGVuOy0tYm9yZGVyLXJhZGl1czowOy0tYm9yZGVyLXdpZHRoOjA7LS1ib3JkZXItc3R5bGU6bm9uZTstLWJvcmRlci1jb2xvcjp0cmFuc3BhcmVudDstLWJhY2tncm91bmQ6dmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpOy0tYm94LXNoYWRvdzpub25lOy0tYmFja2Ryb3Atb3BhY2l0eTowO2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOmFic29sdXRlOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtvdXRsaW5lOm5vbmU7Y29udGFpbjpzdHJpY3R9Lm1vZGFsLXdyYXBwZXIsaW9uLWJhY2tkcm9we3BvaW50ZXItZXZlbnRzOmF1dG99Omhvc3QoLm92ZXJsYXktaGlkZGVuKXtkaXNwbGF5Om5vbmV9Lm1vZGFsLXdyYXBwZXIsLm1vZGFsLXNoYWRvd3tib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO3dpZHRoOnZhcigtLXdpZHRoKTttaW4td2lkdGg6dmFyKC0tbWluLXdpZHRoKTttYXgtd2lkdGg6dmFyKC0tbWF4LXdpZHRoKTtoZWlnaHQ6dmFyKC0taGVpZ2h0KTttaW4taGVpZ2h0OnZhcigtLW1pbi1oZWlnaHQpO21heC1oZWlnaHQ6dmFyKC0tbWF4LWhlaWdodCk7Ym9yZGVyLXdpZHRoOnZhcigtLWJvcmRlci13aWR0aCk7Ym9yZGVyLXN0eWxlOnZhcigtLWJvcmRlci1zdHlsZSk7Ym9yZGVyLWNvbG9yOnZhcigtLWJvcmRlci1jb2xvcik7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTstd2Via2l0LWJveC1zaGFkb3c6dmFyKC0tYm94LXNoYWRvdyk7Ym94LXNoYWRvdzp2YXIoLS1ib3gtc2hhZG93KTtvdmVyZmxvdzp2YXIoLS1vdmVyZmxvdyk7ei1pbmRleDoxMH0ubW9kYWwtc2hhZG93e3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9QG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtaW4taGVpZ2h0OiA2MDBweCl7Omhvc3R7LS13aWR0aDo2MDBweDstLWhlaWdodDo1MDBweDstLWlvbi1zYWZlLWFyZWEtdG9wOjBweDstLWlvbi1zYWZlLWFyZWEtYm90dG9tOjBweDstLWlvbi1zYWZlLWFyZWEtcmlnaHQ6MHB4Oy0taW9uLXNhZmUtYXJlYS1sZWZ0OjBweH19QG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtaW4taGVpZ2h0OiA3NjhweCl7Omhvc3R7LS13aWR0aDo2MDBweDstLWhlaWdodDo2MDBweH19Lm1vZGFsLWhhbmRsZXtsZWZ0OjBweDtyaWdodDowcHg7dG9wOjVweDtib3JkZXItcmFkaXVzOjhweDttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjM2cHg7aGVpZ2h0OjVweDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVaKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApO2JvcmRlcjowO2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLXN0ZXAtMzUwLCAjYzBjMGJlKTtjdXJzb3I6cG9pbnRlcjt6LWluZGV4OjExfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Lm1vZGFsLWhhbmRsZXttYXJnaW4tbGVmdDp1bnNldDttYXJnaW4tcmlnaHQ6dW5zZXQ7LXdlYmtpdC1tYXJnaW4tc3RhcnQ6YXV0bzttYXJnaW4taW5saW5lLXN0YXJ0OmF1dG87LXdlYmtpdC1tYXJnaW4tZW5kOmF1dG87bWFyZ2luLWlubGluZS1lbmQ6YXV0b319Lm1vZGFsLWhhbmRsZTo6YmVmb3Jle3BhZGRpbmctbGVmdDo0cHg7cGFkZGluZy1yaWdodDo0cHg7cGFkZGluZy10b3A6NHB4O3BhZGRpbmctYm90dG9tOjRweDtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDozNnB4O2hlaWdodDo1cHg7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsIC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwgLTUwJSk7Y29udGVudDpcXFwiXFxcIn1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApey5tb2RhbC1oYW5kbGU6OmJlZm9yZXtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6NHB4O3BhZGRpbmctaW5saW5lLXN0YXJ0OjRweDstd2Via2l0LXBhZGRpbmctZW5kOjRweDtwYWRkaW5nLWlubGluZS1lbmQ6NHB4fX06aG9zdCgubW9kYWwtc2hlZXQpey0taGVpZ2h0OmNhbGMoMTAwJSAtICh2YXIoLS1pb24tc2FmZS1hcmVhLXRvcCkgKyAxMHB4KSl9Omhvc3QoLm1vZGFsLXNoZWV0KSAubW9kYWwtd3JhcHBlciw6aG9zdCgubW9kYWwtc2hlZXQpIC5tb2RhbC1zaGFkb3d7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjB9Omhvc3R7LS1iYWNrZHJvcC1vcGFjaXR5OnZhcigtLWlvbi1iYWNrZHJvcC1vcGFjaXR5LCAwLjQpfTpob3N0KC5tb2RhbC1jYXJkKSw6aG9zdCgubW9kYWwtc2hlZXQpey0tYm9yZGVyLXJhZGl1czoxMHB4fUBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpezpob3N0ey0tYm9yZGVyLXJhZGl1czoxMHB4fX0ubW9kYWwtd3JhcHBlcnstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAgMTAwJSwgIDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAgMTAwJSwgIDApfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2N3B4KXtAc3VwcG9ydHMgKHdpZHRoOiAxcHgpezpob3N0KC5tb2RhbC1jYXJkKXstLWhlaWdodDpjYWxjKDEwMCUgLSBtYXgoMzBweCwgdmFyKC0taW9uLXNhZmUtYXJlYS10b3ApKSAtIDEwcHgpfX1Ac3VwcG9ydHMgbm90ICh3aWR0aDogMXB4KXs6aG9zdCgubW9kYWwtY2FyZCl7LS1oZWlnaHQ6Y2FsYygxMDAlIC0gNDBweCl9fTpob3N0KC5tb2RhbC1jYXJkKSAubW9kYWwtd3JhcHBlcntib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowfTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC5tb2RhbC1jYXJkKSAubW9kYWwtd3JhcHBlciw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkubW9kYWwtY2FyZCAubW9kYWwtd3JhcHBlcntib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowfTpob3N0KC5tb2RhbC1jYXJkKXstLWJhY2tkcm9wLW9wYWNpdHk6MDstLXdpZHRoOjEwMCU7LW1zLWZsZXgtYWxpZ246ZW5kO2FsaWduLWl0ZW1zOmZsZXgtZW5kfTpob3N0KC5tb2RhbC1jYXJkKSAubW9kYWwtc2hhZG93e2Rpc3BsYXk6bm9uZX06aG9zdCgubW9kYWwtY2FyZCkgaW9uLWJhY2tkcm9we3BvaW50ZXItZXZlbnRzOm5vbmV9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KXs6aG9zdCgubW9kYWwtY2FyZCl7LS13aWR0aDpjYWxjKDEwMCUgLSAxMjBweCk7LS1oZWlnaHQ6Y2FsYygxMDAlIC0gKDEyMHB4ICsgdmFyKC0taW9uLXNhZmUtYXJlYS10b3ApICsgdmFyKC0taW9uLXNhZmUtYXJlYS1ib3R0b20pKSk7LS1tYXgtd2lkdGg6NzIwcHg7LS1tYXgtaGVpZ2h0OjEwMDBweDstLWJhY2tkcm9wLW9wYWNpdHk6MDstLWJveC1zaGFkb3c6MHB4IDBweCAzMHB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjEpOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgMC41cyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOmFsbCAwLjVzIGVhc2UtaW4tb3V0fTpob3N0KC5tb2RhbC1jYXJkKSAubW9kYWwtd3JhcHBlcnstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9Omhvc3QoLm1vZGFsLWNhcmQpIC5tb2RhbC1zaGFkb3d7LXdlYmtpdC1ib3gtc2hhZG93OnZhcigtLWJveC1zaGFkb3cpO2JveC1zaGFkb3c6dmFyKC0tYm94LXNoYWRvdyl9fTpob3N0KC5tb2RhbC1zaGVldCkgLm1vZGFsLXdyYXBwZXJ7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czp2YXIoLS1ib3JkZXItcmFkaXVzKTtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czp2YXIoLS1ib3JkZXItcmFkaXVzKTtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MH06aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgubW9kYWwtc2hlZXQpIC5tb2RhbC13cmFwcGVyLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS5tb2RhbC1zaGVldCAubW9kYWwtd3JhcHBlcntib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowfVwiO1xuXG5jb25zdCBtb2RhbE1kQ3NzID0gXCI6aG9zdHstLXdpZHRoOjEwMCU7LS1taW4td2lkdGg6YXV0bzstLW1heC13aWR0aDphdXRvOy0taGVpZ2h0OjEwMCU7LS1taW4taGVpZ2h0OmF1dG87LS1tYXgtaGVpZ2h0OmF1dG87LS1vdmVyZmxvdzpoaWRkZW47LS1ib3JkZXItcmFkaXVzOjA7LS1ib3JkZXItd2lkdGg6MDstLWJvcmRlci1zdHlsZTpub25lOy0tYm9yZGVyLWNvbG9yOnRyYW5zcGFyZW50Oy0tYmFja2dyb3VuZDp2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvciwgI2ZmZik7LS1ib3gtc2hhZG93Om5vbmU7LS1iYWNrZHJvcC1vcGFjaXR5OjA7bGVmdDowO3JpZ2h0OjA7dG9wOjA7Ym90dG9tOjA7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cG9zaXRpb246YWJzb2x1dGU7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO291dGxpbmU6bm9uZTtjb250YWluOnN0cmljdH0ubW9kYWwtd3JhcHBlcixpb24tYmFja2Ryb3B7cG9pbnRlci1ldmVudHM6YXV0b306aG9zdCgub3ZlcmxheS1oaWRkZW4pe2Rpc3BsYXk6bm9uZX0ubW9kYWwtd3JhcHBlciwubW9kYWwtc2hhZG93e2JvcmRlci1yYWRpdXM6dmFyKC0tYm9yZGVyLXJhZGl1cyk7d2lkdGg6dmFyKC0td2lkdGgpO21pbi13aWR0aDp2YXIoLS1taW4td2lkdGgpO21heC13aWR0aDp2YXIoLS1tYXgtd2lkdGgpO2hlaWdodDp2YXIoLS1oZWlnaHQpO21pbi1oZWlnaHQ6dmFyKC0tbWluLWhlaWdodCk7bWF4LWhlaWdodDp2YXIoLS1tYXgtaGVpZ2h0KTtib3JkZXItd2lkdGg6dmFyKC0tYm9yZGVyLXdpZHRoKTtib3JkZXItc3R5bGU6dmFyKC0tYm9yZGVyLXN0eWxlKTtib3JkZXItY29sb3I6dmFyKC0tYm9yZGVyLWNvbG9yKTtiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQpOy13ZWJraXQtYm94LXNoYWRvdzp2YXIoLS1ib3gtc2hhZG93KTtib3gtc2hhZG93OnZhcigtLWJveC1zaGFkb3cpO292ZXJmbG93OnZhcigtLW92ZXJmbG93KTt6LWluZGV4OjEwfS5tb2RhbC1zaGFkb3d7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZDp0cmFuc3BhcmVudH1AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDYwMHB4KXs6aG9zdHstLXdpZHRoOjYwMHB4Oy0taGVpZ2h0OjUwMHB4Oy0taW9uLXNhZmUtYXJlYS10b3A6MHB4Oy0taW9uLXNhZmUtYXJlYS1ib3R0b206MHB4Oy0taW9uLXNhZmUtYXJlYS1yaWdodDowcHg7LS1pb24tc2FmZS1hcmVhLWxlZnQ6MHB4fX1AbWVkaWEgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDc2OHB4KXs6aG9zdHstLXdpZHRoOjYwMHB4Oy0taGVpZ2h0OjYwMHB4fX0ubW9kYWwtaGFuZGxle2xlZnQ6MHB4O3JpZ2h0OjBweDt0b3A6NXB4O2JvcmRlci1yYWRpdXM6OHB4O21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG87cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MzZweDtoZWlnaHQ6NXB4Oy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7Ym9yZGVyOjA7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3Itc3RlcC0zNTAsICNjMGMwYmUpO2N1cnNvcjpwb2ludGVyO3otaW5kZXg6MTF9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsubW9kYWwtaGFuZGxle21hcmdpbi1sZWZ0OnVuc2V0O21hcmdpbi1yaWdodDp1bnNldDstd2Via2l0LW1hcmdpbi1zdGFydDphdXRvO21hcmdpbi1pbmxpbmUtc3RhcnQ6YXV0bzstd2Via2l0LW1hcmdpbi1lbmQ6YXV0bzttYXJnaW4taW5saW5lLWVuZDphdXRvfX0ubW9kYWwtaGFuZGxlOjpiZWZvcmV7cGFkZGluZy1sZWZ0OjRweDtwYWRkaW5nLXJpZ2h0OjRweDtwYWRkaW5nLXRvcDo0cHg7cGFkZGluZy1ib3R0b206NHB4O3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjM2cHg7aGVpZ2h0OjVweDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwgLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtjb250ZW50OlxcXCJcXFwifUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Lm1vZGFsLWhhbmRsZTo6YmVmb3Jle3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDo0cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6NHB4Oy13ZWJraXQtcGFkZGluZy1lbmQ6NHB4O3BhZGRpbmctaW5saW5lLWVuZDo0cHh9fTpob3N0KC5tb2RhbC1zaGVldCl7LS1oZWlnaHQ6Y2FsYygxMDAlIC0gKHZhcigtLWlvbi1zYWZlLWFyZWEtdG9wKSArIDEwcHgpKX06aG9zdCgubW9kYWwtc2hlZXQpIC5tb2RhbC13cmFwcGVyLDpob3N0KC5tb2RhbC1zaGVldCkgLm1vZGFsLXNoYWRvd3twb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MH06aG9zdHstLWJhY2tkcm9wLW9wYWNpdHk6dmFyKC0taW9uLWJhY2tkcm9wLW9wYWNpdHksIDAuMzIpfUBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIGFuZCAobWluLWhlaWdodDogNjAwcHgpezpob3N0ey0tYm9yZGVyLXJhZGl1czoycHg7LS1ib3gtc2hhZG93OjAgMjhweCA0OHB4IHJnYmEoMCwgMCwgMCwgMC40KX19Lm1vZGFsLXdyYXBwZXJ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgIDQwcHgsICAwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgIDQwcHgsICAwKTtvcGFjaXR5OjAuMDF9XCI7XG5cbmNvbnN0IE1vZGFsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmRpZFByZXNlbnQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvbk1vZGFsRGlkUHJlc2VudFwiLCA3KTtcbiAgICB0aGlzLndpbGxQcmVzZW50ID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25Nb2RhbFdpbGxQcmVzZW50XCIsIDcpO1xuICAgIHRoaXMud2lsbERpc21pc3MgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvbk1vZGFsV2lsbERpc21pc3NcIiwgNyk7XG4gICAgdGhpcy5kaWREaXNtaXNzID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25Nb2RhbERpZERpc21pc3NcIiwgNyk7XG4gICAgdGhpcy5pb25CcmVha3BvaW50RGlkQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25CcmVha3BvaW50RGlkQ2hhbmdlXCIsIDcpO1xuICAgIHRoaXMuZGlkUHJlc2VudFNob3J0aGFuZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiZGlkUHJlc2VudFwiLCA3KTtcbiAgICB0aGlzLndpbGxQcmVzZW50U2hvcnRoYW5kID0gY3JlYXRlRXZlbnQodGhpcywgXCJ3aWxsUHJlc2VudFwiLCA3KTtcbiAgICB0aGlzLndpbGxEaXNtaXNzU2hvcnRoYW5kID0gY3JlYXRlRXZlbnQodGhpcywgXCJ3aWxsRGlzbWlzc1wiLCA3KTtcbiAgICB0aGlzLmRpZERpc21pc3NTaG9ydGhhbmQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImRpZERpc21pc3NcIiwgNyk7XG4gICAgdGhpcy5tb2RhbEluZGV4ID0gbW9kYWxJZHMrKztcbiAgICB0aGlzLmNvcmVEZWxlZ2F0ZSA9IENvcmVEZWxlZ2F0ZSgpO1xuICAgIHRoaXMuaXNTaGVldE1vZGFsID0gZmFsc2U7XG4gICAgdGhpcy5pbmhlcml0ZWRBdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5pbmxpbmUgPSBmYWxzZTtcbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBtb2RhbCBpcyBiZWluZyBkaXNtaXNzZWQgdmlhIGdlc3R1cmVcbiAgICB0aGlzLmdlc3R1cmVBbmltYXRpb25EaXNtaXNzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wcmVzZW50ZWQgPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5oYXNDb250cm9sbGVyID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUga2V5Ym9hcmQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRpc21pc3NlZCB3aGVuIHRoZSBvdmVybGF5IGlzIHByZXNlbnRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmtleWJvYXJkQ2xvc2UgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEEgZGVjaW1hbCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgdGhhdCBpbmRpY2F0ZXMgdGhlXG4gICAgICogcG9pbnQgYWZ0ZXIgd2hpY2ggdGhlIGJhY2tkcm9wIHdpbGwgYmVnaW4gdG8gZmFkZSBpblxuICAgICAqIHdoZW4gdXNpbmcgYSBzaGVldCBtb2RhbC4gUHJpb3IgdG8gdGhpcyBwb2ludCwgdGhlXG4gICAgICogYmFja2Ryb3Agd2lsbCBiZSBoaWRkZW4gYW5kIHRoZSBjb250ZW50IHVuZGVybmVhdGhcbiAgICAgKiB0aGUgc2hlZXQgY2FuIGJlIGludGVyYWN0ZWQgd2l0aC4gVGhpcyB2YWx1ZSBpcyBleGNsdXNpdmVcbiAgICAgKiBtZWFuaW5nIHRoZSBiYWNrZHJvcCB3aWxsIGJlY29tZSBhY3RpdmUgYWZ0ZXIgdGhlIHZhbHVlXG4gICAgICogc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIHRoaXMuYmFja2Ryb3BCcmVha3BvaW50ID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJhY3Rpb24gYmVoYXZpb3IgZm9yIHRoZSBzaGVldCBtb2RhbCB3aGVuIHRoZSBoYW5kbGUgaXMgcHJlc3NlZC5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIGBcIm5vbmVcImAsIHdoaWNoICBtZWFucyB0aGUgbW9kYWwgd2lsbCBub3QgY2hhbmdlIHNpemUgb3IgcG9zaXRpb24gd2hlbiB0aGUgaGFuZGxlIGlzIHByZXNzZWQuXG4gICAgICogU2V0IHRvIGBcImN5Y2xlXCJgIHRvIGxldCB0aGUgbW9kYWwgY3ljbGUgYmV0d2VlbiBhdmFpbGFibGUgYnJlYWtwb2ludHMgd2hlbiBwcmVzc2VkLlxuICAgICAqXG4gICAgICogSGFuZGxlIGJlaGF2aW9yIGlzIHVuYXZhaWxhYmxlIHdoZW4gdGhlIGBoYW5kbGVgIHByb3BlcnR5IGlzIHNldCB0byBgZmFsc2VgIG9yXG4gICAgICogd2hlbiB0aGUgYGJyZWFrcG9pbnRzYCBwcm9wZXJ0eSBpcyBub3Qgc2V0ICh1c2luZyBhIGZ1bGxzY3JlZW4gb3IgY2FyZCBtb2RhbCkuXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVCZWhhdmlvciA9ICdub25lJztcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCB3aWxsIGJlIGRpc21pc3NlZCB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLlxuICAgICAqL1xuICAgIHRoaXMuYmFja2Ryb3BEaXNtaXNzID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIGEgYmFja2Ryb3Agd2lsbCBiZSBkaXNwbGF5ZWQgYmVoaW5kIHRoZSBtb2RhbC5cbiAgICAgKiBUaGlzIHByb3BlcnR5IGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IHRoZSBiYWNrZHJvcFxuICAgICAqIGRhcmtlbnMgdGhlIHNjcmVlbiB3aGVuIHRoZSBtb2RhbCBpcyBwcmVzZW50ZWQuXG4gICAgICogSXQgZG9lcyBub3QgY29udHJvbCB3aGV0aGVyIG9yIG5vdCB0aGUgYmFja2Ryb3BcbiAgICAgKiBpcyBhY3RpdmUgb3IgcHJlc2VudCBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIHRoaXMuc2hvd0JhY2tkcm9wID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCB3aWxsIGFuaW1hdGUuXG4gICAgICovXG4gICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgbW9kYWwgY2FuIGJlIHN3aXBlZCB0byBkaXNtaXNzLiBPbmx5IGFwcGxpZXMgaW4gaU9TIG1vZGUuXG4gICAgICogQGRlcHJlY2F0ZWQgLSBUbyBwcmV2ZW50IG1vZGFscyBmcm9tIGRpc21pc3NpbmcsIHVzZSBjYW5EaXNtaXNzIGluc3RlYWQuXG4gICAgICovXG4gICAgdGhpcy5zd2lwZVRvQ2xvc2UgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCB3aWxsIG9wZW4uIElmIGBmYWxzZWAsIHRoZSBtb2RhbCB3aWxsIGNsb3NlLlxuICAgICAqIFVzZSB0aGlzIGlmIHlvdSBuZWVkIGZpbmVyIGdyYWluZWQgY29udHJvbCBvdmVyIHByZXNlbnRhdGlvbiwgb3RoZXJ3aXNlXG4gICAgICoganVzdCB1c2UgdGhlIG1vZGFsQ29udHJvbGxlciBvciB0aGUgYHRyaWdnZXJgIHByb3BlcnR5LlxuICAgICAqIE5vdGU6IGBpc09wZW5gIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgYmUgc2V0IGJhY2sgdG8gYGZhbHNlYCB3aGVuXG4gICAgICogdGhlIG1vZGFsIGRpc21pc3Nlcy4gWW91IHdpbGwgbmVlZCB0byBkbyB0aGF0IGluIHlvdXIgY29kZS5cbiAgICAgKi9cbiAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBwYXNzZWQgaW50byBgaW9uLW1vZGFsYCB3aWxsXG4gICAgICogYXV0b21hdGljYWxseSBiZSBtb3VudGVkIHdoZW4gdGhlIG1vZGFsIGlzIGNyZWF0ZWQuIFRoZVxuICAgICAqIGNvbXBvbmVudCB3aWxsIHJlbWFpbiBtb3VudGVkIGV2ZW4gd2hlbiB0aGUgbW9kYWwgaXMgZGlzbWlzc2VkLlxuICAgICAqIEhvd2V2ZXIsIHRoZSBjb21wb25lbnQgd2lsbCBiZSBkZXN0cm95ZWQgd2hlbiB0aGUgbW9kYWwgaXNcbiAgICAgKiBkZXN0cm95ZWQuIFRoaXMgcHJvcGVydHkgaXMgbm90IHJlYWN0aXZlIGFuZCBzaG91bGQgb25seSBiZVxuICAgICAqIHVzZWQgd2hlbiBpbml0aWFsbHkgY3JlYXRpbmcgYSBtb2RhbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgZmVhdHVyZSBvbmx5IGFwcGxpZXMgdG8gaW5saW5lIG1vZGFscyBpbiBKYXZhU2NyaXB0XG4gICAgICogZnJhbWV3b3JrcyBzdWNoIGFzIEFuZ3VsYXIsIFJlYWN0LCBhbmQgVnVlLlxuICAgICAqL1xuICAgIHRoaXMua2VlcENvbnRlbnRzTW91bnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29uZmlndXJlVHJpZ2dlckludGVyYWN0aW9uID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyB0cmlnZ2VyLCBlbCwgZGVzdHJveVRyaWdnZXJJbnRlcmFjdGlvbiB9ID0gdGhpcztcbiAgICAgIGlmIChkZXN0cm95VHJpZ2dlckludGVyYWN0aW9uKSB7XG4gICAgICAgIGRlc3Ryb3lUcmlnZ2VySW50ZXJhY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyaWdnZXJFbCA9IHRyaWdnZXIgIT09IHVuZGVmaW5lZCA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRyaWdnZXIpIDogbnVsbDtcbiAgICAgIGlmICghdHJpZ2dlckVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbmZpZ3VyZVRyaWdnZXJJbnRlcmFjdGlvbiA9ICh0cmlnRWwsIG1vZGFsRWwpID0+IHtcbiAgICAgICAgY29uc3Qgb3Blbk1vZGFsID0gKCkgPT4ge1xuICAgICAgICAgIG1vZGFsRWwucHJlc2VudCgpO1xuICAgICAgICB9O1xuICAgICAgICB0cmlnRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvcGVuTW9kYWwpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHRyaWdFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9wZW5Nb2RhbCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdGhpcy5kZXN0cm95VHJpZ2dlckludGVyYWN0aW9uID0gY29uZmlndXJlVHJpZ2dlckludGVyYWN0aW9uKHRyaWdnZXJFbCwgZWwpO1xuICAgIH07XG4gICAgdGhpcy5vbkhhbmRsZUNsaWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBzaGVldFRyYW5zaXRpb24sIGhhbmRsZUJlaGF2aW9yIH0gPSB0aGlzO1xuICAgICAgaWYgKGhhbmRsZUJlaGF2aW9yICE9PSAnY3ljbGUnIHx8IHNoZWV0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2hlZXQgbW9kYWwgc2hvdWxkIG5vdCBhZHZhbmNlIHRvIHRoZSBuZXh0IGJyZWFrcG9pbnRcbiAgICAgICAgICogaWYgdGhlIGhhbmRsZSBiZWhhdmlvciBpcyBub3QgYGN5Y2xlYCBvciBpZiB0aGUgaGFuZGxlXG4gICAgICAgICAqIGlzIGNsaWNrZWQgd2hpbGUgdGhlIHNoZWV0IGlzIG1vdmluZyB0byBhIGJyZWFrcG9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1vdmVUb05leHRCcmVha3BvaW50KCk7XG4gICAgfTtcbiAgICB0aGlzLm9uQmFja2Ryb3BUYXAgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHNoZWV0VHJhbnNpdGlvbiB9ID0gdGhpcztcbiAgICAgIGlmIChzaGVldFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgaGFuZGxlIGlzIGRvdWJsZSBjbGlja2VkIGF0IHRoZSBsYXJnZXN0IGJyZWFrcG9pbnQsXG4gICAgICAgICAqIGl0IHdpbGwgc3RhcnQgdG8gbW92ZSB0byB0aGUgZmlyc3QgYnJlYWtwb2ludC4gV2hpbGUgdHJhbnNpdGlvbmluZyxcbiAgICAgICAgICogdGhlIGJhY2tkcm9wIHdpbGwgb2Z0ZW4gcmVjZWl2ZSB0aGUgc2Vjb25kIGNsaWNrLiBXZSBwcmV2ZW50IHRoZVxuICAgICAgICAgKiBiYWNrZHJvcCBmcm9tIGRpc21pc3NpbmcgdGhlIG1vZGFsIHdoaWxlIG1vdmluZyBiZXR3ZWVuIGJyZWFrcG9pbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNtaXNzKHVuZGVmaW5lZCwgQkFDS0RST1ApO1xuICAgIH07XG4gICAgdGhpcy5vbkxpZmVjeWNsZSA9IChtb2RhbEV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMudXNlcnNFbGVtZW50O1xuICAgICAgY29uc3QgbmFtZSA9IExJRkVDWUNMRV9NQVBbbW9kYWxFdmVudC50eXBlXTtcbiAgICAgIGlmIChlbCAmJiBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV2ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgICBkZXRhaWw6IG1vZGFsRXZlbnQuZGV0YWlsLFxuICAgICAgICB9KTtcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBvbklzT3BlbkNoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBpZiAobmV3VmFsdWUgPT09IHRydWUgJiYgb2xkVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnByZXNlbnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3VmFsdWUgPT09IGZhbHNlICYmIG9sZFZhbHVlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmRpc21pc3MoKTtcbiAgICB9XG4gIH1cbiAgb25UcmlnZ2VyQ2hhbmdlKCkge1xuICAgIHRoaXMuY29uZmlndXJlVHJpZ2dlckludGVyYWN0aW9uKCk7XG4gIH1cbiAgYXN5bmMgc3dpcGVUb0Nsb3NlQ2hhbmdlZChlbmFibGUpIHtcbiAgICBpZiAodGhpcy5nZXN0dXJlKSB7XG4gICAgICB0aGlzLmdlc3R1cmUuZW5hYmxlKGVuYWJsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuYWJsZSkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0U3dpcGVUb0Nsb3NlKCk7XG4gICAgfVxuICB9XG4gIGJyZWFrcG9pbnRzQ2hhbmdlZChicmVha3BvaW50cykge1xuICAgIGlmIChicmVha3BvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNvcnRlZEJyZWFrcG9pbnRzID0gYnJlYWtwb2ludHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBwcmVwYXJlT3ZlcmxheSh0aGlzLmVsKTtcbiAgfVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBjb25zdCB7IGJyZWFrcG9pbnRzLCBpbml0aWFsQnJlYWtwb2ludCwgc3dpcGVUb0Nsb3NlLCBlbCB9ID0gdGhpcztcbiAgICB0aGlzLmluaGVyaXRlZEF0dHJpYnV0ZXMgPSBpbmhlcml0QXR0cmlidXRlcyhlbCwgWydyb2xlJ10pO1xuICAgIC8qKlxuICAgICAqIElmIHVzZXIgaGFzIGN1c3RvbSBJRCBzZXQgdGhlbiB3ZSBzaG91bGRcbiAgICAgKiBub3QgYXNzaWduIHRoZSBkZWZhdWx0IGluY3JlbWVudGluZyBJRC5cbiAgICAgKi9cbiAgICB0aGlzLm1vZGFsSWQgPSB0aGlzLmVsLmhhc0F0dHJpYnV0ZSgnaWQnKSA/IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdpZCcpIDogYGlvbi1tb2RhbC0ke3RoaXMubW9kYWxJbmRleH1gO1xuICAgIGNvbnN0IGlzU2hlZXRNb2RhbCA9ICh0aGlzLmlzU2hlZXRNb2RhbCA9IGJyZWFrcG9pbnRzICE9PSB1bmRlZmluZWQgJiYgaW5pdGlhbEJyZWFrcG9pbnQgIT09IHVuZGVmaW5lZCk7XG4gICAgaWYgKGlzU2hlZXRNb2RhbCkge1xuICAgICAgdGhpcy5jdXJyZW50QnJlYWtwb2ludCA9IHRoaXMuaW5pdGlhbEJyZWFrcG9pbnQ7XG4gICAgfVxuICAgIGlmIChicmVha3BvaW50cyAhPT0gdW5kZWZpbmVkICYmIGluaXRpYWxCcmVha3BvaW50ICE9PSB1bmRlZmluZWQgJiYgIWJyZWFrcG9pbnRzLmluY2x1ZGVzKGluaXRpYWxCcmVha3BvaW50KSkge1xuICAgICAgcHJpbnRJb25XYXJuaW5nKCdZb3VyIGJyZWFrcG9pbnRzIGFycmF5IG11c3QgaW5jbHVkZSB0aGUgaW5pdGlhbEJyZWFrcG9pbnQgdmFsdWUuJyk7XG4gICAgfVxuICAgIGlmIChzd2lwZVRvQ2xvc2UpIHtcbiAgICAgIHByaW50SW9uV2FybmluZygnc3dpcGVUb0Nsb3NlIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgY2FuRGlzbWlzcy5cXG5cXG5JZiB5b3Ugd2FudCBhIGNhcmQgbW9kYWwgdG8gYmUgc3dpcGVhYmxlLCBzZXQgY2FuRGlzbWlzcyB0byBgdHJ1ZWAuIEluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Ugb2YgSW9uaWMsIHN3aXBlVG9DbG9zZSB3aWxsIGJlIHJlbW92ZWQsIGFuZCBhbGwgY2FyZCBtb2RhbHMgd2lsbCBiZSBzd2lwZWFibGUgYnkgZGVmYXVsdC4nKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAvKipcbiAgICAgKiBJZiBtb2RhbCB3YXMgcmVuZGVyZWQgd2l0aCBpc09wZW49XCJ0cnVlXCJcbiAgICAgKiB0aGVuIHdlIHNob3VsZCBvcGVuIG1vZGFsIGltbWVkaWF0ZWx5LlxuICAgICAqL1xuICAgIGlmICh0aGlzLmlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgcmFmKCgpID0+IHRoaXMucHJlc2VudCgpKTtcbiAgICB9XG4gICAgdGhpcy5icmVha3BvaW50c0NoYW5nZWQodGhpcy5icmVha3BvaW50cyk7XG4gICAgdGhpcy5jb25maWd1cmVUcmlnZ2VySW50ZXJhY3Rpb24oKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBhbiBvdmVybGF5XG4gICAqIGlzIGJlaW5nIHVzZWQgaW5saW5lIG9yIHZpYSBhIGNvbnRyb2xsZXIvSlNcbiAgICogYW5kIHJldHVybnMgdGhlIGNvcnJlY3QgZGVsZWdhdGUuXG4gICAqIEJ5IGRlZmF1bHQsIHN1YnNlcXVlbnQgY2FsbHMgdG8gZ2V0RGVsZWdhdGVcbiAgICogd2lsbCB1c2UgYSBjYWNoZWQgdmVyc2lvbiBvZiB0aGUgZGVsZWdhdGUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYWxsaW5nIGRpc21pc3MgYWZ0ZXJcbiAgICogcHJlc2VudCBzbyB0aGF0IHRoZSBjb3JyZWN0IGRlbGVnYXRlIGlzIGdpdmVuLlxuICAgKi9cbiAgZ2V0RGVsZWdhdGUoZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLndvcmtpbmdEZWxlZ2F0ZSAmJiAhZm9yY2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlbGVnYXRlOiB0aGlzLndvcmtpbmdEZWxlZ2F0ZSxcbiAgICAgICAgaW5saW5lOiB0aGlzLmlubGluZSxcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHVzaW5nIG92ZXJsYXkgaW5saW5lXG4gICAgICogd2UgcG90ZW50aWFsbHkgbmVlZCB0byB1c2UgdGhlIGNvcmVEZWxlZ2F0ZVxuICAgICAqIHNvIHRoYXQgdGhpcyB3b3JrcyBpbiB2YW5pbGxhIEpTIGFwcHMuXG4gICAgICogSWYgYSBkZXZlbG9wZXIgaGFzIHByZXNlbnRlZCB0aGlzIGNvbXBvbmVudFxuICAgICAqIHZpYSBhIGNvbnRyb2xsZXIsIHRoZW4gd2UgY2FuIGFzc3VtZVxuICAgICAqIHRoZSBjb21wb25lbnQgaXMgYWxyZWFkeSBpbiB0aGVcbiAgICAgKiBjb3JyZWN0IHBsYWNlLlxuICAgICAqL1xuICAgIGNvbnN0IHBhcmVudEVsID0gdGhpcy5lbC5wYXJlbnROb2RlO1xuICAgIGNvbnN0IGlubGluZSA9ICh0aGlzLmlubGluZSA9IHBhcmVudEVsICE9PSBudWxsICYmICF0aGlzLmhhc0NvbnRyb2xsZXIpO1xuICAgIGNvbnN0IGRlbGVnYXRlID0gKHRoaXMud29ya2luZ0RlbGVnYXRlID0gaW5saW5lID8gdGhpcy5kZWxlZ2F0ZSB8fCB0aGlzLmNvcmVEZWxlZ2F0ZSA6IHRoaXMuZGVsZWdhdGUpO1xuICAgIHJldHVybiB7IGlubGluZSwgZGVsZWdhdGUgfTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICogbW9kYWwgaXMgYWxsb3dlZCB0byBkaXNtaXNzIGJhc2VkXG4gICAqIG9uIHRoZSBzdGF0ZSBvZiB0aGUgY2FuRGlzbWlzcyBwcm9wLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tDYW5EaXNtaXNzKCkge1xuICAgIGNvbnN0IHsgY2FuRGlzbWlzcyB9ID0gdGhpcztcbiAgICAvKipcbiAgICAgKiBUT0RPIChGVy05MzcpIC0gUmVtb3ZlIHRoZSBmb2xsb3dpbmcgY2hlY2sgaW5cbiAgICAgKiB0aGUgbmV4dCBtYWpvciByZWxlYXNlIG9mIElvbmljLlxuICAgICAqL1xuICAgIGlmIChjYW5EaXNtaXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbkRpc21pc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjYW5EaXNtaXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5EaXNtaXNzO1xuICB9XG4gIC8qKlxuICAgKiBQcmVzZW50IHRoZSBtb2RhbCBvdmVybGF5IGFmdGVyIGl0IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAqL1xuICBhc3luYyBwcmVzZW50KCkge1xuICAgIGlmICh0aGlzLnByZXNlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIGFuIGlubGluZSBtb2RhbFxuICAgICAqIGFuZCBkaXNtaXNzaW5nIGEgbW9kYWwgaXQgaXMgcG9zc2libGUgdG9cbiAgICAgKiBxdWlja2x5IHByZXNlbnQgdGhlIG1vZGFsIHdoaWxlIGl0IGlzXG4gICAgICogZGlzbWlzc2luZy4gV2UgbmVlZCB0byBhd2FpdCBhbnkgY3VycmVudFxuICAgICAqIHRyYW5zaXRpb24gdG8gYWxsb3cgdGhlIGRpc21pc3MgdG8gZmluaXNoXG4gICAgICogYmVmb3JlIHByZXNlbnRpbmcgYWdhaW4uXG4gICAgICovXG4gICAgaWYgKHRoaXMuY3VycmVudFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50VHJhbnNpdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIG1vZGFsIGlzIHByZXNlbnRlZCBtdWx0aXBsZSB0aW1lcyAoaW5saW5lIG1vZGFscyksIHdlXG4gICAgICogbmVlZCB0byByZXNldCB0aGUgY3VycmVudCBicmVha3BvaW50IHRvIHRoZSBpbml0aWFsIGJyZWFrcG9pbnQuXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50QnJlYWtwb2ludCA9IHRoaXMuaW5pdGlhbEJyZWFrcG9pbnQ7XG4gICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21wb25lbnRQcm9wcyksIHsgbW9kYWw6IHRoaXMuZWwgfSk7XG4gICAgY29uc3QgeyBpbmxpbmUsIGRlbGVnYXRlIH0gPSB0aGlzLmdldERlbGVnYXRlKHRydWUpO1xuICAgIHRoaXMudXNlcnNFbGVtZW50ID0gYXdhaXQgYXR0YWNoQ29tcG9uZW50KGRlbGVnYXRlLCB0aGlzLmVsLCB0aGlzLmNvbXBvbmVudCwgWydpb24tcGFnZSddLCBkYXRhLCBpbmxpbmUpO1xuICAgIGF3YWl0IGRlZXBSZWFkeSh0aGlzLnVzZXJzRWxlbWVudCk7XG4gICAgd3JpdGVUYXNrKCgpID0+IHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnc2hvdy1tb2RhbCcpKTtcbiAgICB0aGlzLmN1cnJlbnRUcmFuc2l0aW9uID0gcHJlc2VudCh0aGlzLCAnbW9kYWxFbnRlcicsIGlvc0VudGVyQW5pbWF0aW9uLCBtZEVudGVyQW5pbWF0aW9uLCB7XG4gICAgICBwcmVzZW50aW5nRWw6IHRoaXMucHJlc2VudGluZ0VsZW1lbnQsXG4gICAgICBjdXJyZW50QnJlYWtwb2ludDogdGhpcy5pbml0aWFsQnJlYWtwb2ludCxcbiAgICAgIGJhY2tkcm9wQnJlYWtwb2ludDogdGhpcy5iYWNrZHJvcEJyZWFrcG9pbnQsXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVE9ETyAoRlctOTM3KSAtIEluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Ugb2YgSW9uaWMsIGFsbCBjYXJkIG1vZGFsc1xuICAgICAqIHdpbGwgYmUgc3dpcGVhYmxlIGJ5IGRlZmF1bHQuIGNhbkRpc21pc3Mgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB0aGVcbiAgICAgKiBtb2RhbCBjYW4gYmUgZGlzbWlzc2VkLiBUaGlzIGNoZWNrIHNob3VsZCBjaGFuZ2UgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mXG4gICAgICogcHJlc2VudGluZ0VsZW1lbnQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIElmIHdlIGRpZCBub3QgZG8gdGhpcyBjaGVjaywgdGhlbiBub3QgdXNpbmcgc3dpcGVUb0Nsb3NlIHdvdWxkIG1lYW4geW91IGNvdWxkXG4gICAgICogbm90IHJ1biBjYW5EaXNtaXNzIG9uIHN3aXBlIGFzIHRoZXJlIHdvdWxkIGJlIG5vIHN3aXBlIGdlc3R1cmUgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBjb25zdCBoYXNDYXJkTW9kYWwgPSB0aGlzLnN3aXBlVG9DbG9zZSB8fCAodGhpcy5jYW5EaXNtaXNzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wcmVzZW50aW5nRWxlbWVudCAhPT0gdW5kZWZpbmVkKTtcbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgc3RhdHVzIGJhciBhdCB0aGVcbiAgICAgKiBzdGFydCBvZiB0aGUgYW5pbWF0aW9uIHNvIHRoYXQgaXQgY29tcGxldGVzXG4gICAgICogYnkgdGhlIHRpbWUgdGhlIGNhcmQgYW5pbWF0aW9uIGlzIGRvbmUuXG4gICAgICovXG4gICAgaWYgKGhhc0NhcmRNb2RhbCAmJiBnZXRJb25Nb2RlKHRoaXMpID09PSAnaW9zJykge1xuICAgICAgc2V0Q2FyZFN0YXR1c0JhckRhcmsoKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5jdXJyZW50VHJhbnNpdGlvbjtcbiAgICBpZiAodGhpcy5pc1NoZWV0TW9kYWwpIHtcbiAgICAgIHRoaXMuaW5pdFNoZWV0R2VzdHVyZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXNDYXJkTW9kYWwpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFN3aXBlVG9DbG9zZSgpO1xuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMua2V5Ym9hcmRPcGVuQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmdlc3R1cmUpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGVuIHRoZSBuYXRpdmUga2V5Ym9hcmQgaXMgb3BlbmVkIGFuZCB0aGUgd2Vidmlld1xuICAgICAgICAgICAqIGlzIHJlc2l6ZWQsIHRoZSBnZXN0dXJlIGltcGxlbWVudGF0aW9uIHdpbGwgYmVjb21lIHVucmVzcG9uc2l2ZVxuICAgICAgICAgICAqIGFuZCBlbnRlciBhIGZyZWUtc2Nyb2xsIG1vZGUuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBXaGVuIHRoZSBrZXlib2FyZCBpcyBvcGVuZWQsIHdlIGRpc2FibGUgdGhlIGdlc3R1cmUgZm9yXG4gICAgICAgICAgICogYSBzaW5nbGUgZnJhbWUgYW5kIHJlLWVuYWJsZSBvbmNlIHRoZSBjb250ZW50cyBoYXZlIHJlcG9zaXRpb25lZFxuICAgICAgICAgICAqIGZyb20gdGhlIGtleWJvYXJkIHBsYWNlbWVudC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLmdlc3R1cmUuZW5hYmxlKGZhbHNlKTtcbiAgICAgICAgICByYWYoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2VzdHVyZSkge1xuICAgICAgICAgICAgICB0aGlzLmdlc3R1cmUuZW5hYmxlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoS0VZQk9BUkRfRElEX09QRU4sIHRoaXMua2V5Ym9hcmRPcGVuQ2FsbGJhY2spO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRUcmFuc2l0aW9uID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRTd2lwZVRvQ2xvc2UoKSB7XG4gICAgaWYgKGdldElvbk1vZGUodGhpcykgIT09ICdpb3MnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZWwgfSA9IHRoaXM7XG4gICAgLy8gQWxsIG9mIHRoZSBlbGVtZW50cyBuZWVkZWQgZm9yIHRoZSBzd2lwZSBnZXN0dXJlXG4gICAgLy8gc2hvdWxkIGJlIGluIHRoZSBET00gYW5kIHJlZmVyZW5jZWQgYnkgbm93LCBleGNlcHRcbiAgICAvLyBmb3IgdGhlIHByZXNlbnRpbmcgZWxcbiAgICBjb25zdCBhbmltYXRpb25CdWlsZGVyID0gdGhpcy5sZWF2ZUFuaW1hdGlvbiB8fCBjb25maWcuZ2V0KCdtb2RhbExlYXZlJywgaW9zTGVhdmVBbmltYXRpb24pO1xuICAgIGNvbnN0IGFuaSA9ICh0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbkJ1aWxkZXIoZWwsIHsgcHJlc2VudGluZ0VsOiB0aGlzLnByZXNlbnRpbmdFbGVtZW50IH0pKTtcbiAgICBjb25zdCBjb250ZW50RWwgPSBmaW5kSW9uQ29udGVudChlbCk7XG4gICAgaWYgKCFjb250ZW50RWwpIHtcbiAgICAgIHByaW50SW9uQ29udGVudEVycm9yTXNnKGVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5nZXN0dXJlID0gY3JlYXRlU3dpcGVUb0Nsb3NlR2VzdHVyZShlbCwgYW5pLCAoKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIFdoaWxlIHRoZSBnZXN0dXJlIGFuaW1hdGlvbiBpcyBmaW5pc2hpbmdcbiAgICAgICAqIGl0IGlzIHBvc3NpYmxlIGZvciBhIHVzZXIgdG8gdGFwIHRoZSBiYWNrZHJvcC5cbiAgICAgICAqIFRoaXMgd291bGQgcmVzdWx0IGluIHRoZSBkaXNtaXNzIGFuaW1hdGlvblxuICAgICAgICogYmVpbmcgcGxheWVkIGFnYWluLiBUeXBpY2FsbHkgdGhpcyBpcyBhdm9pZGVkXG4gICAgICAgKiBieSBzZXR0aW5nIGBwcmVzZW50ZWQgPSBmYWxzZWAgb24gdGhlIG92ZXJsYXlcbiAgICAgICAqIGNvbXBvbmVudDsgaG93ZXZlciwgd2UgY2Fubm90IGRvIHRoYXQgaGVyZSBhc1xuICAgICAgICogdGhhdCB3b3VsZCBwcmV2ZW50IHRoZSBlbGVtZW50IGZyb20gYmVpbmdcbiAgICAgICAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAgICovXG4gICAgICB0aGlzLmdlc3R1cmVBbmltYXRpb25EaXNtaXNzaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uLm9uRmluaXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5kaXNtaXNzKHVuZGVmaW5lZCwgJ2dlc3R1cmUnKTtcbiAgICAgICAgdGhpcy5nZXN0dXJlQW5pbWF0aW9uRGlzbWlzc2luZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5nZXN0dXJlLmVuYWJsZSh0cnVlKTtcbiAgfVxuICBpbml0U2hlZXRHZXN0dXJlKCkge1xuICAgIGNvbnN0IHsgd3JhcHBlckVsLCBpbml0aWFsQnJlYWtwb2ludCwgYmFja2Ryb3BCcmVha3BvaW50IH0gPSB0aGlzO1xuICAgIGlmICghd3JhcHBlckVsIHx8IGluaXRpYWxCcmVha3BvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uQnVpbGRlciA9IHRoaXMuZW50ZXJBbmltYXRpb24gfHwgY29uZmlnLmdldCgnbW9kYWxFbnRlcicsIGlvc0VudGVyQW5pbWF0aW9uKTtcbiAgICBjb25zdCBhbmkgPSAodGhpcy5hbmltYXRpb24gPSBhbmltYXRpb25CdWlsZGVyKHRoaXMuZWwsIHtcbiAgICAgIHByZXNlbnRpbmdFbDogdGhpcy5wcmVzZW50aW5nRWxlbWVudCxcbiAgICAgIGN1cnJlbnRCcmVha3BvaW50OiBpbml0aWFsQnJlYWtwb2ludCxcbiAgICAgIGJhY2tkcm9wQnJlYWtwb2ludCxcbiAgICB9KSk7XG4gICAgYW5pLnByb2dyZXNzU3RhcnQodHJ1ZSwgMSk7XG4gICAgY29uc3QgeyBnZXN0dXJlLCBtb3ZlU2hlZXRUb0JyZWFrcG9pbnQgfSA9IGNyZWF0ZVNoZWV0R2VzdHVyZSh0aGlzLmVsLCB0aGlzLmJhY2tkcm9wRWwsIHdyYXBwZXJFbCwgaW5pdGlhbEJyZWFrcG9pbnQsIGJhY2tkcm9wQnJlYWtwb2ludCwgYW5pLCB0aGlzLnNvcnRlZEJyZWFrcG9pbnRzLCAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuY3VycmVudEJyZWFrcG9pbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7IH0sICgpID0+IHRoaXMuc2hlZXRPbkRpc21pc3MoKSwgKGJyZWFrcG9pbnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCcmVha3BvaW50ICE9PSBicmVha3BvaW50KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xuICAgICAgICB0aGlzLmlvbkJyZWFrcG9pbnREaWRDaGFuZ2UuZW1pdCh7IGJyZWFrcG9pbnQgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5nZXN0dXJlID0gZ2VzdHVyZTtcbiAgICB0aGlzLm1vdmVTaGVldFRvQnJlYWtwb2ludCA9IG1vdmVTaGVldFRvQnJlYWtwb2ludDtcbiAgICB0aGlzLmdlc3R1cmUuZW5hYmxlKHRydWUpO1xuICB9XG4gIHNoZWV0T25EaXNtaXNzKCkge1xuICAgIC8qKlxuICAgICAqIFdoaWxlIHRoZSBnZXN0dXJlIGFuaW1hdGlvbiBpcyBmaW5pc2hpbmdcbiAgICAgKiBpdCBpcyBwb3NzaWJsZSBmb3IgYSB1c2VyIHRvIHRhcCB0aGUgYmFja2Ryb3AuXG4gICAgICogVGhpcyB3b3VsZCByZXN1bHQgaW4gdGhlIGRpc21pc3MgYW5pbWF0aW9uXG4gICAgICogYmVpbmcgcGxheWVkIGFnYWluLiBUeXBpY2FsbHkgdGhpcyBpcyBhdm9pZGVkXG4gICAgICogYnkgc2V0dGluZyBgcHJlc2VudGVkID0gZmFsc2VgIG9uIHRoZSBvdmVybGF5XG4gICAgICogY29tcG9uZW50OyBob3dldmVyLCB3ZSBjYW5ub3QgZG8gdGhhdCBoZXJlIGFzXG4gICAgICogdGhhdCB3b3VsZCBwcmV2ZW50IHRoZSBlbGVtZW50IGZyb20gYmVpbmdcbiAgICAgKiByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgKi9cbiAgICB0aGlzLmdlc3R1cmVBbmltYXRpb25EaXNtaXNzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmFuaW1hdGlvbi5vbkZpbmlzaChhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRCcmVha3BvaW50ID0gMDtcbiAgICAgIHRoaXMuaW9uQnJlYWtwb2ludERpZENoYW5nZS5lbWl0KHsgYnJlYWtwb2ludDogdGhpcy5jdXJyZW50QnJlYWtwb2ludCB9KTtcbiAgICAgIGF3YWl0IHRoaXMuZGlzbWlzcyh1bmRlZmluZWQsICdnZXN0dXJlJyk7XG4gICAgICB0aGlzLmdlc3R1cmVBbmltYXRpb25EaXNtaXNzaW5nID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc21pc3MgdGhlIG1vZGFsIG92ZXJsYXkgYWZ0ZXIgaXQgaGFzIGJlZW4gcHJlc2VudGVkLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSBBbnkgZGF0YSB0byBlbWl0IGluIHRoZSBkaXNtaXNzIGV2ZW50cy5cbiAgICogQHBhcmFtIHJvbGUgVGhlIHJvbGUgb2YgdGhlIGVsZW1lbnQgdGhhdCBpcyBkaXNtaXNzaW5nIHRoZSBtb2RhbC4gRm9yIGV4YW1wbGUsICdjYW5jZWwnIG9yICdiYWNrZHJvcCcuXG4gICAqL1xuICBhc3luYyBkaXNtaXNzKGRhdGEsIHJvbGUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuZ2VzdHVyZUFuaW1hdGlvbkRpc21pc3NpbmcgJiYgcm9sZSAhPT0gJ2dlc3R1cmUnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGEgY2FuRGlzbWlzcyBoYW5kbGVyIGlzIHJlc3BvbnNpYmxlXG4gICAgICogZm9yIGNhbGxpbmcgdGhlIGRpc21pc3MgbWV0aG9kLCB3ZSBzaG91bGRcbiAgICAgKiBub3QgcnVuIHRoZSBjYW5EaXNtaXNzIGNoZWNrIGFnYWluLlxuICAgICAqL1xuICAgIGlmIChyb2xlICE9PSAnaGFuZGxlcicgJiYgIShhd2FpdCB0aGlzLmNoZWNrQ2FuRGlzbWlzcygpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIHN0YXJ0IHRoZSBzdGF0dXMgYmFyIGNoYW5nZVxuICAgICAqIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHNvIHRoYXQgdGhlIGNoYW5nZVxuICAgICAqIGZpbmlzaGVzIHdoZW4gdGhlIGRpc21pc3MgYW5pbWF0aW9uIGRvZXMuXG4gICAgICogVE9ETyAoRlctOTM3KVxuICAgICAqL1xuICAgIGNvbnN0IGhhc0NhcmRNb2RhbCA9IHRoaXMuc3dpcGVUb0Nsb3NlIHx8ICh0aGlzLmNhbkRpc21pc3MgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnByZXNlbnRpbmdFbGVtZW50ICE9PSB1bmRlZmluZWQpO1xuICAgIGlmIChoYXNDYXJkTW9kYWwgJiYgZ2V0SW9uTW9kZSh0aGlzKSA9PT0gJ2lvcycpIHtcbiAgICAgIHNldENhcmRTdGF0dXNCYXJEZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSAqL1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmtleWJvYXJkT3BlbkNhbGxiYWNrKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihLRVlCT0FSRF9ESURfT1BFTiwgdGhpcy5rZXlib2FyZE9wZW5DYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgYW4gaW5saW5lIG1vZGFsXG4gICAgICogYW5kIHByZXNlbnRpbmcgYSBtb2RhbCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgICAqIHF1aWNrbHkgZGlzbWlzcyB0aGUgbW9kYWwgd2hpbGUgaXQgaXNcbiAgICAgKiBwcmVzZW50aW5nLiBXZSBuZWVkIHRvIGF3YWl0IGFueSBjdXJyZW50XG4gICAgICogdHJhbnNpdGlvbiB0byBhbGxvdyB0aGUgcHJlc2VudCB0byBmaW5pc2hcbiAgICAgKiBiZWZvcmUgZGlzbWlzc2luZyBhZ2Fpbi5cbiAgICAgKi9cbiAgICBpZiAodGhpcy5jdXJyZW50VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmN1cnJlbnRUcmFuc2l0aW9uO1xuICAgIH1cbiAgICBjb25zdCBlbnRlcmluZ0FuaW1hdGlvbiA9IGFjdGl2ZUFuaW1hdGlvbnMuZ2V0KHRoaXMpIHx8IFtdO1xuICAgIHRoaXMuY3VycmVudFRyYW5zaXRpb24gPSBkaXNtaXNzKHRoaXMsIGRhdGEsIHJvbGUsICdtb2RhbExlYXZlJywgaW9zTGVhdmVBbmltYXRpb24sIG1kTGVhdmVBbmltYXRpb24sIHtcbiAgICAgIHByZXNlbnRpbmdFbDogdGhpcy5wcmVzZW50aW5nRWxlbWVudCxcbiAgICAgIGN1cnJlbnRCcmVha3BvaW50OiAoX2EgPSB0aGlzLmN1cnJlbnRCcmVha3BvaW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmluaXRpYWxCcmVha3BvaW50LFxuICAgICAgYmFja2Ryb3BCcmVha3BvaW50OiB0aGlzLmJhY2tkcm9wQnJlYWtwb2ludCxcbiAgICB9KTtcbiAgICBjb25zdCBkaXNtaXNzZWQgPSBhd2FpdCB0aGlzLmN1cnJlbnRUcmFuc2l0aW9uO1xuICAgIGlmIChkaXNtaXNzZWQpIHtcbiAgICAgIGNvbnN0IHsgZGVsZWdhdGUgfSA9IHRoaXMuZ2V0RGVsZWdhdGUoKTtcbiAgICAgIGF3YWl0IGRldGFjaENvbXBvbmVudChkZWxlZ2F0ZSwgdGhpcy51c2Vyc0VsZW1lbnQpO1xuICAgICAgd3JpdGVUYXNrKCgpID0+IHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdy1tb2RhbCcpKTtcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5nZXN0dXJlKSB7XG4gICAgICAgIHRoaXMuZ2VzdHVyZS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBlbnRlcmluZ0FuaW1hdGlvbi5mb3JFYWNoKChhbmkpID0+IGFuaS5kZXN0cm95KCkpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRCcmVha3BvaW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY3VycmVudFRyYW5zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRpc21pc3NlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtb2RhbCBkaWQgZGlzbWlzcy5cbiAgICovXG4gIG9uRGlkRGlzbWlzcygpIHtcbiAgICByZXR1cm4gZXZlbnRNZXRob2QodGhpcy5lbCwgJ2lvbk1vZGFsRGlkRGlzbWlzcycpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG1vZGFsIHdpbGwgZGlzbWlzcy5cbiAgICovXG4gIG9uV2lsbERpc21pc3MoKSB7XG4gICAgcmV0dXJuIGV2ZW50TWV0aG9kKHRoaXMuZWwsICdpb25Nb2RhbFdpbGxEaXNtaXNzJyk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgYSBzaGVldCBzdHlsZSBtb2RhbCB0byBhIHNwZWNpZmljIGJyZWFrcG9pbnQuIFRoZSBicmVha3BvaW50IHZhbHVlIG11c3RcbiAgICogYmUgYSB2YWx1ZSBkZWZpbmVkIGluIHlvdXIgYGJyZWFrcG9pbnRzYCBhcnJheS5cbiAgICovXG4gIGFzeW5jIHNldEN1cnJlbnRCcmVha3BvaW50KGJyZWFrcG9pbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTaGVldE1vZGFsKSB7XG4gICAgICBwcmludElvbldhcm5pbmcoJ3NldEN1cnJlbnRCcmVha3BvaW50IGlzIG9ubHkgc3VwcG9ydGVkIG9uIHNoZWV0IG1vZGFscy4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmJyZWFrcG9pbnRzLmluY2x1ZGVzKGJyZWFrcG9pbnQpKSB7XG4gICAgICBwcmludElvbldhcm5pbmcoYEF0dGVtcHRlZCB0byBzZXQgaW52YWxpZCBicmVha3BvaW50IHZhbHVlICR7YnJlYWtwb2ludH0uIFBsZWFzZSBkb3VibGUgY2hlY2sgdGhhdCB0aGUgYnJlYWtwb2ludCB2YWx1ZSBpcyBwYXJ0IG9mIHlvdXIgZGVmaW5lZCBicmVha3BvaW50cy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50QnJlYWtwb2ludCwgbW92ZVNoZWV0VG9CcmVha3BvaW50LCBjYW5EaXNtaXNzLCBicmVha3BvaW50cyB9ID0gdGhpcztcbiAgICBpZiAoY3VycmVudEJyZWFrcG9pbnQgPT09IGJyZWFrcG9pbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1vdmVTaGVldFRvQnJlYWtwb2ludCkge1xuICAgICAgdGhpcy5zaGVldFRyYW5zaXRpb24gPSBtb3ZlU2hlZXRUb0JyZWFrcG9pbnQoe1xuICAgICAgICBicmVha3BvaW50LFxuICAgICAgICBicmVha3BvaW50T2Zmc2V0OiAxIC0gY3VycmVudEJyZWFrcG9pbnQsXG4gICAgICAgIGNhbkRpc21pc3M6IGNhbkRpc21pc3MgIT09IHVuZGVmaW5lZCAmJiBjYW5EaXNtaXNzICE9PSB0cnVlICYmIGJyZWFrcG9pbnRzWzBdID09PSAwLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLnNoZWV0VHJhbnNpdGlvbjtcbiAgICAgIHRoaXMuc2hlZXRUcmFuc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBicmVha3BvaW50IG9mIGEgc2hlZXQgc3R5bGUgbW9kYWxcbiAgICovXG4gIGFzeW5jIGdldEN1cnJlbnRCcmVha3BvaW50KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRCcmVha3BvaW50O1xuICB9XG4gIGFzeW5jIG1vdmVUb05leHRCcmVha3BvaW50KCkge1xuICAgIGNvbnN0IHsgYnJlYWtwb2ludHMsIGN1cnJlbnRCcmVha3BvaW50IH0gPSB0aGlzO1xuICAgIGlmICghYnJlYWtwb2ludHMgfHwgY3VycmVudEJyZWFrcG9pbnQgPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgbW9kYWwgZG9lcyBub3QgaGF2ZSBicmVha3BvaW50cyBhbmQvb3IgdGhlIGN1cnJlbnRcbiAgICAgICAqIGJyZWFrcG9pbnQgaXMgbm90IHNldCwgd2UgY2FuJ3QgbW92ZSB0byB0aGUgbmV4dCBicmVha3BvaW50LlxuICAgICAgICovXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFsbG93ZWRCcmVha3BvaW50cyA9IGJyZWFrcG9pbnRzLmZpbHRlcigoYikgPT4gYiAhPT0gMCk7XG4gICAgY29uc3QgY3VycmVudEJyZWFrcG9pbnRJbmRleCA9IGFsbG93ZWRCcmVha3BvaW50cy5pbmRleE9mKGN1cnJlbnRCcmVha3BvaW50KTtcbiAgICBjb25zdCBuZXh0QnJlYWtwb2ludEluZGV4ID0gKGN1cnJlbnRCcmVha3BvaW50SW5kZXggKyAxKSAlIGFsbG93ZWRCcmVha3BvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgbmV4dEJyZWFrcG9pbnQgPSBhbGxvd2VkQnJlYWtwb2ludHNbbmV4dEJyZWFrcG9pbnRJbmRleF07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBicmVha3BvaW50IHRvIHRoZSBuZXh0IGF2YWlsYWJsZSBicmVha3BvaW50LlxuICAgICAqIElmIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgaXMgdGhlIGxhc3QgYnJlYWtwb2ludCwgd2Ugc2V0IHRoZSBjdXJyZW50XG4gICAgICogYnJlYWtwb2ludCB0byB0aGUgZmlyc3Qgbm9uLXplcm8gYnJlYWtwb2ludCB0byBhdm9pZCBkaXNtaXNzaW5nIHRoZSBzaGVldC5cbiAgICAgKi9cbiAgICBhd2FpdCB0aGlzLnNldEN1cnJlbnRCcmVha3BvaW50KG5leHRCcmVha3BvaW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBoYW5kbGUsIGlzU2hlZXRNb2RhbCwgcHJlc2VudGluZ0VsZW1lbnQsIGh0bWxBdHRyaWJ1dGVzLCBoYW5kbGVCZWhhdmlvciwgaW5oZXJpdGVkQXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICBjb25zdCBzaG93SGFuZGxlID0gaGFuZGxlICE9PSBmYWxzZSAmJiBpc1NoZWV0TW9kYWw7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgY29uc3QgeyBtb2RhbElkIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlzQ2FyZE1vZGFsID0gcHJlc2VudGluZ0VsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiBtb2RlID09PSAnaW9zJztcbiAgICBjb25zdCBpc0hhbmRsZUN5Y2xlID0gaGFuZGxlQmVoYXZpb3IgPT09ICdjeWNsZSc7XG4gICAgcmV0dXJuIChoKEhvc3QsIE9iamVjdC5hc3NpZ24oeyBcIm5vLXJvdXRlclwiOiB0cnVlLCBcImFyaWEtbW9kYWxcIjogXCJ0cnVlXCIsIHJvbGU6IFwiZGlhbG9nXCIsIHRhYmluZGV4OiBcIi0xXCIgfSwgaHRtbEF0dHJpYnV0ZXMsIGluaGVyaXRlZEF0dHJpYnV0ZXMsIHsgc3R5bGU6IHtcbiAgICAgICAgekluZGV4OiBgJHsyMDAwMCArIHRoaXMub3ZlcmxheUluZGV4fWAsXG4gICAgICB9LCBjbGFzczogT2JqZWN0LmFzc2lnbih7IFttb2RlXTogdHJ1ZSwgWydtb2RhbC1kZWZhdWx0J106ICFpc0NhcmRNb2RhbCAmJiAhaXNTaGVldE1vZGFsLCBbYG1vZGFsLWNhcmRgXTogaXNDYXJkTW9kYWwsIFtgbW9kYWwtc2hlZXRgXTogaXNTaGVldE1vZGFsLCAnb3ZlcmxheS1oaWRkZW4nOiB0cnVlIH0sIGdldENsYXNzTWFwKHRoaXMuY3NzQ2xhc3MpKSwgaWQ6IG1vZGFsSWQsIG9uSW9uQmFja2Ryb3BUYXA6IHRoaXMub25CYWNrZHJvcFRhcCwgb25Jb25Nb2RhbERpZFByZXNlbnQ6IHRoaXMub25MaWZlY3ljbGUsIG9uSW9uTW9kYWxXaWxsUHJlc2VudDogdGhpcy5vbkxpZmVjeWNsZSwgb25Jb25Nb2RhbFdpbGxEaXNtaXNzOiB0aGlzLm9uTGlmZWN5Y2xlLCBvbklvbk1vZGFsRGlkRGlzbWlzczogdGhpcy5vbkxpZmVjeWNsZSB9KSwgaChcImlvbi1iYWNrZHJvcFwiLCB7IHJlZjogKGVsKSA9PiAodGhpcy5iYWNrZHJvcEVsID0gZWwpLCB2aXNpYmxlOiB0aGlzLnNob3dCYWNrZHJvcCwgdGFwcGFibGU6IHRoaXMuYmFja2Ryb3BEaXNtaXNzLCBwYXJ0OiBcImJhY2tkcm9wXCIgfSksIG1vZGUgPT09ICdpb3MnICYmIGgoXCJkaXZcIiwgeyBjbGFzczogXCJtb2RhbC1zaGFkb3dcIiB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiBcIm1vZGFsLXdyYXBwZXIgaW9uLW92ZXJsYXktd3JhcHBlclwiLCBwYXJ0OiBcImNvbnRlbnRcIiwgcmVmOiAoZWwpID0+ICh0aGlzLndyYXBwZXJFbCA9IGVsKSB9LCBzaG93SGFuZGxlICYmIChoKFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwibW9kYWwtaGFuZGxlXCIsXG4gICAgICAvLyBQcmV2ZW50cyB0aGUgaGFuZGxlIGZyb20gcmVjZWl2aW5nIGtleWJvYXJkIGZvY3VzIHdoZW4gaXQgZG9lcyBub3QgY3ljbGVcbiAgICAgIHRhYkluZGV4OiAhaXNIYW5kbGVDeWNsZSA/IC0xIDogMCwgXCJhcmlhLWxhYmVsXCI6IFwiQWN0aXZhdGUgdG8gYWRqdXN0IHRoZSBzaXplIG9mIHRoZSBkaWFsb2cgb3ZlcmxheWluZyB0aGUgc2NyZWVuXCIsIG9uQ2xpY2s6IGlzSGFuZGxlQ3ljbGUgPyB0aGlzLm9uSGFuZGxlQ2xpY2sgOiB1bmRlZmluZWQsIHBhcnQ6IFwiaGFuZGxlXCIgfSkpLCBoKFwic2xvdFwiLCBudWxsKSkpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJpc09wZW5cIjogW1wib25Jc09wZW5DaGFuZ2VcIl0sXG4gICAgXCJ0cmlnZ2VyXCI6IFtcIm9uVHJpZ2dlckNoYW5nZVwiXSxcbiAgICBcInN3aXBlVG9DbG9zZVwiOiBbXCJzd2lwZVRvQ2xvc2VDaGFuZ2VkXCJdXG4gIH07IH1cbn07XG5jb25zdCBMSUZFQ1lDTEVfTUFQID0ge1xuICBpb25Nb2RhbERpZFByZXNlbnQ6ICdpb25WaWV3RGlkRW50ZXInLFxuICBpb25Nb2RhbFdpbGxQcmVzZW50OiAnaW9uVmlld1dpbGxFbnRlcicsXG4gIGlvbk1vZGFsV2lsbERpc21pc3M6ICdpb25WaWV3V2lsbExlYXZlJyxcbiAgaW9uTW9kYWxEaWREaXNtaXNzOiAnaW9uVmlld0RpZExlYXZlJyxcbn07XG5sZXQgbW9kYWxJZHMgPSAwO1xuTW9kYWwuc3R5bGUgPSB7XG4gIGlvczogbW9kYWxJb3NDc3MsXG4gIG1kOiBtb2RhbE1kQ3NzXG59O1xuXG5leHBvcnQgeyBNb2RhbCBhcyBpb25fbW9kYWwgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5jb25zdCBob3N0Q29udGV4dCA9IChzZWxlY3RvciwgZWwpID0+IHtcbiAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpICE9PSBudWxsO1xufTtcbi8qKlxuICogQ3JlYXRlIHRoZSBtb2RlIGFuZCBjb2xvciBjbGFzc2VzIGZvciB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBjbGFzc2VzIHBhc3NlZCBpblxuICovXG5jb25zdCBjcmVhdGVDb2xvckNsYXNzZXMgPSAoY29sb3IsIGNzc0NsYXNzTWFwKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnICYmIGNvbG9yLmxlbmd0aCA+IDBcbiAgICA/IE9iamVjdC5hc3NpZ24oeyAnaW9uLWNvbG9yJzogdHJ1ZSwgW2Bpb24tY29sb3ItJHtjb2xvcn1gXTogdHJ1ZSB9LCBjc3NDbGFzc01hcCkgOiBjc3NDbGFzc01hcDtcbn07XG5jb25zdCBnZXRDbGFzc0xpc3QgPSAoY2xhc3NlcykgPT4ge1xuICBpZiAoY2xhc3NlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5pc0FycmF5KGNsYXNzZXMpID8gY2xhc3NlcyA6IGNsYXNzZXMuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4gYXJyYXlcbiAgICAgIC5maWx0ZXIoKGMpID0+IGMgIT0gbnVsbClcbiAgICAgIC5tYXAoKGMpID0+IGMudHJpbSgpKVxuICAgICAgLmZpbHRlcigoYykgPT4gYyAhPT0gJycpO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5jb25zdCBnZXRDbGFzc01hcCA9IChjbGFzc2VzKSA9PiB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBnZXRDbGFzc0xpc3QoY2xhc3NlcykuZm9yRWFjaCgoYykgPT4gKG1hcFtjXSA9IHRydWUpKTtcbiAgcmV0dXJuIG1hcDtcbn07XG5jb25zdCBTQ0hFTUUgPSAvXlthLXpdW2EtejAtOStcXC0uXSo6LztcbmNvbnN0IG9wZW5VUkwgPSBhc3luYyAodXJsLCBldiwgZGlyZWN0aW9uLCBhbmltYXRpb24pID0+IHtcbiAgaWYgKHVybCAhPSBudWxsICYmIHVybFswXSAhPT0gJyMnICYmICFTQ0hFTUUudGVzdCh1cmwpKSB7XG4gICAgY29uc3Qgcm91dGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW9uLXJvdXRlcicpO1xuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIGlmIChldiAhPSBudWxsKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVyLnB1c2godXJsLCBkaXJlY3Rpb24sIGFuaW1hdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUNvbG9yQ2xhc3NlcyBhcyBjLCBnZXRDbGFzc01hcCBhcyBnLCBob3N0Q29udGV4dCBhcyBoLCBvcGVuVVJMIGFzIG8gfTtcbiJdLCJuYW1lcyI6WyJwcmludElvbldhcm5pbmciLCJtZXNzYWdlIiwicGFyYW1zIiwiY29uc29sZSIsIndhcm4iLCJwcmludElvbkVycm9yIiwiZXJyb3IiLCJwcmludFJlcXVpcmVkRWxlbWVudEVycm9yIiwiZWwiLCJ0YXJnZXRTZWxlY3RvcnMiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJqb2luIiwiYSIsImIiLCJwIiwiciIsInJlZ2lzdGVySW5zdGFuY2UiLCJlIiwiY3JlYXRlRXZlbnQiLCJjIiwid3JpdGVUYXNrIiwiaCIsIkgiLCJIb3N0IiwiaSIsImdldEVsZW1lbnQiLCJnZXRJb25Nb2RlIiwiY29uZmlnIiwiZiIsImZpbmRDbG9zZXN0SW9uQ29udGVudCIsImlzSW9uQ29udGVudCIsImQiLCJkaXNhYmxlQ29udGVudFNjcm9sbFkiLCJyZXNldENvbnRlbnRTY3JvbGxZIiwiZmluZElvbkNvbnRlbnQiLCJwcmludElvbkNvbnRlbnRFcnJvck1zZyIsIkMiLCJDb3JlRGVsZWdhdGUiLCJhdHRhY2hDb21wb25lbnQiLCJkZXRhY2hDb21wb25lbnQiLCJnIiwiZ2V0RWxlbWVudFJvb3QiLCJsIiwiY2xhbXAiLCJyYWYiLCJqIiwiaW5oZXJpdEF0dHJpYnV0ZXMiLCJLRVlCT0FSRF9ESURfT1BFTiIsIkIiLCJCQUNLRFJPUCIsInByZXBhcmVPdmVybGF5IiwicHJlc2VudCIsImFjdGl2ZUFuaW1hdGlvbnMiLCJkaXNtaXNzIiwiZXZlbnRNZXRob2QiLCJnZXRDbGFzc01hcCIsImRlZXBSZWFkeSIsImNyZWF0ZUFuaW1hdGlvbiIsImdldFRpbWVHaXZlblByb2dyZXNzaW9uIiwiY3JlYXRlR2VzdHVyZSIsInciLCJ3aW4iLCJTdHlsZSIsIlN0YXR1c0JhciIsImdldEVuZ2luZSIsIl9hIiwiQ2FwYWNpdG9yIiwiaXNQbHVnaW5BdmFpbGFibGUiLCJQbHVnaW5zIiwic3VwcG9ydHNEZWZhdWx0U3RhdHVzQmFyU3R5bGUiLCJQbHVnaW5IZWFkZXJzIiwic2V0U3R5bGUiLCJvcHRpb25zIiwiZW5naW5lIiwiZ2V0QmFja2Ryb3BWYWx1ZUZvclNoZWV0IiwieCIsImJhY2tkcm9wQnJlYWtwb2ludCIsInNsb3BlIiwic2V0Q2FyZFN0YXR1c0JhckRhcmsiLCJpbm5lcldpZHRoIiwic3R5bGUiLCJEYXJrIiwic2V0Q2FyZFN0YXR1c0JhckRlZmF1bHQiLCJEZWZhdWx0IiwiaGFuZGxlQ2FuRGlzbWlzcyIsImFuaW1hdGlvbiIsImNhbkRpc21pc3MiLCJzaG91bGREaXNtaXNzIiwiaXNSdW5uaW5nIiwib25GaW5pc2giLCJ1bmRlZmluZWQiLCJvbmVUaW1lQ2FsbGJhY2siLCJjYWxjdWxhdGVTcHJpbmdTdGVwIiwidCIsIlN3aXBlVG9DbG9zZURlZmF1bHRzIiwiTUlOX1BSRVNFTlRJTkdfU0NBTEUiLCJjcmVhdGVTd2lwZVRvQ2xvc2VHZXN0dXJlIiwib25EaXNtaXNzIiwiRElTTUlTU19USFJFU0hPTEQiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJpc09wZW4iLCJjYW5EaXNtaXNzQmxvY2tzR2VzdHVyZSIsImNvbnRlbnRFbCIsInNjcm9sbEVsIiwiY2FuRGlzbWlzc01heFN0ZXAiLCJpbml0aWFsU2Nyb2xsWSIsImxhc3RTdGVwIiwiZ2V0U2Nyb2xsWSIsInNjcm9sbFkiLCJjYW5TdGFydCIsImRldGFpbCIsInRhcmdldCIsImV2ZW50IiwiY2xvc2VzdCIsInJvb3QiLCJxdWVyeVNlbGVjdG9yIiwiaGFzUmVmcmVzaGVySW5Db250ZW50Iiwic2Nyb2xsVG9wIiwiZm9vdGVyIiwib25TdGFydCIsImRlbHRhWSIsInByb2dyZXNzU3RhcnQiLCJvbk1vdmUiLCJzdGVwIiwiaXNBdHRlbXBpbmdEaXNtaXNzV2l0aENhbkRpc21pc3MiLCJtYXhTdGVwIiwicHJvY2Vzc2VkU3RlcCIsImNsYW1wZWRTdGVwIiwicHJvZ3Jlc3NTdGVwIiwib25FbmQiLCJ2ZWxvY2l0eSIsInZlbG9jaXR5WSIsInRocmVzaG9sZCIsInNob3VsZENvbXBsZXRlIiwibmV3U3RlcFZhbHVlIiwiZWFzaW5nIiwiZHVyYXRpb24iLCJjb21wdXRlRHVyYXRpb24iLCJnZXN0dXJlIiwiZW5hYmxlIiwicHJvZ3Jlc3NFbmQiLCJnZXN0dXJlTmFtZSIsImdlc3R1cmVQcmlvcml0eSIsImRpcmVjdGlvbiIsInJlbWFpbmluZyIsIk1hdGgiLCJhYnMiLCJjcmVhdGVTaGVldEVudGVyQW5pbWF0aW9uIiwib3B0cyIsImN1cnJlbnRCcmVha3BvaW50Iiwic2hvdWxkU2hvd0JhY2tkcm9wIiwiaW5pdGlhbEJhY2tkcm9wIiwiYmFja2Ryb3BBbmltYXRpb24iLCJmcm9tVG8iLCJiZWZvcmVTdHlsZXMiLCJhZnRlckNsZWFyU3R5bGVzIiwid3JhcHBlckFuaW1hdGlvbiIsImtleWZyYW1lcyIsIm9mZnNldCIsIm9wYWNpdHkiLCJ0cmFuc2Zvcm0iLCJjcmVhdGVTaGVldExlYXZlQW5pbWF0aW9uIiwiYmFja2Ryb3BWYWx1ZSIsImRlZmF1bHRCYWNrZHJvcCIsImN1c3RvbUJhY2tkcm9wIiwiY3JlYXRlRW50ZXJBbmltYXRpb24kMSIsImlvc0VudGVyQW5pbWF0aW9uIiwiYmFzZUVsIiwicHJlc2VudGluZ0VsIiwiYWRkRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJiYXNlQW5pbWF0aW9uIiwiYWRkQW5pbWF0aW9uIiwiaXNNb2JpbGUiLCJ3aW5kb3ciLCJoYXNDYXJkTW9kYWwiLCJwcmVzZW50aW5nRWxlbWVudCIsInByZXNlbnRpbmdFbFJvb3QiLCJwcmVzZW50aW5nQW5pbWF0aW9uIiwib3ZlcmZsb3ciLCJib2R5RWwiLCJkb2N1bWVudCIsImJvZHkiLCJ0cmFuc2Zvcm1PZmZzZXQiLCJDU1MiLCJzdXBwb3J0cyIsIm1vZGFsVHJhbnNmb3JtIiwidG9QcmVzZW50aW5nU2NhbGUiLCJmaW5hbFRyYW5zZm9ybSIsImFmdGVyU3R5bGVzIiwiYmVmb3JlQWRkV3JpdGUiLCJzZXRQcm9wZXJ0eSIsImZpbHRlciIsImJvcmRlclJhZGl1cyIsInNoYWRvd0FuaW1hdGlvbiIsImNyZWF0ZUxlYXZlQW5pbWF0aW9uJDEiLCJpb3NMZWF2ZUFuaW1hdGlvbiIsImJlZm9yZUNsZWFyU3R5bGVzIiwiY3VycmVudFN0ZXAiLCJudW1Nb2RhbHMiLCJBcnJheSIsImZyb20iLCJtIiwibGVuZ3RoIiwiY3JlYXRlRW50ZXJBbmltYXRpb24iLCJtZEVudGVyQW5pbWF0aW9uIiwiY3JlYXRlTGVhdmVBbmltYXRpb24iLCJtZExlYXZlQW5pbWF0aW9uIiwiY3JlYXRlU2hlZXRHZXN0dXJlIiwiYmFja2Ryb3BFbCIsIndyYXBwZXJFbCIsImluaXRpYWxCcmVha3BvaW50IiwiYnJlYWtwb2ludHMiLCJnZXRDdXJyZW50QnJlYWtwb2ludCIsIm9uQnJlYWtwb2ludENoYW5nZSIsIlNoZWV0RGVmYXVsdHMiLCJXUkFQUEVSX0tFWUZSQU1FUyIsIkJBQ0tEUk9QX0tFWUZSQU1FUyIsImNsaWVudEhlaWdodCIsImNoaWxkQW5pbWF0aW9ucyIsImZpbmQiLCJhbmkiLCJpZCIsIm1heEJyZWFrcG9pbnQiLCJtaW5CcmVha3BvaW50IiwiZW5hYmxlQmFja2Ryb3AiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJkaXNhYmxlQmFja2Ryb3AiLCJhZGQiLCJzaG91bGRFbmFibGVCYWNrZHJvcCIsImNvbnRlbnQiLCJmb2N1cyIsImluaXRpYWxTdGVwIiwic2Vjb25kVG9MYXN0QnJlYWtwb2ludCIsImlzQXR0ZW1wdGluZ0Rpc21pc3NXaXRoQ2FuRGlzbWlzcyIsImRpZmYiLCJyZWR1Y2UiLCJtb3ZlU2hlZXRUb0JyZWFrcG9pbnQiLCJicmVha3BvaW50IiwiYnJlYWtwb2ludE9mZnNldCIsInNob3VsZFByZXZlbnREaXNtaXNzIiwic25hcFRvQnJlYWtwb2ludCIsInNob3VsZFJlbWFpbk9wZW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1vZGFsSW9zQ3NzIiwibW9kYWxNZENzcyIsIk1vZGFsIiwiY29uc3RydWN0b3IiLCJob3N0UmVmIiwiZGlkUHJlc2VudCIsIndpbGxQcmVzZW50Iiwid2lsbERpc21pc3MiLCJkaWREaXNtaXNzIiwiaW9uQnJlYWtwb2ludERpZENoYW5nZSIsImRpZFByZXNlbnRTaG9ydGhhbmQiLCJ3aWxsUHJlc2VudFNob3J0aGFuZCIsIndpbGxEaXNtaXNzU2hvcnRoYW5kIiwiZGlkRGlzbWlzc1Nob3J0aGFuZCIsIm1vZGFsSW5kZXgiLCJtb2RhbElkcyIsImNvcmVEZWxlZ2F0ZSIsImlzU2hlZXRNb2RhbCIsImluaGVyaXRlZEF0dHJpYnV0ZXMiLCJpbmxpbmUiLCJnZXN0dXJlQW5pbWF0aW9uRGlzbWlzc2luZyIsInByZXNlbnRlZCIsImhhc0NvbnRyb2xsZXIiLCJrZXlib2FyZENsb3NlIiwiaGFuZGxlQmVoYXZpb3IiLCJiYWNrZHJvcERpc21pc3MiLCJzaG93QmFja2Ryb3AiLCJhbmltYXRlZCIsInN3aXBlVG9DbG9zZSIsImtlZXBDb250ZW50c01vdW50ZWQiLCJjb25maWd1cmVUcmlnZ2VySW50ZXJhY3Rpb24iLCJ0cmlnZ2VyIiwiZGVzdHJveVRyaWdnZXJJbnRlcmFjdGlvbiIsInRyaWdnZXJFbCIsImdldEVsZW1lbnRCeUlkIiwidHJpZ0VsIiwibW9kYWxFbCIsIm9wZW5Nb2RhbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25IYW5kbGVDbGljayIsInNoZWV0VHJhbnNpdGlvbiIsIm1vdmVUb05leHRCcmVha3BvaW50Iiwib25CYWNrZHJvcFRhcCIsIm9uTGlmZWN5Y2xlIiwibW9kYWxFdmVudCIsInVzZXJzRWxlbWVudCIsIm5hbWUiLCJMSUZFQ1lDTEVfTUFQIiwidHlwZSIsImV2IiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJvbklzT3BlbkNoYW5nZSIsIm5ld1ZhbHVlIiwib2xkVmFsdWUiLCJvblRyaWdnZXJDaGFuZ2UiLCJzd2lwZVRvQ2xvc2VDaGFuZ2VkIiwiaW5pdFN3aXBlVG9DbG9zZSIsImJyZWFrcG9pbnRzQ2hhbmdlZCIsInNvcnRlZEJyZWFrcG9pbnRzIiwic29ydCIsImNvbm5lY3RlZENhbGxiYWNrIiwiY29tcG9uZW50V2lsbExvYWQiLCJtb2RhbElkIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiaW5jbHVkZXMiLCJjb21wb25lbnREaWRMb2FkIiwiZ2V0RGVsZWdhdGUiLCJmb3JjZSIsIndvcmtpbmdEZWxlZ2F0ZSIsImRlbGVnYXRlIiwicGFyZW50RWwiLCJwYXJlbnROb2RlIiwiY2hlY2tDYW5EaXNtaXNzIiwiY3VycmVudFRyYW5zaXRpb24iLCJkYXRhIiwiT2JqZWN0IiwiYXNzaWduIiwiY29tcG9uZW50UHJvcHMiLCJtb2RhbCIsImNvbXBvbmVudCIsImluaXRTaGVldEdlc3R1cmUiLCJrZXlib2FyZE9wZW5DYWxsYmFjayIsImFuaW1hdGlvbkJ1aWxkZXIiLCJsZWF2ZUFuaW1hdGlvbiIsImdldCIsImVudGVyQW5pbWF0aW9uIiwic2hlZXRPbkRpc21pc3MiLCJlbWl0Iiwicm9sZSIsImVudGVyaW5nQW5pbWF0aW9uIiwiZGlzbWlzc2VkIiwiZGVzdHJveSIsImZvckVhY2giLCJvbkRpZERpc21pc3MiLCJvbldpbGxEaXNtaXNzIiwic2V0Q3VycmVudEJyZWFrcG9pbnQiLCJhbGxvd2VkQnJlYWtwb2ludHMiLCJjdXJyZW50QnJlYWtwb2ludEluZGV4IiwiaW5kZXhPZiIsIm5leHRCcmVha3BvaW50SW5kZXgiLCJuZXh0QnJlYWtwb2ludCIsInJlbmRlciIsImhhbmRsZSIsImh0bWxBdHRyaWJ1dGVzIiwic2hvd0hhbmRsZSIsIm1vZGUiLCJpc0NhcmRNb2RhbCIsImlzSGFuZGxlQ3ljbGUiLCJ0YWJpbmRleCIsInpJbmRleCIsIm92ZXJsYXlJbmRleCIsImNsYXNzIiwiY3NzQ2xhc3MiLCJvbklvbkJhY2tkcm9wVGFwIiwib25Jb25Nb2RhbERpZFByZXNlbnQiLCJvbklvbk1vZGFsV2lsbFByZXNlbnQiLCJvbklvbk1vZGFsV2lsbERpc21pc3MiLCJvbklvbk1vZGFsRGlkRGlzbWlzcyIsInJlZiIsInZpc2libGUiLCJ0YXBwYWJsZSIsInBhcnQiLCJ0YWJJbmRleCIsIm9uQ2xpY2siLCJ3YXRjaGVycyIsImlvbk1vZGFsRGlkUHJlc2VudCIsImlvbk1vZGFsV2lsbFByZXNlbnQiLCJpb25Nb2RhbFdpbGxEaXNtaXNzIiwiaW9uTW9kYWxEaWREaXNtaXNzIiwiaW9zIiwibWQiLCJpb25fbW9kYWwiLCJob3N0Q29udGV4dCIsInNlbGVjdG9yIiwiY3JlYXRlQ29sb3JDbGFzc2VzIiwiY29sb3IiLCJjc3NDbGFzc01hcCIsImdldENsYXNzTGlzdCIsImNsYXNzZXMiLCJhcnJheSIsImlzQXJyYXkiLCJzcGxpdCIsIm1hcCIsInRyaW0iLCJTQ0hFTUUiLCJvcGVuVVJMIiwidXJsIiwidGVzdCIsInJvdXRlciIsInByZXZlbnREZWZhdWx0IiwicHVzaCIsIm8iXSwic291cmNlUm9vdCI6IndlYnBhY2s6Ly8vIiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMSwyXX0=