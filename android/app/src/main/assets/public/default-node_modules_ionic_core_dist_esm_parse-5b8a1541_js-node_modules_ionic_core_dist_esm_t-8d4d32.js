"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_ionic_core_dist_esm_parse-5b8a1541_js-node_modules_ionic_core_dist_esm_t-8d4d32"],{

/***/ 9273:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/index-c4b11676.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": () => (/* binding */ printRequiredElementError),
/* harmony export */   "b": () => (/* binding */ printIonError),
/* harmony export */   "p": () => (/* binding */ printIonWarning)
/* harmony export */ });
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */

/**
 * Logs a warning to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 */
const printIonWarning = (message, ...params) => {
  return console.warn(`[Ionic Warning]: ${message}`, ...params);
};
/*
 * Logs an error to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 * @param params - Additional arguments to supply to the console.error.
 */


const printIonError = (message, ...params) => {
  return console.error(`[Ionic Error]: ${message}`, ...params);
};
/**
 * Prints an error informing developers that an implementation requires an element to be used
 * within a specific selector.
 *
 * @param el The web component element this is requiring the element.
 * @param targetSelectors The selector or selectors that were not found.
 */


const printRequiredElementError = (el, ...targetSelectors) => {
  return console.error(`<${el.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(' or ')}.`);
};



/***/ }),

/***/ 5479:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/parse-5b8a1541.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": () => (/* binding */ getYearColumnData),
/* harmony export */   "B": () => (/* binding */ isMonthFirstLocale),
/* harmony export */   "C": () => (/* binding */ getTimeColumnsData),
/* harmony export */   "D": () => (/* binding */ isLocaleDayPeriodRTL),
/* harmony export */   "E": () => (/* binding */ getDaysOfWeek),
/* harmony export */   "F": () => (/* binding */ getMonthAndYear),
/* harmony export */   "G": () => (/* binding */ getDaysOfMonth),
/* harmony export */   "H": () => (/* binding */ generateMonths),
/* harmony export */   "I": () => (/* binding */ is24Hour),
/* harmony export */   "J": () => (/* binding */ getLocalizedTime),
/* harmony export */   "K": () => (/* binding */ getMonthAndDay),
/* harmony export */   "L": () => (/* binding */ formatValue),
/* harmony export */   "M": () => (/* binding */ getNextYear),
/* harmony export */   "N": () => (/* binding */ getPreviousYear),
/* harmony export */   "O": () => (/* binding */ clampDate),
/* harmony export */   "P": () => (/* binding */ parseAmPm),
/* harmony export */   "Q": () => (/* binding */ calculateHourFromAMPM),
/* harmony export */   "R": () => (/* binding */ getLocalizedDateTime),
/* harmony export */   "S": () => (/* binding */ getMonthDayAndYear),
/* harmony export */   "a": () => (/* binding */ getDay),
/* harmony export */   "b": () => (/* binding */ isAfter),
/* harmony export */   "c": () => (/* binding */ isSameDay),
/* harmony export */   "d": () => (/* binding */ getPreviousMonth),
/* harmony export */   "e": () => (/* binding */ getNextMonth),
/* harmony export */   "f": () => (/* binding */ getToday),
/* harmony export */   "g": () => (/* binding */ generateDayAriaLabel),
/* harmony export */   "h": () => (/* binding */ getPartsFromCalendarDay),
/* harmony export */   "i": () => (/* binding */ isBefore),
/* harmony export */   "j": () => (/* binding */ getEndOfWeek),
/* harmony export */   "k": () => (/* binding */ getStartOfWeek),
/* harmony export */   "l": () => (/* binding */ getPreviousDay),
/* harmony export */   "m": () => (/* binding */ getNextDay),
/* harmony export */   "n": () => (/* binding */ getPreviousWeek),
/* harmony export */   "o": () => (/* binding */ getNextWeek),
/* harmony export */   "p": () => (/* binding */ parseDate),
/* harmony export */   "q": () => (/* binding */ parseMinParts),
/* harmony export */   "r": () => (/* binding */ parseMaxParts),
/* harmony export */   "s": () => (/* binding */ convertToArrayOfNumbers),
/* harmony export */   "t": () => (/* binding */ convertDataToISO),
/* harmony export */   "u": () => (/* binding */ getNumDaysInMonth),
/* harmony export */   "v": () => (/* binding */ validateParts),
/* harmony export */   "w": () => (/* binding */ warnIfValueOutOfBounds),
/* harmony export */   "x": () => (/* binding */ getCombinedDateColumnData),
/* harmony export */   "y": () => (/* binding */ getMonthColumnData),
/* harmony export */   "z": () => (/* binding */ getDayColumnData)
/* harmony export */ });
/* harmony import */ var _index_c4b11676_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-c4b11676.js */ 9273);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */

/**
 * Returns true if the selected day is equal to the reference day
 */

const isSameDay = (baseParts, compareParts) => {
  return baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year;
};
/**
 * Returns true is the selected day is before the reference day.
 */


const isBefore = (baseParts, compareParts) => {
  return !!(baseParts.year < compareParts.year || baseParts.year === compareParts.year && baseParts.month < compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day < compareParts.day);
};
/**
 * Returns true is the selected day is after the reference day.
 */


const isAfter = (baseParts, compareParts) => {
  return !!(baseParts.year > compareParts.year || baseParts.year === compareParts.year && baseParts.month > compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day > compareParts.day);
};

const warnIfValueOutOfBounds = (value, min, max) => {
  const valueArray = Array.isArray(value) ? value : [value];

  for (const val of valueArray) {
    if (min !== undefined && isBefore(val, min) || max !== undefined && isAfter(val, max)) {
      (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_0__.p)('The value provided to ion-datetime is out of bounds.\n\n' + `Min: ${JSON.stringify(min)}\n` + `Max: ${JSON.stringify(max)}\n` + `Value: ${JSON.stringify(value)}`);
      break;
    }
  }
};
/**
 * Determines if given year is a
 * leap year. Returns `true` if year
 * is a leap year. Returns `false`
 * otherwise.
 */


const isLeapYear = year => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};

const is24Hour = (locale, hourCycle) => {
  /**
   * If developer has explicitly enabled h23 time
   * then return early and do not look at the system default.
   */
  if (hourCycle !== undefined) {
    return hourCycle === 'h23';
  }
  /**
   * If hourCycle was not specified, check the locale
   * that is set on the user's device. We first check the
   * Intl.DateTimeFormat hourCycle option as developers can encode this
   * option into the locale string. Example: `en-US-u-hc-h23`
   */


  const formatted = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  });
  const options = formatted.resolvedOptions();

  if (options.hourCycle !== undefined) {
    return options.hourCycle === 'h23';
  }
  /**
   * If hourCycle is not specified (either through lack
   * of browser support or locale information) then fall
   * back to this slower hourCycle check.
   */


  const date = new Date('5/18/2021 00:00');
  const parts = formatted.formatToParts(date);
  const hour = parts.find(p => p.type === 'hour');

  if (!hour) {
    throw new Error('Hour value not found from DateTimeFormat');
  }

  return hour.value === '00';
};
/**
 * Given a date object, returns the number
 * of days in that month.
 * Month value begin at 1, not 0.
 * i.e. January = month 1.
 */


const getNumDaysInMonth = (month, year) => {
  return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? isLeapYear(year) ? 29 : 28 : 31;
};
/**
 * Certain locales display month then year while
 * others display year then month.
 * We can use Intl.DateTimeFormat to determine
 * the ordering for each locale.
 * The formatOptions param can be used to customize
 * which pieces of a date to compare against the month
 * with. For example, some locales render dd/mm/yyyy
 * while others render mm/dd/yyyy. This function can be
 * used for variations of the same "month first" check.
 */


const isMonthFirstLocale = (locale, formatOptions = {
  month: 'numeric',
  year: 'numeric'
}) => {
  /**
   * By setting month and year we guarantee that only
   * month, year, and literal (slashes '/', for example)
   * values are included in the formatToParts results.
   *
   * The ordering of the parts will be determined by
   * the locale. So if the month is the first value,
   * then we know month should be shown first. If the
   * year is the first value, then we know year should be shown first.
   *
   * This ordering can be controlled by customizing the locale property.
   */
  const parts = new Intl.DateTimeFormat(locale, formatOptions).formatToParts(new Date());
  return parts[0].type === 'month';
};
/**
 * Determines if the given locale formats the day period (am/pm) to the
 * left or right of the hour.
 * @param locale The locale to check.
 * @returns `true` if the locale formats the day period to the left of the hour.
 */


const isLocaleDayPeriodRTL = locale => {
  const parts = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  }).formatToParts(new Date());
  return parts[0].type === 'dayPeriod';
};

const twoDigit = val => {
  return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);
};

const fourDigit = val => {
  return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);
};

function convertDataToISO(data) {
  if (Array.isArray(data)) {
    return data.map(parts => convertDataToISO(parts));
  } // https://www.w3.org/TR/NOTE-datetime


  let rtn = '';

  if (data.year !== undefined) {
    // YYYY
    rtn = fourDigit(data.year);

    if (data.month !== undefined) {
      // YYYY-MM
      rtn += '-' + twoDigit(data.month);

      if (data.day !== undefined) {
        // YYYY-MM-DD
        rtn += '-' + twoDigit(data.day);

        if (data.hour !== undefined) {
          // YYYY-MM-DDTHH:mm:SS
          rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:00`;

          if (data.tzOffset === undefined) {
            // YYYY-MM-DDTHH:mm:SSZ
            rtn += 'Z';
          } else {
            // YYYY-MM-DDTHH:mm:SS+/-HH:mm
            rtn += (data.tzOffset > 0 ? '+' : '-') + twoDigit(Math.floor(Math.abs(data.tzOffset / 60))) + ':' + twoDigit(data.tzOffset % 60);
          }
        }
      }
    }
  } else if (data.hour !== undefined) {
    // HH:mm
    rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);
  }

  return rtn;
}
/**
 * Converts an 12 hour value to 24 hours.
 */


const convert12HourTo24Hour = (hour, ampm) => {
  if (ampm === undefined) {
    return hour;
  }
  /**
   * If AM and 12am
   * then return 00:00.
   * Otherwise just return
   * the hour since it is
   * already in 24 hour format.
   */


  if (ampm === 'am') {
    if (hour === 12) {
      return 0;
    }

    return hour;
  }
  /**
   * If PM and 12pm
   * just return 12:00
   * since it is already
   * in 24 hour format.
   * Otherwise add 12 hours
   * to the time.
   */


  if (hour === 12) {
    return 12;
  }

  return hour + 12;
};

const getStartOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;

  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }

  return subtractDays(refParts, dayOfWeek);
};

const getEndOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;

  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }

  return addDays(refParts, 6 - dayOfWeek);
};

const getNextDay = refParts => {
  return addDays(refParts, 1);
};

const getPreviousDay = refParts => {
  return subtractDays(refParts, 1);
};

const getPreviousWeek = refParts => {
  return subtractDays(refParts, 7);
};

const getNextWeek = refParts => {
  return addDays(refParts, 7);
};
/**
 * Given datetime parts, subtract
 * numDays from the date.
 * Returns a new DatetimeParts object
 * Currently can only go backward at most 1 month.
 */


const subtractDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;

  if (day === null) {
    throw new Error('No day provided');
  }

  const workingParts = {
    month,
    day,
    year
  };
  workingParts.day = day - numDays;
  /**
   * If wrapping to previous month
   * update days and decrement month
   */

  if (workingParts.day < 1) {
    workingParts.month -= 1;
  }
  /**
   * If moving to previous year, reset
   * month to December and decrement year
   */


  if (workingParts.month < 1) {
    workingParts.month = 12;
    workingParts.year -= 1;
  }
  /**
   * Determine how many days are in the current
   * month
   */


  if (workingParts.day < 1) {
    const daysInMonth = getNumDaysInMonth(workingParts.month, workingParts.year);
    /**
     * Take num days in month and add the
     * number of underflow days. This number will
     * be negative.
     * Example: 1 week before Jan 2, 2021 is
     * December 26, 2021 so:
     * 2 - 7 = -5
     * 31 + (-5) = 26
     */

    workingParts.day = daysInMonth + workingParts.day;
  }

  return workingParts;
};
/**
 * Given datetime parts, add
 * numDays to the date.
 * Returns a new DatetimeParts object
 * Currently can only go forward at most 1 month.
 */


const addDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;

  if (day === null) {
    throw new Error('No day provided');
  }

  const workingParts = {
    month,
    day,
    year
  };
  const daysInMonth = getNumDaysInMonth(month, year);
  workingParts.day = day + numDays;
  /**
   * If wrapping to next month
   * update days and increment month
   */

  if (workingParts.day > daysInMonth) {
    workingParts.day -= daysInMonth;
    workingParts.month += 1;
  }
  /**
   * If moving to next year, reset
   * month to January and increment year
   */


  if (workingParts.month > 12) {
    workingParts.month = 1;
    workingParts.year += 1;
  }

  return workingParts;
};
/**
 * Given DatetimeParts, generate the previous month.
 */


const getPreviousMonth = refParts => {
  /**
   * If current month is January, wrap backwards
   *  to December of the previous year.
   */
  const month = refParts.month === 1 ? 12 : refParts.month - 1;
  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the next month.
 */


const getNextMonth = refParts => {
  /**
   * If current month is December, wrap forwards
   *  to January of the next year.
   */
  const month = refParts.month === 12 ? 1 : refParts.month + 1;
  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};

const changeYear = (refParts, yearDelta) => {
  const month = refParts.month;
  const year = refParts.year + yearDelta;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the previous year.
 */


const getPreviousYear = refParts => {
  return changeYear(refParts, -1);
};
/**
 * Given DatetimeParts, generate the next year.
 */


const getNextYear = refParts => {
  return changeYear(refParts, 1);
};
/**
 * If PM, then internal value should
 * be converted to 24-hr time.
 * Does not apply when public
 * values are already 24-hr time.
 */


const getInternalHourValue = (hour, use24Hour, ampm) => {
  if (use24Hour) {
    return hour;
  }

  return convert12HourTo24Hour(hour, ampm);
};
/**
 * Unless otherwise stated, all month values are
 * 1 indexed instead of the typical 0 index in JS Date.
 * Example:
 *   January = Month 0 when using JS Date
 *   January = Month 1 when using this datetime util
 */

/**
 * Given the current datetime parts and a new AM/PM value
 * calculate what the hour should be in 24-hour time format.
 * Used when toggling the AM/PM segment since we store our hours
 * in 24-hour time format internally.
 */


const calculateHourFromAMPM = (currentParts, newAMPM) => {
  const {
    ampm: currentAMPM,
    hour
  } = currentParts;
  let newHour = hour;
  /**
   * If going from AM --> PM, need to update the
   *
   */

  if (currentAMPM === 'am' && newAMPM === 'pm') {
    newHour = convert12HourTo24Hour(newHour, 'pm');
    /**
     * If going from PM --> AM
     */
  } else if (currentAMPM === 'pm' && newAMPM === 'am') {
    newHour = Math.abs(newHour - 12);
  }

  return newHour;
};
/**
 * Updates parts to ensure that month and day
 * values are valid. For days that do not exist,
 * the closest valid day is used.
 */


const validateParts = (parts, minParts, maxParts) => {
  const {
    month,
    day,
    year
  } = parts;
  const partsCopy = Object.assign({}, parts);
  const numDays = getNumDaysInMonth(month, year);
  /**
   * If the max number of days
   * is greater than the day we want
   * to set, update the DatetimeParts
   * day field to be the max days.
   */

  if (day !== null && numDays < day) {
    partsCopy.day = numDays;
  }
  /**
   * If value is same day as min day,
   * make sure the time value is in bounds.
   */


  if (minParts !== undefined && isSameDay(partsCopy, minParts)) {
    /**
     * If the hour is out of bounds,
     * update both the hour and minute.
     * This is done so that the new time
     * is closest to what the user selected.
     */
    if (partsCopy.hour !== undefined && minParts.hour !== undefined) {
      if (partsCopy.hour < minParts.hour) {
        partsCopy.hour = minParts.hour;
        partsCopy.minute = minParts.minute;
        /**
         * If only the minute is out of bounds,
         * set it to the min minute.
         */
      } else if (partsCopy.hour === minParts.hour && partsCopy.minute !== undefined && minParts.minute !== undefined && partsCopy.minute < minParts.minute) {
        partsCopy.minute = minParts.minute;
      }
    }
  }
  /**
   * If value is same day as max day,
   * make sure the time value is in bounds.
   */


  if (maxParts !== undefined && isSameDay(parts, maxParts)) {
    /**
     * If the hour is out of bounds,
     * update both the hour and minute.
     * This is done so that the new time
     * is closest to what the user selected.
     */
    if (partsCopy.hour !== undefined && maxParts.hour !== undefined) {
      if (partsCopy.hour > maxParts.hour) {
        partsCopy.hour = maxParts.hour;
        partsCopy.minute = maxParts.minute;
        /**
         * If only the minute is out of bounds,
         * set it to the max minute.
         */
      } else if (partsCopy.hour === maxParts.hour && partsCopy.minute !== undefined && maxParts.minute !== undefined && partsCopy.minute > maxParts.minute) {
        partsCopy.minute = maxParts.minute;
      }
    }
  }

  return partsCopy;
};

const getFormattedDayPeriod = dayPeriod => {
  if (dayPeriod === undefined) {
    return '';
  }

  return dayPeriod.toUpperCase();
};

const getLocalizedTime = (locale, refParts, use24Hour) => {
  if (refParts.hour === undefined || refParts.minute === undefined) {
    return 'Invalid Time';
  }

  return new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    minute: 'numeric',
    timeZone: 'UTC',

    /**
     * We use hourCycle here instead of hour12 due to:
     * https://bugs.chromium.org/p/chromium/issues/detail?id=1347316&q=hour12&can=2
     */
    hourCycle: use24Hour ? 'h23' : 'h12'
  }).format(new Date(convertDataToISO(Object.assign(Object.assign({}, refParts), {
    // TODO: FW-1831 will remove the need to manually set the tzOffset to undefined
    tzOffset: undefined
  }))));
};
/**
 * Adds padding to a time value so
 * that it is always 2 digits.
 */


const addTimePadding = value => {
  const valueToString = value.toString();

  if (valueToString.length > 1) {
    return valueToString;
  }

  return `0${valueToString}`;
};
/**
 * Formats 24 hour times so that
 * it always has 2 digits. For
 * 12 hour times it ensures that
 * hour 0 is formatted as '12'.
 */


const getFormattedHour = (hour, use24Hour) => {
  if (use24Hour) {
    return addTimePadding(hour);
  }
  /**
   * If using 12 hour
   * format, make sure hour
   * 0 is formatted as '12'.
   */


  if (hour === 0) {
    return '12';
  }

  return hour.toString();
};
/**
 * Generates an aria-label to be read by screen readers
 * given a local, a date, and whether or not that date is
 * today's date.
 */


const generateDayAriaLabel = (locale, today, refParts) => {
  if (refParts.day === null) {
    return null;
  }
  /**
   * MM/DD/YYYY will return midnight in the user's timezone.
   */


  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  const labelString = new Intl.DateTimeFormat(locale, {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
  /**
   * If date is today, prepend "Today" so screen readers indicate
   * that the date is today.
   */

  return today ? `Today, ${labelString}` : labelString;
};
/**
 * Gets the day of the week, month, and day
 * Used for the header in MD mode.
 */


const getMonthAndDay = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the month name and full year.
 * Example: May 2021
 */


const getMonthAndYear = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    month: 'long',
    year: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the short month, numeric day, and full year.
 * Example: Apr 22, 2021
 */


const getMonthDayAndYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric day.
 * Note: Some languages will add literal characters
 * to the end. This function removes those literals.
 * Example: 29
 */


const getDay = (locale, refParts) => {
  return getLocalizedDateTimeParts(locale, refParts, {
    day: 'numeric'
  }).find(obj => obj.type === 'day').value;
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric year.
 * Example: 2022
 */


const getYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    year: 'numeric'
  });
};

const getNormalizedDate = refParts => {
  const timeString = refParts.hour !== undefined && refParts.minute !== undefined ? ` ${refParts.hour}:${refParts.minute}` : '';
  return new Date(`${refParts.month}/${refParts.day}/${refParts.year}${timeString} GMT+0000`);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns a string. If
 * you want an array of the individual pieces
 * that make up the localized date string, use
 * getLocalizedDateTimeParts.
 */


const getLocalizedDateTime = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, options).format(date);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns an array of
 * each piece of the date.
 */


const getLocalizedDateTimeParts = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, options).formatToParts(date);
};
/**
 * Wrapper function for Intl.DateTimeFormat.
 * Allows developers to apply an allowed format to DatetimeParts.
 * This function also has built in safeguards for older browser bugs
 * with Intl.DateTimeFormat.
 */


const getDateTimeFormat = (locale, options) => {
  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, options), {
    timeZone: 'UTC'
  }));
};
/**
 * Gets a localized version of "Today"
 * Falls back to "Today" in English for
 * browsers that do not support RelativeTimeFormat.
 */


const getTodayLabel = locale => {
  if ('RelativeTimeFormat' in Intl) {
    const label = new Intl.RelativeTimeFormat(locale, {
      numeric: 'auto'
    }).format(0, 'day');
    return label.charAt(0).toUpperCase() + label.slice(1);
  } else {
    return 'Today';
  }
};
/**
 * When calling toISOString(), the browser
 * will convert the date to UTC time by either adding
 * or subtracting the time zone offset.
 * To work around this, we need to either add
 * or subtract the time zone offset to the Date
 * object prior to calling toISOString().
 * This allows us to get an ISO string
 * that is in the user's time zone.
 *
 * Example:
 * Time zone offset is 240
 * Meaning: The browser needs to add 240 minutes
 * to the Date object to get UTC time.
 * What Ionic does: We subtract 240 minutes
 * from the Date object. The browser then adds
 * 240 minutes in toISOString(). The result
 * is a time that is in the user's time zone
 * and not UTC.
 *
 * Note: Some timezones include minute adjustments
 * such as 30 or 45 minutes. This is why we use setMinutes
 * instead of setHours.
 * Example: India Standard Time
 * Timezone offset: -330 = -5.5 hours.
 *
 * List of timezones with 30 and 45 minute timezones:
 * https://www.timeanddate.com/time/time-zones-interesting.html
 */


const removeDateTzOffset = date => {
  const tzOffset = date.getTimezoneOffset();
  date.setMinutes(date.getMinutes() - tzOffset);
  return date;
};

const DATE_AM = removeDateTzOffset(new Date('2022T01:00'));
const DATE_PM = removeDateTzOffset(new Date('2022T13:00'));
/**
 * Formats the locale's string representation of the day period (am/pm) for a given
 * ref parts day period.
 *
 * @param locale The locale to format the day period in.
 * @param value The date string, in ISO format.
 * @returns The localized day period (am/pm) representation of the given value.
 */

const getLocalizedDayPeriod = (locale, dayPeriod) => {
  const date = dayPeriod === 'am' ? DATE_AM : DATE_PM;
  const localizedDayPeriod = new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    timeZone: 'UTC'
  }).formatToParts(date).find(part => part.type === 'dayPeriod');

  if (localizedDayPeriod) {
    return localizedDayPeriod.value;
  }

  return getFormattedDayPeriod(dayPeriod);
};
/**
 * Formats the datetime's value to a string, for use in the native input.
 *
 * @param value The value to format, either an ISO string or an array thereof.
 */


const formatValue = value => {
  return Array.isArray(value) ? value.join(',') : value;
};
/**
 * Returns the current date as
 * an ISO string in the user's
 * time zone.
 */


const getToday = () => {
  /**
   * ion-datetime intentionally does not
   * parse time zones/do automatic time zone
   * conversion when accepting user input.
   * However when we get today's date string,
   * we want it formatted relative to the user's
   * time zone.
   *
   * When calling toISOString(), the browser
   * will convert the date to UTC time by either adding
   * or subtracting the time zone offset.
   * To work around this, we need to either add
   * or subtract the time zone offset to the Date
   * object prior to calling toISOString().
   * This allows us to get an ISO string
   * that is in the user's time zone.
   */
  return removeDateTzOffset(new Date()).toISOString();
};

const minutes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59];
const hour12 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
const hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
/**
 * Given a locale and a mode,
 * return an array with formatted days
 * of the week. iOS should display days
 * such as "Mon" or "Tue".
 * MD should display days such as "M"
 * or "T".
 */

const getDaysOfWeek = (locale, mode, firstDayOfWeek = 0) => {
  /**
   * Nov 1st, 2020 starts on a Sunday.
   * ion-datetime assumes weeks start on Sunday,
   * but is configurable via `firstDayOfWeek`.
   */
  const weekdayFormat = mode === 'ios' ? 'short' : 'narrow';
  const intl = new Intl.DateTimeFormat(locale, {
    weekday: weekdayFormat
  });
  const startDate = new Date('11/01/2020');
  const daysOfWeek = [];
  /**
   * For each day of the week,
   * get the day name.
   */

  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(currentDate.getDate() + i);
    daysOfWeek.push(intl.format(currentDate));
  }

  return daysOfWeek;
};
/**
 * Returns an array containing all of the
 * days in a month for a given year. Values are
 * aligned with a week calendar starting on
 * the firstDayOfWeek value (Sunday by default)
 * using null values.
 */


const getDaysOfMonth = (month, year, firstDayOfWeek) => {
  const numDays = getNumDaysInMonth(month, year);
  const firstOfMonth = new Date(`${month}/1/${year}`).getDay();
  /**
   * To get the first day of the month aligned on the correct
   * day of the week, we need to determine how many "filler" days
   * to generate. These filler days as empty/disabled buttons
   * that fill the space of the days of the week before the first
   * of the month.
   *
   * There are two cases here:
   *
   * 1. If firstOfMonth = 4, firstDayOfWeek = 0 then the offset
   * is (4 - (0 + 1)) = 3. Since the offset loop goes from 0 to 3 inclusive,
   * this will generate 4 filler days (0, 1, 2, 3), and then day of week 4 will have
   * the first day of the month.
   *
   * 2. If firstOfMonth = 2, firstDayOfWeek = 4 then the offset
   * is (6 - (4 - 2)) = 4. Since the offset loop goes from 0 to 4 inclusive,
   * this will generate 5 filler days (0, 1, 2, 3, 4), and then day of week 5 will have
   * the first day of the month.
   */

  const offset = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);
  let days = [];

  for (let i = 1; i <= numDays; i++) {
    days.push({
      day: i,
      dayOfWeek: (offset + i) % 7
    });
  }

  for (let i = 0; i <= offset; i++) {
    days = [{
      day: null,
      dayOfWeek: null
    }, ...days];
  }

  return days;
};
/**
 * Given a local, reference datetime parts and option
 * max/min bound datetime parts, calculate the acceptable
 * hour and minute values according to the bounds and locale.
 */


const generateTime = (refParts, hourCycle = 'h12', minParts, maxParts, hourValues, minuteValues) => {
  const use24Hour = hourCycle === 'h23';
  let processedHours = use24Hour ? hour23 : hour12;
  let processedMinutes = minutes;
  let isAMAllowed = true;
  let isPMAllowed = true;

  if (hourValues) {
    processedHours = processedHours.filter(hour => hourValues.includes(hour));
  }

  if (minuteValues) {
    processedMinutes = processedMinutes.filter(minute => minuteValues.includes(minute));
  }

  if (minParts) {
    /**
     * If ref day is the same as the
     * minimum allowed day, filter hour/minute
     * values according to min hour and minute.
     */
    if (isSameDay(refParts, minParts)) {
      /**
       * Users may not always set the hour/minute for
       * min value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (minParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) >= minParts.hour;
        });
        isAMAllowed = minParts.hour < 13;
      }

      if (minParts.minute !== undefined) {
        /**
         * The minimum minute range should not be enforced when
         * the hour is greater than the min hour.
         *
         * For example with a minimum range of 09:30, users
         * should be able to select 10:00-10:29 and beyond.
         */
        let isPastMinHour = false;

        if (minParts.hour !== undefined && refParts.hour !== undefined) {
          if (refParts.hour > minParts.hour) {
            isPastMinHour = true;
          }
        }

        processedMinutes = processedMinutes.filter(minute => {
          if (isPastMinHour) {
            return true;
          }

          return minute >= minParts.minute;
        });
      }
      /**
       * If ref day is before minimum
       * day do not render any hours/minute values
       */

    } else if (isBefore(refParts, minParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }

  if (maxParts) {
    /**
     * If ref day is the same as the
     * maximum allowed day, filter hour/minute
     * values according to max hour and minute.
     */
    if (isSameDay(refParts, maxParts)) {
      /**
       * Users may not always set the hour/minute for
       * max value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (maxParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) <= maxParts.hour;
        });
        isPMAllowed = maxParts.hour >= 13;
      }

      if (maxParts.minute !== undefined && refParts.hour === maxParts.hour) {
        // The available minutes should only be filtered when the hour is the same as the max hour.
        // For example if the max hour is 10:30 and the current hour is 10:00,
        // users should be able to select 00-30 minutes.
        // If the current hour is 09:00, users should be able to select 00-60 minutes.
        processedMinutes = processedMinutes.filter(minute => minute <= maxParts.minute);
      }
      /**
       * If ref day is after minimum
       * day do not render any hours/minute values
       */

    } else if (isAfter(refParts, maxParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }

  return {
    hours: processedHours,
    minutes: processedMinutes,
    am: isAMAllowed,
    pm: isPMAllowed
  };
};
/**
 * Given DatetimeParts, generate the previous,
 * current, and and next months.
 */


const generateMonths = refParts => {
  return [getPreviousMonth(refParts), {
    month: refParts.month,
    year: refParts.year,
    day: refParts.day
  }, getNextMonth(refParts)];
};

const getMonthColumnData = (locale, refParts, minParts, maxParts, monthValues, formatOptions = {
  month: 'long'
}) => {
  const {
    year
  } = refParts;
  const months = [];

  if (monthValues !== undefined) {
    let processedMonths = monthValues;

    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month <= maxParts.month);
    }

    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month >= minParts.month);
    }

    processedMonths.forEach(processedMonth => {
      const date = new Date(`${processedMonth}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: processedMonth
      });
    });
  } else {
    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;
    const minMonth = minParts && minParts.year === year ? minParts.month : 1;

    for (let i = minMonth; i <= maxMonth; i++) {
      /**
       *
       * There is a bug on iOS 14 where
       * Intl.DateTimeFormat takes into account
       * the local timezone offset when formatting dates.
       *
       * Forcing the timezone to 'UTC' fixes the issue. However,
       * we should keep this workaround as it is safer. In the event
       * this breaks in another browser, we will not be impacted
       * because all dates will be interpreted in UTC.
       *
       * Example:
       * new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "March"
       * new Intl.DateTimeFormat('en-US', { month: 'long', timeZone: 'UTC' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "April"
       *
       * In certain timezones, iOS 14 shows the wrong
       * date for .toUTCString(). To combat this, we
       * force all of the timezones to GMT+0000 (UTC).
       *
       * Example:
       * Time Zone: Central European Standard Time
       * new Date('1/1/1992').toUTCString() // "Tue, 31 Dec 1991 23:00:00 GMT"
       * new Date('1/1/1992 GMT+0000').toUTCString() // "Wed, 01 Jan 1992 00:00:00 GMT"
       */
      const date = new Date(`${i}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: i
      });
    }
  }

  return months;
};
/**
 * Returns information regarding
 * selectable dates (i.e 1st, 2nd, 3rd, etc)
 * within a reference month.
 * @param locale The locale to format the date with
 * @param refParts The reference month/year to generate dates for
 * @param minParts The minimum bound on the date that can be returned
 * @param maxParts The maximum bound on the date that can be returned
 * @param dayValues The allowed date values
 * @returns Date data to be used in ion-picker-column-internal
 */


const getDayColumnData = (locale, refParts, minParts, maxParts, dayValues, formatOptions = {
  day: 'numeric'
}) => {
  const {
    month,
    year
  } = refParts;
  const days = [];
  /**
   * If we have max/min bounds that in the same
   * month/year as the refParts, we should
   * use the define day as the max/min day.
   * Otherwise, fallback to the max/min days in a month.
   */

  const numDaysInMonth = getNumDaysInMonth(month, year);
  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== null && (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== undefined && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;
  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== null && (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== undefined && minParts.year === year && minParts.month === month ? minParts.day : 1;

  if (dayValues !== undefined) {
    let processedDays = dayValues;
    processedDays = processedDays.filter(day => day >= minDay && day <= maxDay);
    processedDays.forEach(processedDay => {
      const date = new Date(`${month}/${processedDay}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: processedDay
      });
    });
  } else {
    for (let i = minDay; i <= maxDay; i++) {
      const date = new Date(`${month}/${i}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: i
      });
    }
  }

  return days;
};

const getYearColumnData = (locale, refParts, minParts, maxParts, yearValues) => {
  var _a, _b;

  let processedYears = [];

  if (yearValues !== undefined) {
    processedYears = yearValues;

    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year <= maxParts.year);
    }

    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year >= minParts.year);
    }
  } else {
    const {
      year
    } = refParts;
    const maxYear = (_a = maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== null && _a !== void 0 ? _a : year;
    const minYear = (_b = minParts === null || minParts === void 0 ? void 0 : minParts.year) !== null && _b !== void 0 ? _b : year - 100;

    for (let i = maxYear; i >= minYear; i--) {
      processedYears.push(i);
    }
  }

  return processedYears.map(year => ({
    text: getYear(locale, {
      year,
      month: refParts.month,
      day: refParts.day
    }),
    value: year
  }));
};
/**
 * Given a starting date and an upper bound,
 * this functions returns an array of all
 * month objects in that range.
 */


const getAllMonthsInRange = (currentParts, maxParts) => {
  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {
    return [currentParts];
  }

  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];
};
/**
 * Creates and returns picker items
 * that represent the days in a month.
 * Example: "Thu, Jun 2"
 */


const getCombinedDateColumnData = (locale, todayParts, minParts, maxParts, dayValues, monthValues) => {
  let items = [];
  let parts = [];
  /**
   * Get all month objects from the min date
   * to the max date. Note: Do not use getMonthColumnData
   * as that function only generates dates within a
   * single year.
   */

  let months = getAllMonthsInRange(minParts, maxParts);
  /**
   * Filter out any disallowed month values.
   */

  if (monthValues) {
    months = months.filter(({
      month
    }) => monthValues.includes(month));
  }
  /**
   * Get all of the days in the month.
   * From there, generate an array where
   * each item has the month, date, and day
   * of work as the text.
   */


  months.forEach(monthObject => {
    const referenceMonth = {
      month: monthObject.month,
      day: null,
      year: monthObject.year
    };
    const monthDays = getDayColumnData(locale, referenceMonth, minParts, maxParts, dayValues, {
      month: 'short',
      day: 'numeric',
      weekday: 'short'
    });
    const dateParts = [];
    const dateColumnItems = [];
    monthDays.forEach(dayObject => {
      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), {
        day: dayObject.value
      }), todayParts);
      /**
       * Today's date should read as "Today" (localized)
       * not the actual date string
       */

      dateColumnItems.push({
        text: isToday ? getTodayLabel(locale) : dayObject.text,
        value: `${referenceMonth.year}-${referenceMonth.month}-${dayObject.value}`
      });
      /**
       * When selecting a date in the wheel picker
       * we need access to the raw datetime parts data.
       * The picker column only accepts values of
       * type string or number, so we need to return
       * two sets of data: A data set to be passed
       * to the picker column, and a data set to
       * be used to reference the raw data when
       * updating the picker column value.
       */

      dateParts.push({
        month: referenceMonth.month,
        year: referenceMonth.year,
        day: dayObject.value
      });
    });
    parts = [...parts, ...dateParts];
    items = [...items, ...dateColumnItems];
  });
  return {
    parts,
    items
  };
};

const getTimeColumnsData = (locale, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteVaues) => {
  const use24Hour = is24Hour(locale, hourCycle);
  const {
    hours,
    minutes,
    am,
    pm
  } = generateTime(refParts, use24Hour ? 'h23' : 'h12', minParts, maxParts, allowedHourValues, allowedMinuteVaues);
  const hoursItems = hours.map(hour => {
    return {
      text: getFormattedHour(hour, use24Hour),
      value: getInternalHourValue(hour, use24Hour, refParts.ampm)
    };
  });
  const minutesItems = minutes.map(minute => {
    return {
      text: addTimePadding(minute),
      value: minute
    };
  });
  const dayPeriodItems = [];

  if (am && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'am'),
      value: 'am'
    });
  }

  if (pm && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'pm'),
      value: 'pm'
    });
  }

  return {
    minutesData: minutesItems,
    hoursData: hoursItems,
    dayPeriodData: dayPeriodItems
  };
};

const ISO_8601_REGEXP = // eslint-disable-next-line no-useless-escape
/^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/; // eslint-disable-next-line no-useless-escape

const TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
/**
 * Use to convert a string of comma separated numbers or
 * an array of numbers, and clean up any user input
 */

const convertToArrayOfNumbers = input => {
  if (input === undefined) {
    return;
  }

  let processedInput = input;

  if (typeof input === 'string') {
    // convert the string to an array of strings
    // auto remove any whitespace and [] characters
    processedInput = input.replace(/\[|\]|\s/g, '').split(',');
  }

  let values;

  if (Array.isArray(processedInput)) {
    // ensure each value is an actual number in the returned array
    values = processedInput.map(num => parseInt(num, 10)).filter(isFinite);
  } else {
    values = [processedInput];
  }

  return values;
};
/**
 * Extracts date information
 * from a .calendar-day element
 * into DatetimeParts.
 */


const getPartsFromCalendarDay = el => {
  return {
    month: parseInt(el.getAttribute('data-month'), 10),
    day: parseInt(el.getAttribute('data-day'), 10),
    year: parseInt(el.getAttribute('data-year'), 10),
    dayOfWeek: parseInt(el.getAttribute('data-day-of-week'), 10)
  };
};

function parseDate(val) {
  if (Array.isArray(val)) {
    return val.map(valStr => parseDate(valStr));
  } // manually parse IS0 cuz Date.parse cannot be trusted
  // ISO 8601 format: 1994-12-15T13:47:20Z


  let parse = null;

  if (val != null && val !== '') {
    // try parsing for just time first, HH:MM
    parse = TIME_REGEXP.exec(val);

    if (parse) {
      // adjust the array so it fits nicely with the datetime parse
      parse.unshift(undefined, undefined);
      parse[2] = parse[3] = undefined;
    } else {
      // try parsing for full ISO datetime
      parse = ISO_8601_REGEXP.exec(val);
    }
  }

  if (parse === null) {
    // wasn't able to parse the ISO datetime
    return undefined;
  } // ensure all the parse values exist with at least 0


  for (let i = 1; i < 8; i++) {
    parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;
  }

  let tzOffset = 0;

  if (parse[9] && parse[10]) {
    // hours
    tzOffset = parseInt(parse[10], 10) * 60;

    if (parse[11]) {
      // minutes
      tzOffset += parseInt(parse[11], 10);
    }

    if (parse[9] === '-') {
      // + or -
      tzOffset *= -1;
    }
  } // can also get second and millisecond from parse[6] and parse[7] if needed


  return {
    year: parse[1],
    month: parse[2],
    day: parse[3],
    hour: parse[4],
    minute: parse[5],
    tzOffset,
    ampm: parse[4] < 12 ? 'am' : 'pm'
  };
}

const clampDate = (dateParts, minParts, maxParts) => {
  if (minParts && isBefore(dateParts, minParts)) {
    return minParts;
  } else if (maxParts && isAfter(dateParts, maxParts)) {
    return maxParts;
  }

  return dateParts;
};
/**
 * Parses an hour and returns if the value is in the morning (am) or afternoon (pm).
 * @param hour The hour to format, should be 0-23
 * @returns `pm` if the hour is greater than or equal to 12, `am` if less than 12.
 */


const parseAmPm = hour => {
  return hour >= 12 ? 'pm' : 'am';
};
/**
 * Takes a max date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, max="2012" would fill in the missing
 * month, day, hour, and minute information.
 */


const parseMaxParts = (max, todayParts) => {
  const {
    month,
    day,
    year,
    hour,
    minute
  } = parseDate(max);
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */

  const yearValue = year !== null && year !== void 0 ? year : todayParts.year;
  const monthValue = month !== null && month !== void 0 ? month : 12;
  return {
    month: monthValue,
    day: day !== null && day !== void 0 ? day : getNumDaysInMonth(monthValue, yearValue),

    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: yearValue,
    hour: hour !== null && hour !== void 0 ? hour : 23,
    minute: minute !== null && minute !== void 0 ? minute : 59
  };
};
/**
 * Takes a min date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, min="2012" would fill in the missing
 * month, day, hour, and minute information.
 */


const parseMinParts = (min, todayParts) => {
  const {
    month,
    day,
    year,
    hour,
    minute
  } = parseDate(min);
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */

  return {
    month: month !== null && month !== void 0 ? month : 1,
    day: day !== null && day !== void 0 ? day : 1,

    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: year !== null && year !== void 0 ? year : todayParts.year,
    hour: hour !== null && hour !== void 0 ? hour : 0,
    minute: minute !== null && minute !== void 0 ? minute : 0
  };
};



/***/ }),

/***/ 320:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/theme-7670341c.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ createColorClasses),
/* harmony export */   "g": () => (/* binding */ getClassMap),
/* harmony export */   "h": () => (/* binding */ hostContext),
/* harmony export */   "o": () => (/* binding */ openURL)
/* harmony export */ });
/* harmony import */ var C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 1670);


/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el) => {
  return el.closest(selector) !== null;
};
/**
 * Create the mode and color classes for the component based on the classes passed in
 */


const createColorClasses = (color, cssClassMap) => {
  return typeof color === 'string' && color.length > 0 ? Object.assign({
    'ion-color': true,
    [`ion-color-${color}`]: true
  }, cssClassMap) : cssClassMap;
};

const getClassList = classes => {
  if (classes !== undefined) {
    const array = Array.isArray(classes) ? classes : classes.split(' ');
    return array.filter(c => c != null).map(c => c.trim()).filter(c => c !== '');
  }

  return [];
};

const getClassMap = classes => {
  const map = {};
  getClassList(classes).forEach(c => map[c] = true);
  return map;
};

const SCHEME = /^[a-z][a-z0-9+\-.]*:/;

const openURL = /*#__PURE__*/function () {
  var _ref = (0,C_Users_2DAW_Documents_ionic_animales_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url, ev, direction, animation) {
    if (url != null && url[0] !== '#' && !SCHEME.test(url)) {
      const router = document.querySelector('ion-router');

      if (router) {
        if (ev != null) {
          ev.preventDefault();
        }

        return router.push(url, direction, animation);
      }
    }

    return false;
  });

  return function openURL(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV9wYXJzZS01YjhhMTU0MV9qcy1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV90LThkNGQzMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsZUFBZSxHQUFHLENBQUNDLE9BQUQsRUFBVSxHQUFHQyxNQUFiLEtBQXdCO0VBQzlDLE9BQU9DLE9BQU8sQ0FBQ0MsSUFBUixDQUFjLG9CQUFtQkgsT0FBUSxFQUF6QyxFQUE0QyxHQUFHQyxNQUEvQyxDQUFQO0FBQ0QsQ0FGRDtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNRyxhQUFhLEdBQUcsQ0FBQ0osT0FBRCxFQUFVLEdBQUdDLE1BQWIsS0FBd0I7RUFDNUMsT0FBT0MsT0FBTyxDQUFDRyxLQUFSLENBQWUsa0JBQWlCTCxPQUFRLEVBQXhDLEVBQTJDLEdBQUdDLE1BQTlDLENBQVA7QUFDRCxDQUZEO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1LLHlCQUF5QixHQUFHLENBQUNDLEVBQUQsRUFBSyxHQUFHQyxlQUFSLEtBQTRCO0VBQzVELE9BQU9OLE9BQU8sQ0FBQ0csS0FBUixDQUFlLElBQUdFLEVBQUUsQ0FBQ0UsT0FBSCxDQUFXQyxXQUFYLEVBQXlCLHlCQUF3QkYsZUFBZSxDQUFDRyxJQUFoQixDQUFxQixNQUFyQixDQUE2QixHQUFoRyxDQUFQO0FBQ0QsQ0FGRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNSSxTQUFTLEdBQUcsQ0FBQ0MsU0FBRCxFQUFZQyxZQUFaLEtBQTZCO0VBQzdDLE9BQVFE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QkFBZjs7QUFDQSxNQUFNQyxPQUFPO0VBQUEsd0pBQUcsV0FBT0MsR0FBUCxFQUFZQyxFQUFaLEVBQWdCQyxTQUFoQixFQUEyQkMsU0FBM0IsRUFBeUM7SUFDdkQsSUFBSUgsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxLQUFXLEdBQTFCLElBQWlDLENBQUNGLE1BQU0sQ0FBQ00sSUFBUCxDQUFZSixHQUFaLENBQXRDLEVBQXdEO01BQ3RELE1BQU1LLE1BQU0sR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLFlBQXZCLENBQWY7O01BQ0EsSUFBSUYsTUFBSixFQUFZO1FBQ1YsSUFBSUosRUFBRSxJQUFJLElBQVYsRUFBZ0I7VUFDZEEsRUFBRSxDQUFDTyxjQUFIO1FBQ0Q7O1FBQ0QsT0FBT0gsTUFBTSxDQUFDbkosSUFBUCxDQUFZOEksR0FBWixFQUFpQkUsU0FBakIsRUFBNEJDLFNBQTVCLENBQVA7TUFDRDtJQUNGOztJQUNELE9BQU8sS0FBUDtFQUNELENBWFk7O0VBQUEsZ0JBQVBKLE9BQU87SUFBQTtFQUFBO0FBQUEsR0FBYiIsInNvdXJjZXMiOlsiLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vaW5kZXgtYzRiMTE2NzYuanMiLCIuL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS9wYXJzZS01YjhhMTU0MS5qcyIsIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL3RoZW1lLTc2NzAzNDFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlIHdpdGggYW4gSW9uaWMgcHJlZml4XG4gKiB0byBpbmRpY2F0ZSB0aGUgbGlicmFyeSB0aGF0IGlzIHdhcm5pbmcgdGhlIGRldmVsb3Blci5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBzdHJpbmcgbWVzc2FnZSB0byBiZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbmNvbnN0IHByaW50SW9uV2FybmluZyA9IChtZXNzYWdlLCAuLi5wYXJhbXMpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihgW0lvbmljIFdhcm5pbmddOiAke21lc3NhZ2V9YCwgLi4ucGFyYW1zKTtcbn07XG4vKlxuICogTG9ncyBhbiBlcnJvciB0byB0aGUgY29uc29sZSB3aXRoIGFuIElvbmljIHByZWZpeFxuICogdG8gaW5kaWNhdGUgdGhlIGxpYnJhcnkgdGhhdCBpcyB3YXJuaW5nIHRoZSBkZXZlbG9wZXIuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgc3RyaW5nIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkIHRvIHRoZSBjb25zb2xlLlxuICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHN1cHBseSB0byB0aGUgY29uc29sZS5lcnJvci5cbiAqL1xuY29uc3QgcHJpbnRJb25FcnJvciA9IChtZXNzYWdlLCAuLi5wYXJhbXMpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFtJb25pYyBFcnJvcl06ICR7bWVzc2FnZX1gLCAuLi5wYXJhbXMpO1xufTtcbi8qKlxuICogUHJpbnRzIGFuIGVycm9yIGluZm9ybWluZyBkZXZlbG9wZXJzIHRoYXQgYW4gaW1wbGVtZW50YXRpb24gcmVxdWlyZXMgYW4gZWxlbWVudCB0byBiZSB1c2VkXG4gKiB3aXRoaW4gYSBzcGVjaWZpYyBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0gZWwgVGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCB0aGlzIGlzIHJlcXVpcmluZyB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB0YXJnZXRTZWxlY3RvcnMgVGhlIHNlbGVjdG9yIG9yIHNlbGVjdG9ycyB0aGF0IHdlcmUgbm90IGZvdW5kLlxuICovXG5jb25zdCBwcmludFJlcXVpcmVkRWxlbWVudEVycm9yID0gKGVsLCAuLi50YXJnZXRTZWxlY3RvcnMpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+IG11c3QgYmUgdXNlZCBpbnNpZGUgJHt0YXJnZXRTZWxlY3RvcnMuam9pbignIG9yICcpfS5gKTtcbn07XG5cbmV4cG9ydCB7IHByaW50UmVxdWlyZWRFbGVtZW50RXJyb3IgYXMgYSwgcHJpbnRJb25FcnJvciBhcyBiLCBwcmludElvbldhcm5pbmcgYXMgcCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHAgYXMgcHJpbnRJb25XYXJuaW5nIH0gZnJvbSAnLi9pbmRleC1jNGIxMTY3Ni5qcyc7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZWxlY3RlZCBkYXkgaXMgZXF1YWwgdG8gdGhlIHJlZmVyZW5jZSBkYXlcbiAqL1xuY29uc3QgaXNTYW1lRGF5ID0gKGJhc2VQYXJ0cywgY29tcGFyZVBhcnRzKSA9PiB7XG4gIHJldHVybiAoYmFzZVBhcnRzLm1vbnRoID09PSBjb21wYXJlUGFydHMubW9udGggJiYgYmFzZVBhcnRzLmRheSA9PT0gY29tcGFyZVBhcnRzLmRheSAmJiBiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlzIHRoZSBzZWxlY3RlZCBkYXkgaXMgYmVmb3JlIHRoZSByZWZlcmVuY2UgZGF5LlxuICovXG5jb25zdCBpc0JlZm9yZSA9IChiYXNlUGFydHMsIGNvbXBhcmVQYXJ0cykgPT4ge1xuICByZXR1cm4gISEoYmFzZVBhcnRzLnllYXIgPCBjb21wYXJlUGFydHMueWVhciB8fFxuICAgIChiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIgJiYgYmFzZVBhcnRzLm1vbnRoIDwgY29tcGFyZVBhcnRzLm1vbnRoKSB8fFxuICAgIChiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIgJiZcbiAgICAgIGJhc2VQYXJ0cy5tb250aCA9PT0gY29tcGFyZVBhcnRzLm1vbnRoICYmXG4gICAgICBiYXNlUGFydHMuZGF5ICE9PSBudWxsICYmXG4gICAgICBiYXNlUGFydHMuZGF5IDwgY29tcGFyZVBhcnRzLmRheSkpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlzIHRoZSBzZWxlY3RlZCBkYXkgaXMgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBkYXkuXG4gKi9cbmNvbnN0IGlzQWZ0ZXIgPSAoYmFzZVBhcnRzLCBjb21wYXJlUGFydHMpID0+IHtcbiAgcmV0dXJuICEhKGJhc2VQYXJ0cy55ZWFyID4gY29tcGFyZVBhcnRzLnllYXIgfHxcbiAgICAoYmFzZVBhcnRzLnllYXIgPT09IGNvbXBhcmVQYXJ0cy55ZWFyICYmIGJhc2VQYXJ0cy5tb250aCA+IGNvbXBhcmVQYXJ0cy5tb250aCkgfHxcbiAgICAoYmFzZVBhcnRzLnllYXIgPT09IGNvbXBhcmVQYXJ0cy55ZWFyICYmXG4gICAgICBiYXNlUGFydHMubW9udGggPT09IGNvbXBhcmVQYXJ0cy5tb250aCAmJlxuICAgICAgYmFzZVBhcnRzLmRheSAhPT0gbnVsbCAmJlxuICAgICAgYmFzZVBhcnRzLmRheSA+IGNvbXBhcmVQYXJ0cy5kYXkpKTtcbn07XG5jb25zdCB3YXJuSWZWYWx1ZU91dE9mQm91bmRzID0gKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xuICBjb25zdCB2YWx1ZUFycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlQXJyYXkpIHtcbiAgICBpZiAoKG1pbiAhPT0gdW5kZWZpbmVkICYmIGlzQmVmb3JlKHZhbCwgbWluKSkgfHwgKG1heCAhPT0gdW5kZWZpbmVkICYmIGlzQWZ0ZXIodmFsLCBtYXgpKSkge1xuICAgICAgcHJpbnRJb25XYXJuaW5nKCdUaGUgdmFsdWUgcHJvdmlkZWQgdG8gaW9uLWRhdGV0aW1lIGlzIG91dCBvZiBib3VuZHMuXFxuXFxuJyArXG4gICAgICAgIGBNaW46ICR7SlNPTi5zdHJpbmdpZnkobWluKX1cXG5gICtcbiAgICAgICAgYE1heDogJHtKU09OLnN0cmluZ2lmeShtYXgpfVxcbmAgK1xuICAgICAgICBgVmFsdWU6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZ2l2ZW4geWVhciBpcyBhXG4gKiBsZWFwIHllYXIuIFJldHVybnMgYHRydWVgIGlmIHllYXJcbiAqIGlzIGEgbGVhcCB5ZWFyLiBSZXR1cm5zIGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqL1xuY29uc3QgaXNMZWFwWWVhciA9ICh5ZWFyKSA9PiB7XG4gIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbn07XG5jb25zdCBpczI0SG91ciA9IChsb2NhbGUsIGhvdXJDeWNsZSkgPT4ge1xuICAvKipcbiAgICogSWYgZGV2ZWxvcGVyIGhhcyBleHBsaWNpdGx5IGVuYWJsZWQgaDIzIHRpbWVcbiAgICogdGhlbiByZXR1cm4gZWFybHkgYW5kIGRvIG5vdCBsb29rIGF0IHRoZSBzeXN0ZW0gZGVmYXVsdC5cbiAgICovXG4gIGlmIChob3VyQ3ljbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBob3VyQ3ljbGUgPT09ICdoMjMnO1xuICB9XG4gIC8qKlxuICAgKiBJZiBob3VyQ3ljbGUgd2FzIG5vdCBzcGVjaWZpZWQsIGNoZWNrIHRoZSBsb2NhbGVcbiAgICogdGhhdCBpcyBzZXQgb24gdGhlIHVzZXIncyBkZXZpY2UuIFdlIGZpcnN0IGNoZWNrIHRoZVxuICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IGhvdXJDeWNsZSBvcHRpb24gYXMgZGV2ZWxvcGVycyBjYW4gZW5jb2RlIHRoaXNcbiAgICogb3B0aW9uIGludG8gdGhlIGxvY2FsZSBzdHJpbmcuIEV4YW1wbGU6IGBlbi1VUy11LWhjLWgyM2BcbiAgICovXG4gIGNvbnN0IGZvcm1hdHRlZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgeyBob3VyOiAnbnVtZXJpYycgfSk7XG4gIGNvbnN0IG9wdGlvbnMgPSBmb3JtYXR0ZWQucmVzb2x2ZWRPcHRpb25zKCk7XG4gIGlmIChvcHRpb25zLmhvdXJDeWNsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuaG91ckN5Y2xlID09PSAnaDIzJztcbiAgfVxuICAvKipcbiAgICogSWYgaG91ckN5Y2xlIGlzIG5vdCBzcGVjaWZpZWQgKGVpdGhlciB0aHJvdWdoIGxhY2tcbiAgICogb2YgYnJvd3NlciBzdXBwb3J0IG9yIGxvY2FsZSBpbmZvcm1hdGlvbikgdGhlbiBmYWxsXG4gICAqIGJhY2sgdG8gdGhpcyBzbG93ZXIgaG91ckN5Y2xlIGNoZWNrLlxuICAgKi9cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCc1LzE4LzIwMjEgMDA6MDAnKTtcbiAgY29uc3QgcGFydHMgPSBmb3JtYXR0ZWQuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgaG91ciA9IHBhcnRzLmZpbmQoKHApID0+IHAudHlwZSA9PT0gJ2hvdXInKTtcbiAgaWYgKCFob3VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdIb3VyIHZhbHVlIG5vdCBmb3VuZCBmcm9tIERhdGVUaW1lRm9ybWF0Jyk7XG4gIH1cbiAgcmV0dXJuIGhvdXIudmFsdWUgPT09ICcwMCc7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGRhdGUgb2JqZWN0LCByZXR1cm5zIHRoZSBudW1iZXJcbiAqIG9mIGRheXMgaW4gdGhhdCBtb250aC5cbiAqIE1vbnRoIHZhbHVlIGJlZ2luIGF0IDEsIG5vdCAwLlxuICogaS5lLiBKYW51YXJ5ID0gbW9udGggMS5cbiAqL1xuY29uc3QgZ2V0TnVtRGF5c0luTW9udGggPSAobW9udGgsIHllYXIpID0+IHtcbiAgcmV0dXJuIG1vbnRoID09PSA0IHx8IG1vbnRoID09PSA2IHx8IG1vbnRoID09PSA5IHx8IG1vbnRoID09PSAxMVxuICAgID8gMzBcbiAgICA6IG1vbnRoID09PSAyXG4gICAgICA/IGlzTGVhcFllYXIoeWVhcilcbiAgICAgICAgPyAyOVxuICAgICAgICA6IDI4XG4gICAgICA6IDMxO1xufTtcbi8qKlxuICogQ2VydGFpbiBsb2NhbGVzIGRpc3BsYXkgbW9udGggdGhlbiB5ZWFyIHdoaWxlXG4gKiBvdGhlcnMgZGlzcGxheSB5ZWFyIHRoZW4gbW9udGguXG4gKiBXZSBjYW4gdXNlIEludGwuRGF0ZVRpbWVGb3JtYXQgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgb3JkZXJpbmcgZm9yIGVhY2ggbG9jYWxlLlxuICogVGhlIGZvcm1hdE9wdGlvbnMgcGFyYW0gY2FuIGJlIHVzZWQgdG8gY3VzdG9taXplXG4gKiB3aGljaCBwaWVjZXMgb2YgYSBkYXRlIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgbW9udGhcbiAqIHdpdGguIEZvciBleGFtcGxlLCBzb21lIGxvY2FsZXMgcmVuZGVyIGRkL21tL3l5eXlcbiAqIHdoaWxlIG90aGVycyByZW5kZXIgbW0vZGQveXl5eS4gVGhpcyBmdW5jdGlvbiBjYW4gYmVcbiAqIHVzZWQgZm9yIHZhcmlhdGlvbnMgb2YgdGhlIHNhbWUgXCJtb250aCBmaXJzdFwiIGNoZWNrLlxuICovXG5jb25zdCBpc01vbnRoRmlyc3RMb2NhbGUgPSAobG9jYWxlLCBmb3JtYXRPcHRpb25zID0ge1xuICBtb250aDogJ251bWVyaWMnLFxuICB5ZWFyOiAnbnVtZXJpYycsXG59KSA9PiB7XG4gIC8qKlxuICAgKiBCeSBzZXR0aW5nIG1vbnRoIGFuZCB5ZWFyIHdlIGd1YXJhbnRlZSB0aGF0IG9ubHlcbiAgICogbW9udGgsIHllYXIsIGFuZCBsaXRlcmFsIChzbGFzaGVzICcvJywgZm9yIGV4YW1wbGUpXG4gICAqIHZhbHVlcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGZvcm1hdFRvUGFydHMgcmVzdWx0cy5cbiAgICpcbiAgICogVGhlIG9yZGVyaW5nIG9mIHRoZSBwYXJ0cyB3aWxsIGJlIGRldGVybWluZWQgYnlcbiAgICogdGhlIGxvY2FsZS4gU28gaWYgdGhlIG1vbnRoIGlzIHRoZSBmaXJzdCB2YWx1ZSxcbiAgICogdGhlbiB3ZSBrbm93IG1vbnRoIHNob3VsZCBiZSBzaG93biBmaXJzdC4gSWYgdGhlXG4gICAqIHllYXIgaXMgdGhlIGZpcnN0IHZhbHVlLCB0aGVuIHdlIGtub3cgeWVhciBzaG91bGQgYmUgc2hvd24gZmlyc3QuXG4gICAqXG4gICAqIFRoaXMgb3JkZXJpbmcgY2FuIGJlIGNvbnRyb2xsZWQgYnkgY3VzdG9taXppbmcgdGhlIGxvY2FsZSBwcm9wZXJ0eS5cbiAgICovXG4gIGNvbnN0IHBhcnRzID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBmb3JtYXRPcHRpb25zKS5mb3JtYXRUb1BhcnRzKG5ldyBEYXRlKCkpO1xuICByZXR1cm4gcGFydHNbMF0udHlwZSA9PT0gJ21vbnRoJztcbn07XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGxvY2FsZSBmb3JtYXRzIHRoZSBkYXkgcGVyaW9kIChhbS9wbSkgdG8gdGhlXG4gKiBsZWZ0IG9yIHJpZ2h0IG9mIHRoZSBob3VyLlxuICogQHBhcmFtIGxvY2FsZSBUaGUgbG9jYWxlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBsb2NhbGUgZm9ybWF0cyB0aGUgZGF5IHBlcmlvZCB0byB0aGUgbGVmdCBvZiB0aGUgaG91ci5cbiAqL1xuY29uc3QgaXNMb2NhbGVEYXlQZXJpb2RSVEwgPSAobG9jYWxlKSA9PiB7XG4gIGNvbnN0IHBhcnRzID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IGhvdXI6ICdudW1lcmljJyB9KS5mb3JtYXRUb1BhcnRzKG5ldyBEYXRlKCkpO1xuICByZXR1cm4gcGFydHNbMF0udHlwZSA9PT0gJ2RheVBlcmlvZCc7XG59O1xuXG5jb25zdCB0d29EaWdpdCA9ICh2YWwpID0+IHtcbiAgcmV0dXJuICgnMCcgKyAodmFsICE9PSB1bmRlZmluZWQgPyBNYXRoLmFicyh2YWwpIDogJzAnKSkuc2xpY2UoLTIpO1xufTtcbmNvbnN0IGZvdXJEaWdpdCA9ICh2YWwpID0+IHtcbiAgcmV0dXJuICgnMDAwJyArICh2YWwgIT09IHVuZGVmaW5lZCA/IE1hdGguYWJzKHZhbCkgOiAnMCcpKS5zbGljZSgtNCk7XG59O1xuZnVuY3Rpb24gY29udmVydERhdGFUb0lTTyhkYXRhKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGEubWFwKChwYXJ0cykgPT4gY29udmVydERhdGFUb0lTTyhwYXJ0cykpO1xuICB9XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9OT1RFLWRhdGV0aW1lXG4gIGxldCBydG4gPSAnJztcbiAgaWYgKGRhdGEueWVhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gWVlZWVxuICAgIHJ0biA9IGZvdXJEaWdpdChkYXRhLnllYXIpO1xuICAgIGlmIChkYXRhLm1vbnRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFlZWVktTU1cbiAgICAgIHJ0biArPSAnLScgKyB0d29EaWdpdChkYXRhLm1vbnRoKTtcbiAgICAgIGlmIChkYXRhLmRheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFlZWVktTU0tRERcbiAgICAgICAgcnRuICs9ICctJyArIHR3b0RpZ2l0KGRhdGEuZGF5KTtcbiAgICAgICAgaWYgKGRhdGEuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gWVlZWS1NTS1ERFRISDptbTpTU1xuICAgICAgICAgIHJ0biArPSBgVCR7dHdvRGlnaXQoZGF0YS5ob3VyKX06JHt0d29EaWdpdChkYXRhLm1pbnV0ZSl9OjAwYDtcbiAgICAgICAgICBpZiAoZGF0YS50ek9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBZWVlZLU1NLUREVEhIOm1tOlNTWlxuICAgICAgICAgICAgcnRuICs9ICdaJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBZWVlZLU1NLUREVEhIOm1tOlNTKy8tSEg6bW1cbiAgICAgICAgICAgIHJ0biArPVxuICAgICAgICAgICAgICAoZGF0YS50ek9mZnNldCA+IDAgPyAnKycgOiAnLScpICtcbiAgICAgICAgICAgICAgICB0d29EaWdpdChNYXRoLmZsb29yKE1hdGguYWJzKGRhdGEudHpPZmZzZXQgLyA2MCkpKSArXG4gICAgICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgICAgICB0d29EaWdpdChkYXRhLnR6T2Zmc2V0ICUgNjApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIGlmIChkYXRhLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEhIOm1tXG4gICAgcnRuID0gdHdvRGlnaXQoZGF0YS5ob3VyKSArICc6JyArIHR3b0RpZ2l0KGRhdGEubWludXRlKTtcbiAgfVxuICByZXR1cm4gcnRuO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiAxMiBob3VyIHZhbHVlIHRvIDI0IGhvdXJzLlxuICovXG5jb25zdCBjb252ZXJ0MTJIb3VyVG8yNEhvdXIgPSAoaG91ciwgYW1wbSkgPT4ge1xuICBpZiAoYW1wbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhvdXI7XG4gIH1cbiAgLyoqXG4gICAqIElmIEFNIGFuZCAxMmFtXG4gICAqIHRoZW4gcmV0dXJuIDAwOjAwLlxuICAgKiBPdGhlcndpc2UganVzdCByZXR1cm5cbiAgICogdGhlIGhvdXIgc2luY2UgaXQgaXNcbiAgICogYWxyZWFkeSBpbiAyNCBob3VyIGZvcm1hdC5cbiAgICovXG4gIGlmIChhbXBtID09PSAnYW0nKSB7XG4gICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGhvdXI7XG4gIH1cbiAgLyoqXG4gICAqIElmIFBNIGFuZCAxMnBtXG4gICAqIGp1c3QgcmV0dXJuIDEyOjAwXG4gICAqIHNpbmNlIGl0IGlzIGFscmVhZHlcbiAgICogaW4gMjQgaG91ciBmb3JtYXQuXG4gICAqIE90aGVyd2lzZSBhZGQgMTIgaG91cnNcbiAgICogdG8gdGhlIHRpbWUuXG4gICAqL1xuICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICByZXR1cm4gMTI7XG4gIH1cbiAgcmV0dXJuIGhvdXIgKyAxMjtcbn07XG5jb25zdCBnZXRTdGFydE9mV2VlayA9IChyZWZQYXJ0cykgPT4ge1xuICBjb25zdCB7IGRheU9mV2VlayB9ID0gcmVmUGFydHM7XG4gIGlmIChkYXlPZldlZWsgPT09IG51bGwgfHwgZGF5T2ZXZWVrID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRheSBvZiB3ZWVrIHByb3ZpZGVkJyk7XG4gIH1cbiAgcmV0dXJuIHN1YnRyYWN0RGF5cyhyZWZQYXJ0cywgZGF5T2ZXZWVrKTtcbn07XG5jb25zdCBnZXRFbmRPZldlZWsgPSAocmVmUGFydHMpID0+IHtcbiAgY29uc3QgeyBkYXlPZldlZWsgfSA9IHJlZlBhcnRzO1xuICBpZiAoZGF5T2ZXZWVrID09PSBudWxsIHx8IGRheU9mV2VlayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXkgb2Ygd2VlayBwcm92aWRlZCcpO1xuICB9XG4gIHJldHVybiBhZGREYXlzKHJlZlBhcnRzLCA2IC0gZGF5T2ZXZWVrKTtcbn07XG5jb25zdCBnZXROZXh0RGF5ID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBhZGREYXlzKHJlZlBhcnRzLCAxKTtcbn07XG5jb25zdCBnZXRQcmV2aW91c0RheSA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gc3VidHJhY3REYXlzKHJlZlBhcnRzLCAxKTtcbn07XG5jb25zdCBnZXRQcmV2aW91c1dlZWsgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIHN1YnRyYWN0RGF5cyhyZWZQYXJ0cywgNyk7XG59O1xuY29uc3QgZ2V0TmV4dFdlZWsgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGFkZERheXMocmVmUGFydHMsIDcpO1xufTtcbi8qKlxuICogR2l2ZW4gZGF0ZXRpbWUgcGFydHMsIHN1YnRyYWN0XG4gKiBudW1EYXlzIGZyb20gdGhlIGRhdGUuXG4gKiBSZXR1cm5zIGEgbmV3IERhdGV0aW1lUGFydHMgb2JqZWN0XG4gKiBDdXJyZW50bHkgY2FuIG9ubHkgZ28gYmFja3dhcmQgYXQgbW9zdCAxIG1vbnRoLlxuICovXG5jb25zdCBzdWJ0cmFjdERheXMgPSAocmVmUGFydHMsIG51bURheXMpID0+IHtcbiAgY29uc3QgeyBtb250aCwgZGF5LCB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgaWYgKGRheSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF5IHByb3ZpZGVkJyk7XG4gIH1cbiAgY29uc3Qgd29ya2luZ1BhcnRzID0ge1xuICAgIG1vbnRoLFxuICAgIGRheSxcbiAgICB5ZWFyLFxuICB9O1xuICB3b3JraW5nUGFydHMuZGF5ID0gZGF5IC0gbnVtRGF5cztcbiAgLyoqXG4gICAqIElmIHdyYXBwaW5nIHRvIHByZXZpb3VzIG1vbnRoXG4gICAqIHVwZGF0ZSBkYXlzIGFuZCBkZWNyZW1lbnQgbW9udGhcbiAgICovXG4gIGlmICh3b3JraW5nUGFydHMuZGF5IDwgMSkge1xuICAgIHdvcmtpbmdQYXJ0cy5tb250aCAtPSAxO1xuICB9XG4gIC8qKlxuICAgKiBJZiBtb3ZpbmcgdG8gcHJldmlvdXMgeWVhciwgcmVzZXRcbiAgICogbW9udGggdG8gRGVjZW1iZXIgYW5kIGRlY3JlbWVudCB5ZWFyXG4gICAqL1xuICBpZiAod29ya2luZ1BhcnRzLm1vbnRoIDwgMSkge1xuICAgIHdvcmtpbmdQYXJ0cy5tb250aCA9IDEyO1xuICAgIHdvcmtpbmdQYXJ0cy55ZWFyIC09IDE7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZSBob3cgbWFueSBkYXlzIGFyZSBpbiB0aGUgY3VycmVudFxuICAgKiBtb250aFxuICAgKi9cbiAgaWYgKHdvcmtpbmdQYXJ0cy5kYXkgPCAxKSB7XG4gICAgY29uc3QgZGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aCh3b3JraW5nUGFydHMubW9udGgsIHdvcmtpbmdQYXJ0cy55ZWFyKTtcbiAgICAvKipcbiAgICAgKiBUYWtlIG51bSBkYXlzIGluIG1vbnRoIGFuZCBhZGQgdGhlXG4gICAgICogbnVtYmVyIG9mIHVuZGVyZmxvdyBkYXlzLiBUaGlzIG51bWJlciB3aWxsXG4gICAgICogYmUgbmVnYXRpdmUuXG4gICAgICogRXhhbXBsZTogMSB3ZWVrIGJlZm9yZSBKYW4gMiwgMjAyMSBpc1xuICAgICAqIERlY2VtYmVyIDI2LCAyMDIxIHNvOlxuICAgICAqIDIgLSA3ID0gLTVcbiAgICAgKiAzMSArICgtNSkgPSAyNlxuICAgICAqL1xuICAgIHdvcmtpbmdQYXJ0cy5kYXkgPSBkYXlzSW5Nb250aCArIHdvcmtpbmdQYXJ0cy5kYXk7XG4gIH1cbiAgcmV0dXJuIHdvcmtpbmdQYXJ0cztcbn07XG4vKipcbiAqIEdpdmVuIGRhdGV0aW1lIHBhcnRzLCBhZGRcbiAqIG51bURheXMgdG8gdGhlIGRhdGUuXG4gKiBSZXR1cm5zIGEgbmV3IERhdGV0aW1lUGFydHMgb2JqZWN0XG4gKiBDdXJyZW50bHkgY2FuIG9ubHkgZ28gZm9yd2FyZCBhdCBtb3N0IDEgbW9udGguXG4gKi9cbmNvbnN0IGFkZERheXMgPSAocmVmUGFydHMsIG51bURheXMpID0+IHtcbiAgY29uc3QgeyBtb250aCwgZGF5LCB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgaWYgKGRheSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF5IHByb3ZpZGVkJyk7XG4gIH1cbiAgY29uc3Qgd29ya2luZ1BhcnRzID0ge1xuICAgIG1vbnRoLFxuICAgIGRheSxcbiAgICB5ZWFyLFxuICB9O1xuICBjb25zdCBkYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgd29ya2luZ1BhcnRzLmRheSA9IGRheSArIG51bURheXM7XG4gIC8qKlxuICAgKiBJZiB3cmFwcGluZyB0byBuZXh0IG1vbnRoXG4gICAqIHVwZGF0ZSBkYXlzIGFuZCBpbmNyZW1lbnQgbW9udGhcbiAgICovXG4gIGlmICh3b3JraW5nUGFydHMuZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICB3b3JraW5nUGFydHMuZGF5IC09IGRheXNJbk1vbnRoO1xuICAgIHdvcmtpbmdQYXJ0cy5tb250aCArPSAxO1xuICB9XG4gIC8qKlxuICAgKiBJZiBtb3ZpbmcgdG8gbmV4dCB5ZWFyLCByZXNldFxuICAgKiBtb250aCB0byBKYW51YXJ5IGFuZCBpbmNyZW1lbnQgeWVhclxuICAgKi9cbiAgaWYgKHdvcmtpbmdQYXJ0cy5tb250aCA+IDEyKSB7XG4gICAgd29ya2luZ1BhcnRzLm1vbnRoID0gMTtcbiAgICB3b3JraW5nUGFydHMueWVhciArPSAxO1xuICB9XG4gIHJldHVybiB3b3JraW5nUGFydHM7XG59O1xuLyoqXG4gKiBHaXZlbiBEYXRldGltZVBhcnRzLCBnZW5lcmF0ZSB0aGUgcHJldmlvdXMgbW9udGguXG4gKi9cbmNvbnN0IGdldFByZXZpb3VzTW9udGggPSAocmVmUGFydHMpID0+IHtcbiAgLyoqXG4gICAqIElmIGN1cnJlbnQgbW9udGggaXMgSmFudWFyeSwgd3JhcCBiYWNrd2FyZHNcbiAgICogIHRvIERlY2VtYmVyIG9mIHRoZSBwcmV2aW91cyB5ZWFyLlxuICAgKi9cbiAgY29uc3QgbW9udGggPSByZWZQYXJ0cy5tb250aCA9PT0gMSA/IDEyIDogcmVmUGFydHMubW9udGggLSAxO1xuICBjb25zdCB5ZWFyID0gcmVmUGFydHMubW9udGggPT09IDEgPyByZWZQYXJ0cy55ZWFyIC0gMSA6IHJlZlBhcnRzLnllYXI7XG4gIGNvbnN0IG51bURheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICBjb25zdCBkYXkgPSBudW1EYXlzSW5Nb250aCA8IHJlZlBhcnRzLmRheSA/IG51bURheXNJbk1vbnRoIDogcmVmUGFydHMuZGF5O1xuICByZXR1cm4geyBtb250aCwgeWVhciwgZGF5IH07XG59O1xuLyoqXG4gKiBHaXZlbiBEYXRldGltZVBhcnRzLCBnZW5lcmF0ZSB0aGUgbmV4dCBtb250aC5cbiAqL1xuY29uc3QgZ2V0TmV4dE1vbnRoID0gKHJlZlBhcnRzKSA9PiB7XG4gIC8qKlxuICAgKiBJZiBjdXJyZW50IG1vbnRoIGlzIERlY2VtYmVyLCB3cmFwIGZvcndhcmRzXG4gICAqICB0byBKYW51YXJ5IG9mIHRoZSBuZXh0IHllYXIuXG4gICAqL1xuICBjb25zdCBtb250aCA9IHJlZlBhcnRzLm1vbnRoID09PSAxMiA/IDEgOiByZWZQYXJ0cy5tb250aCArIDE7XG4gIGNvbnN0IHllYXIgPSByZWZQYXJ0cy5tb250aCA9PT0gMTIgPyByZWZQYXJ0cy55ZWFyICsgMSA6IHJlZlBhcnRzLnllYXI7XG4gIGNvbnN0IG51bURheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICBjb25zdCBkYXkgPSBudW1EYXlzSW5Nb250aCA8IHJlZlBhcnRzLmRheSA/IG51bURheXNJbk1vbnRoIDogcmVmUGFydHMuZGF5O1xuICByZXR1cm4geyBtb250aCwgeWVhciwgZGF5IH07XG59O1xuY29uc3QgY2hhbmdlWWVhciA9IChyZWZQYXJ0cywgeWVhckRlbHRhKSA9PiB7XG4gIGNvbnN0IG1vbnRoID0gcmVmUGFydHMubW9udGg7XG4gIGNvbnN0IHllYXIgPSByZWZQYXJ0cy55ZWFyICsgeWVhckRlbHRhO1xuICBjb25zdCBudW1EYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgY29uc3QgZGF5ID0gbnVtRGF5c0luTW9udGggPCByZWZQYXJ0cy5kYXkgPyBudW1EYXlzSW5Nb250aCA6IHJlZlBhcnRzLmRheTtcbiAgcmV0dXJuIHsgbW9udGgsIHllYXIsIGRheSB9O1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIHByZXZpb3VzIHllYXIuXG4gKi9cbmNvbnN0IGdldFByZXZpb3VzWWVhciA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gY2hhbmdlWWVhcihyZWZQYXJ0cywgLTEpO1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIG5leHQgeWVhci5cbiAqL1xuY29uc3QgZ2V0TmV4dFllYXIgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGNoYW5nZVllYXIocmVmUGFydHMsIDEpO1xufTtcbi8qKlxuICogSWYgUE0sIHRoZW4gaW50ZXJuYWwgdmFsdWUgc2hvdWxkXG4gKiBiZSBjb252ZXJ0ZWQgdG8gMjQtaHIgdGltZS5cbiAqIERvZXMgbm90IGFwcGx5IHdoZW4gcHVibGljXG4gKiB2YWx1ZXMgYXJlIGFscmVhZHkgMjQtaHIgdGltZS5cbiAqL1xuY29uc3QgZ2V0SW50ZXJuYWxIb3VyVmFsdWUgPSAoaG91ciwgdXNlMjRIb3VyLCBhbXBtKSA9PiB7XG4gIGlmICh1c2UyNEhvdXIpIHtcbiAgICByZXR1cm4gaG91cjtcbiAgfVxuICByZXR1cm4gY29udmVydDEySG91clRvMjRIb3VyKGhvdXIsIGFtcG0pO1xufTtcbi8qKlxuICogVW5sZXNzIG90aGVyd2lzZSBzdGF0ZWQsIGFsbCBtb250aCB2YWx1ZXMgYXJlXG4gKiAxIGluZGV4ZWQgaW5zdGVhZCBvZiB0aGUgdHlwaWNhbCAwIGluZGV4IGluIEpTIERhdGUuXG4gKiBFeGFtcGxlOlxuICogICBKYW51YXJ5ID0gTW9udGggMCB3aGVuIHVzaW5nIEpTIERhdGVcbiAqICAgSmFudWFyeSA9IE1vbnRoIDEgd2hlbiB1c2luZyB0aGlzIGRhdGV0aW1lIHV0aWxcbiAqL1xuLyoqXG4gKiBHaXZlbiB0aGUgY3VycmVudCBkYXRldGltZSBwYXJ0cyBhbmQgYSBuZXcgQU0vUE0gdmFsdWVcbiAqIGNhbGN1bGF0ZSB3aGF0IHRoZSBob3VyIHNob3VsZCBiZSBpbiAyNC1ob3VyIHRpbWUgZm9ybWF0LlxuICogVXNlZCB3aGVuIHRvZ2dsaW5nIHRoZSBBTS9QTSBzZWdtZW50IHNpbmNlIHdlIHN0b3JlIG91ciBob3Vyc1xuICogaW4gMjQtaG91ciB0aW1lIGZvcm1hdCBpbnRlcm5hbGx5LlxuICovXG5jb25zdCBjYWxjdWxhdGVIb3VyRnJvbUFNUE0gPSAoY3VycmVudFBhcnRzLCBuZXdBTVBNKSA9PiB7XG4gIGNvbnN0IHsgYW1wbTogY3VycmVudEFNUE0sIGhvdXIgfSA9IGN1cnJlbnRQYXJ0cztcbiAgbGV0IG5ld0hvdXIgPSBob3VyO1xuICAvKipcbiAgICogSWYgZ29pbmcgZnJvbSBBTSAtLT4gUE0sIG5lZWQgdG8gdXBkYXRlIHRoZVxuICAgKlxuICAgKi9cbiAgaWYgKGN1cnJlbnRBTVBNID09PSAnYW0nICYmIG5ld0FNUE0gPT09ICdwbScpIHtcbiAgICBuZXdIb3VyID0gY29udmVydDEySG91clRvMjRIb3VyKG5ld0hvdXIsICdwbScpO1xuICAgIC8qKlxuICAgICAqIElmIGdvaW5nIGZyb20gUE0gLS0+IEFNXG4gICAgICovXG4gIH1cbiAgZWxzZSBpZiAoY3VycmVudEFNUE0gPT09ICdwbScgJiYgbmV3QU1QTSA9PT0gJ2FtJykge1xuICAgIG5ld0hvdXIgPSBNYXRoLmFicyhuZXdIb3VyIC0gMTIpO1xuICB9XG4gIHJldHVybiBuZXdIb3VyO1xufTtcbi8qKlxuICogVXBkYXRlcyBwYXJ0cyB0byBlbnN1cmUgdGhhdCBtb250aCBhbmQgZGF5XG4gKiB2YWx1ZXMgYXJlIHZhbGlkLiBGb3IgZGF5cyB0aGF0IGRvIG5vdCBleGlzdCxcbiAqIHRoZSBjbG9zZXN0IHZhbGlkIGRheSBpcyB1c2VkLlxuICovXG5jb25zdCB2YWxpZGF0ZVBhcnRzID0gKHBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMpID0+IHtcbiAgY29uc3QgeyBtb250aCwgZGF5LCB5ZWFyIH0gPSBwYXJ0cztcbiAgY29uc3QgcGFydHNDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFydHMpO1xuICBjb25zdCBudW1EYXlzID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICAvKipcbiAgICogSWYgdGhlIG1heCBudW1iZXIgb2YgZGF5c1xuICAgKiBpcyBncmVhdGVyIHRoYW4gdGhlIGRheSB3ZSB3YW50XG4gICAqIHRvIHNldCwgdXBkYXRlIHRoZSBEYXRldGltZVBhcnRzXG4gICAqIGRheSBmaWVsZCB0byBiZSB0aGUgbWF4IGRheXMuXG4gICAqL1xuICBpZiAoZGF5ICE9PSBudWxsICYmIG51bURheXMgPCBkYXkpIHtcbiAgICBwYXJ0c0NvcHkuZGF5ID0gbnVtRGF5cztcbiAgfVxuICAvKipcbiAgICogSWYgdmFsdWUgaXMgc2FtZSBkYXkgYXMgbWluIGRheSxcbiAgICogbWFrZSBzdXJlIHRoZSB0aW1lIHZhbHVlIGlzIGluIGJvdW5kcy5cbiAgICovXG4gIGlmIChtaW5QYXJ0cyAhPT0gdW5kZWZpbmVkICYmIGlzU2FtZURheShwYXJ0c0NvcHksIG1pblBhcnRzKSkge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBob3VyIGlzIG91dCBvZiBib3VuZHMsXG4gICAgICogdXBkYXRlIGJvdGggdGhlIGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKiBUaGlzIGlzIGRvbmUgc28gdGhhdCB0aGUgbmV3IHRpbWVcbiAgICAgKiBpcyBjbG9zZXN0IHRvIHdoYXQgdGhlIHVzZXIgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgaWYgKHBhcnRzQ29weS5ob3VyICE9PSB1bmRlZmluZWQgJiYgbWluUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocGFydHNDb3B5LmhvdXIgPCBtaW5QYXJ0cy5ob3VyKSB7XG4gICAgICAgIHBhcnRzQ29weS5ob3VyID0gbWluUGFydHMuaG91cjtcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSA9IG1pblBhcnRzLm1pbnV0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG9ubHkgdGhlIG1pbnV0ZSBpcyBvdXQgb2YgYm91bmRzLFxuICAgICAgICAgKiBzZXQgaXQgdG8gdGhlIG1pbiBtaW51dGUuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocGFydHNDb3B5LmhvdXIgPT09IG1pblBhcnRzLmhvdXIgJiZcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG1pblBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgPCBtaW5QYXJ0cy5taW51dGUpIHtcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSA9IG1pblBhcnRzLm1pbnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIElmIHZhbHVlIGlzIHNhbWUgZGF5IGFzIG1heCBkYXksXG4gICAqIG1ha2Ugc3VyZSB0aGUgdGltZSB2YWx1ZSBpcyBpbiBib3VuZHMuXG4gICAqL1xuICBpZiAobWF4UGFydHMgIT09IHVuZGVmaW5lZCAmJiBpc1NhbWVEYXkocGFydHMsIG1heFBhcnRzKSkge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBob3VyIGlzIG91dCBvZiBib3VuZHMsXG4gICAgICogdXBkYXRlIGJvdGggdGhlIGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKiBUaGlzIGlzIGRvbmUgc28gdGhhdCB0aGUgbmV3IHRpbWVcbiAgICAgKiBpcyBjbG9zZXN0IHRvIHdoYXQgdGhlIHVzZXIgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgaWYgKHBhcnRzQ29weS5ob3VyICE9PSB1bmRlZmluZWQgJiYgbWF4UGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocGFydHNDb3B5LmhvdXIgPiBtYXhQYXJ0cy5ob3VyKSB7XG4gICAgICAgIHBhcnRzQ29weS5ob3VyID0gbWF4UGFydHMuaG91cjtcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSA9IG1heFBhcnRzLm1pbnV0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG9ubHkgdGhlIG1pbnV0ZSBpcyBvdXQgb2YgYm91bmRzLFxuICAgICAgICAgKiBzZXQgaXQgdG8gdGhlIG1heCBtaW51dGUuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocGFydHNDb3B5LmhvdXIgPT09IG1heFBhcnRzLmhvdXIgJiZcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG1heFBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHBhcnRzQ29weS5taW51dGUgPiBtYXhQYXJ0cy5taW51dGUpIHtcbiAgICAgICAgcGFydHNDb3B5Lm1pbnV0ZSA9IG1heFBhcnRzLm1pbnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzQ29weTtcbn07XG5cbmNvbnN0IGdldEZvcm1hdHRlZERheVBlcmlvZCA9IChkYXlQZXJpb2QpID0+IHtcbiAgaWYgKGRheVBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBkYXlQZXJpb2QudG9VcHBlckNhc2UoKTtcbn07XG5jb25zdCBnZXRMb2NhbGl6ZWRUaW1lID0gKGxvY2FsZSwgcmVmUGFydHMsIHVzZTI0SG91cikgPT4ge1xuICBpZiAocmVmUGFydHMuaG91ciA9PT0gdW5kZWZpbmVkIHx8IHJlZlBhcnRzLm1pbnV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdJbnZhbGlkIFRpbWUnO1xuICB9XG4gIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgdGltZVpvbmU6ICdVVEMnLFxuICAgIC8qKlxuICAgICAqIFdlIHVzZSBob3VyQ3ljbGUgaGVyZSBpbnN0ZWFkIG9mIGhvdXIxMiBkdWUgdG86XG4gICAgICogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTM0NzMxNiZxPWhvdXIxMiZjYW49MlxuICAgICAqL1xuICAgIGhvdXJDeWNsZTogdXNlMjRIb3VyID8gJ2gyMycgOiAnaDEyJyxcbiAgfSkuZm9ybWF0KG5ldyBEYXRlKGNvbnZlcnREYXRhVG9JU08oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWZQYXJ0cyksIHsgXG4gICAgLy8gVE9ETzogRlctMTgzMSB3aWxsIHJlbW92ZSB0aGUgbmVlZCB0byBtYW51YWxseSBzZXQgdGhlIHR6T2Zmc2V0IHRvIHVuZGVmaW5lZFxuICAgIHR6T2Zmc2V0OiB1bmRlZmluZWQgfSkpKSk7XG59O1xuLyoqXG4gKiBBZGRzIHBhZGRpbmcgdG8gYSB0aW1lIHZhbHVlIHNvXG4gKiB0aGF0IGl0IGlzIGFsd2F5cyAyIGRpZ2l0cy5cbiAqL1xuY29uc3QgYWRkVGltZVBhZGRpbmcgPSAodmFsdWUpID0+IHtcbiAgY29uc3QgdmFsdWVUb1N0cmluZyA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGlmICh2YWx1ZVRvU3RyaW5nLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gdmFsdWVUb1N0cmluZztcbiAgfVxuICByZXR1cm4gYDAke3ZhbHVlVG9TdHJpbmd9YDtcbn07XG4vKipcbiAqIEZvcm1hdHMgMjQgaG91ciB0aW1lcyBzbyB0aGF0XG4gKiBpdCBhbHdheXMgaGFzIDIgZGlnaXRzLiBGb3JcbiAqIDEyIGhvdXIgdGltZXMgaXQgZW5zdXJlcyB0aGF0XG4gKiBob3VyIDAgaXMgZm9ybWF0dGVkIGFzICcxMicuXG4gKi9cbmNvbnN0IGdldEZvcm1hdHRlZEhvdXIgPSAoaG91ciwgdXNlMjRIb3VyKSA9PiB7XG4gIGlmICh1c2UyNEhvdXIpIHtcbiAgICByZXR1cm4gYWRkVGltZVBhZGRpbmcoaG91cik7XG4gIH1cbiAgLyoqXG4gICAqIElmIHVzaW5nIDEyIGhvdXJcbiAgICogZm9ybWF0LCBtYWtlIHN1cmUgaG91clxuICAgKiAwIGlzIGZvcm1hdHRlZCBhcyAnMTInLlxuICAgKi9cbiAgaWYgKGhvdXIgPT09IDApIHtcbiAgICByZXR1cm4gJzEyJztcbiAgfVxuICByZXR1cm4gaG91ci50b1N0cmluZygpO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFyaWEtbGFiZWwgdG8gYmUgcmVhZCBieSBzY3JlZW4gcmVhZGVyc1xuICogZ2l2ZW4gYSBsb2NhbCwgYSBkYXRlLCBhbmQgd2hldGhlciBvciBub3QgdGhhdCBkYXRlIGlzXG4gKiB0b2RheSdzIGRhdGUuXG4gKi9cbmNvbnN0IGdlbmVyYXRlRGF5QXJpYUxhYmVsID0gKGxvY2FsZSwgdG9kYXksIHJlZlBhcnRzKSA9PiB7XG4gIGlmIChyZWZQYXJ0cy5kYXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTU0vREQvWVlZWSB3aWxsIHJldHVybiBtaWRuaWdodCBpbiB0aGUgdXNlcidzIHRpbWV6b25lLlxuICAgKi9cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSBHTVQrMDAwMGApO1xuICBjb25zdCBsYWJlbFN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwge1xuICAgIHdlZWtkYXk6ICdsb25nJyxcbiAgICBtb250aDogJ2xvbmcnLFxuICAgIGRheTogJ251bWVyaWMnLFxuICAgIHRpbWVab25lOiAnVVRDJyxcbiAgfSkuZm9ybWF0KGRhdGUpO1xuICAvKipcbiAgICogSWYgZGF0ZSBpcyB0b2RheSwgcHJlcGVuZCBcIlRvZGF5XCIgc28gc2NyZWVuIHJlYWRlcnMgaW5kaWNhdGVcbiAgICogdGhhdCB0aGUgZGF0ZSBpcyB0b2RheS5cbiAgICovXG4gIHJldHVybiB0b2RheSA/IGBUb2RheSwgJHtsYWJlbFN0cmluZ31gIDogbGFiZWxTdHJpbmc7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBkYXkgb2YgdGhlIHdlZWssIG1vbnRoLCBhbmQgZGF5XG4gKiBVc2VkIGZvciB0aGUgaGVhZGVyIGluIE1EIG1vZGUuXG4gKi9cbmNvbnN0IGdldE1vbnRoQW5kRGF5ID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSBHTVQrMDAwMGApO1xuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJywgdGltZVpvbmU6ICdVVEMnIH0pLmZvcm1hdChkYXRlKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgbW9udGggbmFtZSBhbmQgZnVsbCB5ZWFyLlxuICogRXhhbXBsZTogTWF5IDIwMjFcbiAqL1xuY29uc3QgZ2V0TW9udGhBbmRZZWFyID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSBHTVQrMDAwMGApO1xuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IG1vbnRoOiAnbG9uZycsIHllYXI6ICdudW1lcmljJywgdGltZVpvbmU6ICdVVEMnIH0pLmZvcm1hdChkYXRlKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgc2hvcnQgbW9udGgsIG51bWVyaWMgZGF5LCBhbmQgZnVsbCB5ZWFyLlxuICogRXhhbXBsZTogQXByIDIyLCAyMDIxXG4gKi9cbmNvbnN0IGdldE1vbnRoRGF5QW5kWWVhciA9IChsb2NhbGUsIHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBnZXRMb2NhbGl6ZWREYXRlVGltZShsb2NhbGUsIHJlZlBhcnRzLCB7IG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0pO1xufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUgYW5kIGEgZGF0ZSBvYmplY3QsXG4gKiByZXR1cm4gYSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgaW5jbHVkZXNcbiAqIHRoZSBudW1lcmljIGRheS5cbiAqIE5vdGU6IFNvbWUgbGFuZ3VhZ2VzIHdpbGwgYWRkIGxpdGVyYWwgY2hhcmFjdGVyc1xuICogdG8gdGhlIGVuZC4gVGhpcyBmdW5jdGlvbiByZW1vdmVzIHRob3NlIGxpdGVyYWxzLlxuICogRXhhbXBsZTogMjlcbiAqL1xuY29uc3QgZ2V0RGF5ID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGdldExvY2FsaXplZERhdGVUaW1lUGFydHMobG9jYWxlLCByZWZQYXJ0cywgeyBkYXk6ICdudW1lcmljJyB9KS5maW5kKChvYmopID0+IG9iai50eXBlID09PSAnZGF5JykudmFsdWU7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSBhbmQgYSBkYXRlIG9iamVjdCxcbiAqIHJldHVybiBhIGZvcm1hdHRlZCBzdHJpbmcgdGhhdCBpbmNsdWRlc1xuICogdGhlIG51bWVyaWMgeWVhci5cbiAqIEV4YW1wbGU6IDIwMjJcbiAqL1xuY29uc3QgZ2V0WWVhciA9IChsb2NhbGUsIHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBnZXRMb2NhbGl6ZWREYXRlVGltZShsb2NhbGUsIHJlZlBhcnRzLCB7IHllYXI6ICdudW1lcmljJyB9KTtcbn07XG5jb25zdCBnZXROb3JtYWxpemVkRGF0ZSA9IChyZWZQYXJ0cykgPT4ge1xuICBjb25zdCB0aW1lU3RyaW5nID0gcmVmUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkICYmIHJlZlBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkID8gYCAke3JlZlBhcnRzLmhvdXJ9OiR7cmVmUGFydHMubWludXRlfWAgOiAnJztcbiAgcmV0dXJuIG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSR7dGltZVN0cmluZ30gR01UKzAwMDBgKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlLCBEYXRldGltZVBhcnRzLCBhbmQgb3B0aW9uc1xuICogZm9ybWF0IHRoZSBEYXRldGltZVBhcnRzIGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogYW5kIGxvY2FsZSBjb21iaW5hdGlvbi4gVGhpcyByZXR1cm5zIGEgc3RyaW5nLiBJZlxuICogeW91IHdhbnQgYW4gYXJyYXkgb2YgdGhlIGluZGl2aWR1YWwgcGllY2VzXG4gKiB0aGF0IG1ha2UgdXAgdGhlIGxvY2FsaXplZCBkYXRlIHN0cmluZywgdXNlXG4gKiBnZXRMb2NhbGl6ZWREYXRlVGltZVBhcnRzLlxuICovXG5jb25zdCBnZXRMb2NhbGl6ZWREYXRlVGltZSA9IChsb2NhbGUsIHJlZlBhcnRzLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBnZXROb3JtYWxpemVkRGF0ZShyZWZQYXJ0cyk7XG4gIHJldHVybiBnZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChkYXRlKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlLCBEYXRldGltZVBhcnRzLCBhbmQgb3B0aW9uc1xuICogZm9ybWF0IHRoZSBEYXRldGltZVBhcnRzIGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogYW5kIGxvY2FsZSBjb21iaW5hdGlvbi4gVGhpcyByZXR1cm5zIGFuIGFycmF5IG9mXG4gKiBlYWNoIHBpZWNlIG9mIHRoZSBkYXRlLlxuICovXG5jb25zdCBnZXRMb2NhbGl6ZWREYXRlVGltZVBhcnRzID0gKGxvY2FsZSwgcmVmUGFydHMsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZGF0ZSA9IGdldE5vcm1hbGl6ZWREYXRlKHJlZlBhcnRzKTtcbiAgcmV0dXJuIGdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbn07XG4vKipcbiAqIFdyYXBwZXIgZnVuY3Rpb24gZm9yIEludGwuRGF0ZVRpbWVGb3JtYXQuXG4gKiBBbGxvd3MgZGV2ZWxvcGVycyB0byBhcHBseSBhbiBhbGxvd2VkIGZvcm1hdCB0byBEYXRldGltZVBhcnRzLlxuICogVGhpcyBmdW5jdGlvbiBhbHNvIGhhcyBidWlsdCBpbiBzYWZlZ3VhcmRzIGZvciBvbGRlciBicm93c2VyIGJ1Z3NcbiAqIHdpdGggSW50bC5EYXRlVGltZUZvcm1hdC5cbiAqL1xuY29uc3QgZ2V0RGF0ZVRpbWVGb3JtYXQgPSAobG9jYWxlLCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKTtcbn07XG4vKipcbiAqIEdldHMgYSBsb2NhbGl6ZWQgdmVyc2lvbiBvZiBcIlRvZGF5XCJcbiAqIEZhbGxzIGJhY2sgdG8gXCJUb2RheVwiIGluIEVuZ2xpc2ggZm9yXG4gKiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IFJlbGF0aXZlVGltZUZvcm1hdC5cbiAqL1xuY29uc3QgZ2V0VG9kYXlMYWJlbCA9IChsb2NhbGUpID0+IHtcbiAgaWYgKCdSZWxhdGl2ZVRpbWVGb3JtYXQnIGluIEludGwpIHtcbiAgICBjb25zdCBsYWJlbCA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsb2NhbGUsIHsgbnVtZXJpYzogJ2F1dG8nIH0pLmZvcm1hdCgwLCAnZGF5Jyk7XG4gICAgcmV0dXJuIGxhYmVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbGFiZWwuc2xpY2UoMSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuICdUb2RheSc7XG4gIH1cbn07XG4vKipcbiAqIFdoZW4gY2FsbGluZyB0b0lTT1N0cmluZygpLCB0aGUgYnJvd3NlclxuICogd2lsbCBjb252ZXJ0IHRoZSBkYXRlIHRvIFVUQyB0aW1lIGJ5IGVpdGhlciBhZGRpbmdcbiAqIG9yIHN1YnRyYWN0aW5nIHRoZSB0aW1lIHpvbmUgb2Zmc2V0LlxuICogVG8gd29yayBhcm91bmQgdGhpcywgd2UgbmVlZCB0byBlaXRoZXIgYWRkXG4gKiBvciBzdWJ0cmFjdCB0aGUgdGltZSB6b25lIG9mZnNldCB0byB0aGUgRGF0ZVxuICogb2JqZWN0IHByaW9yIHRvIGNhbGxpbmcgdG9JU09TdHJpbmcoKS5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIGdldCBhbiBJU08gc3RyaW5nXG4gKiB0aGF0IGlzIGluIHRoZSB1c2VyJ3MgdGltZSB6b25lLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBUaW1lIHpvbmUgb2Zmc2V0IGlzIDI0MFxuICogTWVhbmluZzogVGhlIGJyb3dzZXIgbmVlZHMgdG8gYWRkIDI0MCBtaW51dGVzXG4gKiB0byB0aGUgRGF0ZSBvYmplY3QgdG8gZ2V0IFVUQyB0aW1lLlxuICogV2hhdCBJb25pYyBkb2VzOiBXZSBzdWJ0cmFjdCAyNDAgbWludXRlc1xuICogZnJvbSB0aGUgRGF0ZSBvYmplY3QuIFRoZSBicm93c2VyIHRoZW4gYWRkc1xuICogMjQwIG1pbnV0ZXMgaW4gdG9JU09TdHJpbmcoKS4gVGhlIHJlc3VsdFxuICogaXMgYSB0aW1lIHRoYXQgaXMgaW4gdGhlIHVzZXIncyB0aW1lIHpvbmVcbiAqIGFuZCBub3QgVVRDLlxuICpcbiAqIE5vdGU6IFNvbWUgdGltZXpvbmVzIGluY2x1ZGUgbWludXRlIGFkanVzdG1lbnRzXG4gKiBzdWNoIGFzIDMwIG9yIDQ1IG1pbnV0ZXMuIFRoaXMgaXMgd2h5IHdlIHVzZSBzZXRNaW51dGVzXG4gKiBpbnN0ZWFkIG9mIHNldEhvdXJzLlxuICogRXhhbXBsZTogSW5kaWEgU3RhbmRhcmQgVGltZVxuICogVGltZXpvbmUgb2Zmc2V0OiAtMzMwID0gLTUuNSBob3Vycy5cbiAqXG4gKiBMaXN0IG9mIHRpbWV6b25lcyB3aXRoIDMwIGFuZCA0NSBtaW51dGUgdGltZXpvbmVzOlxuICogaHR0cHM6Ly93d3cudGltZWFuZGRhdGUuY29tL3RpbWUvdGltZS16b25lcy1pbnRlcmVzdGluZy5odG1sXG4gKi9cbmNvbnN0IHJlbW92ZURhdGVUek9mZnNldCA9IChkYXRlKSA9PiB7XG4gIGNvbnN0IHR6T2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgLSB0ek9mZnNldCk7XG4gIHJldHVybiBkYXRlO1xufTtcbmNvbnN0IERBVEVfQU0gPSByZW1vdmVEYXRlVHpPZmZzZXQobmV3IERhdGUoJzIwMjJUMDE6MDAnKSk7XG5jb25zdCBEQVRFX1BNID0gcmVtb3ZlRGF0ZVR6T2Zmc2V0KG5ldyBEYXRlKCcyMDIyVDEzOjAwJykpO1xuLyoqXG4gKiBGb3JtYXRzIHRoZSBsb2NhbGUncyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRheSBwZXJpb2QgKGFtL3BtKSBmb3IgYSBnaXZlblxuICogcmVmIHBhcnRzIGRheSBwZXJpb2QuXG4gKlxuICogQHBhcmFtIGxvY2FsZSBUaGUgbG9jYWxlIHRvIGZvcm1hdCB0aGUgZGF5IHBlcmlvZCBpbi5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgZGF0ZSBzdHJpbmcsIGluIElTTyBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgbG9jYWxpemVkIGRheSBwZXJpb2QgKGFtL3BtKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdmFsdWUuXG4gKi9cbmNvbnN0IGdldExvY2FsaXplZERheVBlcmlvZCA9IChsb2NhbGUsIGRheVBlcmlvZCkgPT4ge1xuICBjb25zdCBkYXRlID0gZGF5UGVyaW9kID09PSAnYW0nID8gREFURV9BTSA6IERBVEVfUE07XG4gIGNvbnN0IGxvY2FsaXplZERheVBlcmlvZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwge1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICB0aW1lWm9uZTogJ1VUQycsXG4gIH0pXG4gICAgLmZvcm1hdFRvUGFydHMoZGF0ZSlcbiAgICAuZmluZCgocGFydCkgPT4gcGFydC50eXBlID09PSAnZGF5UGVyaW9kJyk7XG4gIGlmIChsb2NhbGl6ZWREYXlQZXJpb2QpIHtcbiAgICByZXR1cm4gbG9jYWxpemVkRGF5UGVyaW9kLnZhbHVlO1xuICB9XG4gIHJldHVybiBnZXRGb3JtYXR0ZWREYXlQZXJpb2QoZGF5UGVyaW9kKTtcbn07XG4vKipcbiAqIEZvcm1hdHMgdGhlIGRhdGV0aW1lJ3MgdmFsdWUgdG8gYSBzdHJpbmcsIGZvciB1c2UgaW4gdGhlIG5hdGl2ZSBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGZvcm1hdCwgZWl0aGVyIGFuIElTTyBzdHJpbmcgb3IgYW4gYXJyYXkgdGhlcmVvZi5cbiAqL1xuY29uc3QgZm9ybWF0VmFsdWUgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCcpIDogdmFsdWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgZGF0ZSBhc1xuICogYW4gSVNPIHN0cmluZyBpbiB0aGUgdXNlcidzXG4gKiB0aW1lIHpvbmUuXG4gKi9cbmNvbnN0IGdldFRvZGF5ID0gKCkgPT4ge1xuICAvKipcbiAgICogaW9uLWRhdGV0aW1lIGludGVudGlvbmFsbHkgZG9lcyBub3RcbiAgICogcGFyc2UgdGltZSB6b25lcy9kbyBhdXRvbWF0aWMgdGltZSB6b25lXG4gICAqIGNvbnZlcnNpb24gd2hlbiBhY2NlcHRpbmcgdXNlciBpbnB1dC5cbiAgICogSG93ZXZlciB3aGVuIHdlIGdldCB0b2RheSdzIGRhdGUgc3RyaW5nLFxuICAgKiB3ZSB3YW50IGl0IGZvcm1hdHRlZCByZWxhdGl2ZSB0byB0aGUgdXNlcidzXG4gICAqIHRpbWUgem9uZS5cbiAgICpcbiAgICogV2hlbiBjYWxsaW5nIHRvSVNPU3RyaW5nKCksIHRoZSBicm93c2VyXG4gICAqIHdpbGwgY29udmVydCB0aGUgZGF0ZSB0byBVVEMgdGltZSBieSBlaXRoZXIgYWRkaW5nXG4gICAqIG9yIHN1YnRyYWN0aW5nIHRoZSB0aW1lIHpvbmUgb2Zmc2V0LlxuICAgKiBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSBuZWVkIHRvIGVpdGhlciBhZGRcbiAgICogb3Igc3VidHJhY3QgdGhlIHRpbWUgem9uZSBvZmZzZXQgdG8gdGhlIERhdGVcbiAgICogb2JqZWN0IHByaW9yIHRvIGNhbGxpbmcgdG9JU09TdHJpbmcoKS5cbiAgICogVGhpcyBhbGxvd3MgdXMgdG8gZ2V0IGFuIElTTyBzdHJpbmdcbiAgICogdGhhdCBpcyBpbiB0aGUgdXNlcidzIHRpbWUgem9uZS5cbiAgICovXG4gIHJldHVybiByZW1vdmVEYXRlVHpPZmZzZXQobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKTtcbn07XG5jb25zdCBtaW51dGVzID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSxcbiAgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCwgNDEsIDQyLCA0MywgNDQsIDQ1LCA0NiwgNDcsIDQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksXG5dO1xuY29uc3QgaG91cjEyID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV07XG5jb25zdCBob3VyMjMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzXTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUgYW5kIGEgbW9kZSxcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGZvcm1hdHRlZCBkYXlzXG4gKiBvZiB0aGUgd2Vlay4gaU9TIHNob3VsZCBkaXNwbGF5IGRheXNcbiAqIHN1Y2ggYXMgXCJNb25cIiBvciBcIlR1ZVwiLlxuICogTUQgc2hvdWxkIGRpc3BsYXkgZGF5cyBzdWNoIGFzIFwiTVwiXG4gKiBvciBcIlRcIi5cbiAqL1xuY29uc3QgZ2V0RGF5c09mV2VlayA9IChsb2NhbGUsIG1vZGUsIGZpcnN0RGF5T2ZXZWVrID0gMCkgPT4ge1xuICAvKipcbiAgICogTm92IDFzdCwgMjAyMCBzdGFydHMgb24gYSBTdW5kYXkuXG4gICAqIGlvbi1kYXRldGltZSBhc3N1bWVzIHdlZWtzIHN0YXJ0IG9uIFN1bmRheSxcbiAgICogYnV0IGlzIGNvbmZpZ3VyYWJsZSB2aWEgYGZpcnN0RGF5T2ZXZWVrYC5cbiAgICovXG4gIGNvbnN0IHdlZWtkYXlGb3JtYXQgPSBtb2RlID09PSAnaW9zJyA/ICdzaG9ydCcgOiAnbmFycm93JztcbiAgY29uc3QgaW50bCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgeyB3ZWVrZGF5OiB3ZWVrZGF5Rm9ybWF0IH0pO1xuICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSgnMTEvMDEvMjAyMCcpO1xuICBjb25zdCBkYXlzT2ZXZWVrID0gW107XG4gIC8qKlxuICAgKiBGb3IgZWFjaCBkYXkgb2YgdGhlIHdlZWssXG4gICAqIGdldCB0aGUgZGF5IG5hbWUuXG4gICAqL1xuICBmb3IgKGxldCBpID0gZmlyc3REYXlPZldlZWs7IGkgPCBmaXJzdERheU9mV2VlayArIDc7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoc3RhcnREYXRlKTtcbiAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSArIGkpO1xuICAgIGRheXNPZldlZWsucHVzaChpbnRsLmZvcm1hdChjdXJyZW50RGF0ZSkpO1xuICB9XG4gIHJldHVybiBkYXlzT2ZXZWVrO1xufTtcbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGVcbiAqIGRheXMgaW4gYSBtb250aCBmb3IgYSBnaXZlbiB5ZWFyLiBWYWx1ZXMgYXJlXG4gKiBhbGlnbmVkIHdpdGggYSB3ZWVrIGNhbGVuZGFyIHN0YXJ0aW5nIG9uXG4gKiB0aGUgZmlyc3REYXlPZldlZWsgdmFsdWUgKFN1bmRheSBieSBkZWZhdWx0KVxuICogdXNpbmcgbnVsbCB2YWx1ZXMuXG4gKi9cbmNvbnN0IGdldERheXNPZk1vbnRoID0gKG1vbnRoLCB5ZWFyLCBmaXJzdERheU9mV2VlaykgPT4ge1xuICBjb25zdCBudW1EYXlzID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICBjb25zdCBmaXJzdE9mTW9udGggPSBuZXcgRGF0ZShgJHttb250aH0vMS8ke3llYXJ9YCkuZ2V0RGF5KCk7XG4gIC8qKlxuICAgKiBUbyBnZXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGggYWxpZ25lZCBvbiB0aGUgY29ycmVjdFxuICAgKiBkYXkgb2YgdGhlIHdlZWssIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IFwiZmlsbGVyXCIgZGF5c1xuICAgKiB0byBnZW5lcmF0ZS4gVGhlc2UgZmlsbGVyIGRheXMgYXMgZW1wdHkvZGlzYWJsZWQgYnV0dG9uc1xuICAgKiB0aGF0IGZpbGwgdGhlIHNwYWNlIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrIGJlZm9yZSB0aGUgZmlyc3RcbiAgICogb2YgdGhlIG1vbnRoLlxuICAgKlxuICAgKiBUaGVyZSBhcmUgdHdvIGNhc2VzIGhlcmU6XG4gICAqXG4gICAqIDEuIElmIGZpcnN0T2ZNb250aCA9IDQsIGZpcnN0RGF5T2ZXZWVrID0gMCB0aGVuIHRoZSBvZmZzZXRcbiAgICogaXMgKDQgLSAoMCArIDEpKSA9IDMuIFNpbmNlIHRoZSBvZmZzZXQgbG9vcCBnb2VzIGZyb20gMCB0byAzIGluY2x1c2l2ZSxcbiAgICogdGhpcyB3aWxsIGdlbmVyYXRlIDQgZmlsbGVyIGRheXMgKDAsIDEsIDIsIDMpLCBhbmQgdGhlbiBkYXkgb2Ygd2VlayA0IHdpbGwgaGF2ZVxuICAgKiB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aC5cbiAgICpcbiAgICogMi4gSWYgZmlyc3RPZk1vbnRoID0gMiwgZmlyc3REYXlPZldlZWsgPSA0IHRoZW4gdGhlIG9mZnNldFxuICAgKiBpcyAoNiAtICg0IC0gMikpID0gNC4gU2luY2UgdGhlIG9mZnNldCBsb29wIGdvZXMgZnJvbSAwIHRvIDQgaW5jbHVzaXZlLFxuICAgKiB0aGlzIHdpbGwgZ2VuZXJhdGUgNSBmaWxsZXIgZGF5cyAoMCwgMSwgMiwgMywgNCksIGFuZCB0aGVuIGRheSBvZiB3ZWVrIDUgd2lsbCBoYXZlXG4gICAqIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKi9cbiAgY29uc3Qgb2Zmc2V0ID0gZmlyc3RPZk1vbnRoID49IGZpcnN0RGF5T2ZXZWVrID8gZmlyc3RPZk1vbnRoIC0gKGZpcnN0RGF5T2ZXZWVrICsgMSkgOiA2IC0gKGZpcnN0RGF5T2ZXZWVrIC0gZmlyc3RPZk1vbnRoKTtcbiAgbGV0IGRheXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtRGF5czsgaSsrKSB7XG4gICAgZGF5cy5wdXNoKHsgZGF5OiBpLCBkYXlPZldlZWs6IChvZmZzZXQgKyBpKSAlIDcgfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gb2Zmc2V0OyBpKyspIHtcbiAgICBkYXlzID0gW3sgZGF5OiBudWxsLCBkYXlPZldlZWs6IG51bGwgfSwgLi4uZGF5c107XG4gIH1cbiAgcmV0dXJuIGRheXM7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsLCByZWZlcmVuY2UgZGF0ZXRpbWUgcGFydHMgYW5kIG9wdGlvblxuICogbWF4L21pbiBib3VuZCBkYXRldGltZSBwYXJ0cywgY2FsY3VsYXRlIHRoZSBhY2NlcHRhYmxlXG4gKiBob3VyIGFuZCBtaW51dGUgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgYm91bmRzIGFuZCBsb2NhbGUuXG4gKi9cbmNvbnN0IGdlbmVyYXRlVGltZSA9IChyZWZQYXJ0cywgaG91ckN5Y2xlID0gJ2gxMicsIG1pblBhcnRzLCBtYXhQYXJ0cywgaG91clZhbHVlcywgbWludXRlVmFsdWVzKSA9PiB7XG4gIGNvbnN0IHVzZTI0SG91ciA9IGhvdXJDeWNsZSA9PT0gJ2gyMyc7XG4gIGxldCBwcm9jZXNzZWRIb3VycyA9IHVzZTI0SG91ciA/IGhvdXIyMyA6IGhvdXIxMjtcbiAgbGV0IHByb2Nlc3NlZE1pbnV0ZXMgPSBtaW51dGVzO1xuICBsZXQgaXNBTUFsbG93ZWQgPSB0cnVlO1xuICBsZXQgaXNQTUFsbG93ZWQgPSB0cnVlO1xuICBpZiAoaG91clZhbHVlcykge1xuICAgIHByb2Nlc3NlZEhvdXJzID0gcHJvY2Vzc2VkSG91cnMuZmlsdGVyKChob3VyKSA9PiBob3VyVmFsdWVzLmluY2x1ZGVzKGhvdXIpKTtcbiAgfVxuICBpZiAobWludXRlVmFsdWVzKSB7XG4gICAgcHJvY2Vzc2VkTWludXRlcyA9IHByb2Nlc3NlZE1pbnV0ZXMuZmlsdGVyKChtaW51dGUpID0+IG1pbnV0ZVZhbHVlcy5pbmNsdWRlcyhtaW51dGUpKTtcbiAgfVxuICBpZiAobWluUGFydHMpIHtcbiAgICAvKipcbiAgICAgKiBJZiByZWYgZGF5IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAqIG1pbmltdW0gYWxsb3dlZCBkYXksIGZpbHRlciBob3VyL21pbnV0ZVxuICAgICAqIHZhbHVlcyBhY2NvcmRpbmcgdG8gbWluIGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKi9cbiAgICBpZiAoaXNTYW1lRGF5KHJlZlBhcnRzLCBtaW5QYXJ0cykpIHtcbiAgICAgIC8qKlxuICAgICAgICogVXNlcnMgbWF5IG5vdCBhbHdheXMgc2V0IHRoZSBob3VyL21pbnV0ZSBmb3JcbiAgICAgICAqIG1pbiB2YWx1ZSAoaS5lLiAyMDIxLTA2LTAyKSBzbyB3ZSBzaG91bGQgYWxsb3dcbiAgICAgICAqIGFsbCBob3Vycy9taW51dGVzIGluIHRoYXQgY2FzZS5cbiAgICAgICAqL1xuICAgICAgaWYgKG1pblBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9jZXNzZWRIb3VycyA9IHByb2Nlc3NlZEhvdXJzLmZpbHRlcigoaG91cikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZEhvdXIgPSByZWZQYXJ0cy5hbXBtID09PSAncG0nID8gKGhvdXIgKyAxMikgJSAyNCA6IGhvdXI7XG4gICAgICAgICAgcmV0dXJuICh1c2UyNEhvdXIgPyBob3VyIDogY29udmVydGVkSG91cikgPj0gbWluUGFydHMuaG91cjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlzQU1BbGxvd2VkID0gbWluUGFydHMuaG91ciA8IDEzO1xuICAgICAgfVxuICAgICAgaWYgKG1pblBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSBtaW51dGUgcmFuZ2Ugc2hvdWxkIG5vdCBiZSBlbmZvcmNlZCB3aGVuXG4gICAgICAgICAqIHRoZSBob3VyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWluIGhvdXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlIHdpdGggYSBtaW5pbXVtIHJhbmdlIG9mIDA5OjMwLCB1c2Vyc1xuICAgICAgICAgKiBzaG91bGQgYmUgYWJsZSB0byBzZWxlY3QgMTA6MDAtMTA6MjkgYW5kIGJleW9uZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBpc1Bhc3RNaW5Ib3VyID0gZmFsc2U7XG4gICAgICAgIGlmIChtaW5QYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQgJiYgcmVmUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlZlBhcnRzLmhvdXIgPiBtaW5QYXJ0cy5ob3VyKSB7XG4gICAgICAgICAgICBpc1Bhc3RNaW5Ib3VyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IHByb2Nlc3NlZE1pbnV0ZXMuZmlsdGVyKChtaW51dGUpID0+IHtcbiAgICAgICAgICBpZiAoaXNQYXN0TWluSG91cikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtaW51dGUgPj0gbWluUGFydHMubWludXRlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSWYgcmVmIGRheSBpcyBiZWZvcmUgbWluaW11bVxuICAgICAgICogZGF5IGRvIG5vdCByZW5kZXIgYW55IGhvdXJzL21pbnV0ZSB2YWx1ZXNcbiAgICAgICAqL1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JlZm9yZShyZWZQYXJ0cywgbWluUGFydHMpKSB7XG4gICAgICBwcm9jZXNzZWRIb3VycyA9IFtdO1xuICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IFtdO1xuICAgICAgaXNBTUFsbG93ZWQgPSBpc1BNQWxsb3dlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAobWF4UGFydHMpIHtcbiAgICAvKipcbiAgICAgKiBJZiByZWYgZGF5IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAqIG1heGltdW0gYWxsb3dlZCBkYXksIGZpbHRlciBob3VyL21pbnV0ZVxuICAgICAqIHZhbHVlcyBhY2NvcmRpbmcgdG8gbWF4IGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKi9cbiAgICBpZiAoaXNTYW1lRGF5KHJlZlBhcnRzLCBtYXhQYXJ0cykpIHtcbiAgICAgIC8qKlxuICAgICAgICogVXNlcnMgbWF5IG5vdCBhbHdheXMgc2V0IHRoZSBob3VyL21pbnV0ZSBmb3JcbiAgICAgICAqIG1heCB2YWx1ZSAoaS5lLiAyMDIxLTA2LTAyKSBzbyB3ZSBzaG91bGQgYWxsb3dcbiAgICAgICAqIGFsbCBob3Vycy9taW51dGVzIGluIHRoYXQgY2FzZS5cbiAgICAgICAqL1xuICAgICAgaWYgKG1heFBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9jZXNzZWRIb3VycyA9IHByb2Nlc3NlZEhvdXJzLmZpbHRlcigoaG91cikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZEhvdXIgPSByZWZQYXJ0cy5hbXBtID09PSAncG0nID8gKGhvdXIgKyAxMikgJSAyNCA6IGhvdXI7XG4gICAgICAgICAgcmV0dXJuICh1c2UyNEhvdXIgPyBob3VyIDogY29udmVydGVkSG91cikgPD0gbWF4UGFydHMuaG91cjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlzUE1BbGxvd2VkID0gbWF4UGFydHMuaG91ciA+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmIChtYXhQYXJ0cy5taW51dGUgIT09IHVuZGVmaW5lZCAmJiByZWZQYXJ0cy5ob3VyID09PSBtYXhQYXJ0cy5ob3VyKSB7XG4gICAgICAgIC8vIFRoZSBhdmFpbGFibGUgbWludXRlcyBzaG91bGQgb25seSBiZSBmaWx0ZXJlZCB3aGVuIHRoZSBob3VyIGlzIHRoZSBzYW1lIGFzIHRoZSBtYXggaG91ci5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUgaWYgdGhlIG1heCBob3VyIGlzIDEwOjMwIGFuZCB0aGUgY3VycmVudCBob3VyIGlzIDEwOjAwLFxuICAgICAgICAvLyB1c2VycyBzaG91bGQgYmUgYWJsZSB0byBzZWxlY3QgMDAtMzAgbWludXRlcy5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaG91ciBpcyAwOTowMCwgdXNlcnMgc2hvdWxkIGJlIGFibGUgdG8gc2VsZWN0IDAwLTYwIG1pbnV0ZXMuXG4gICAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBwcm9jZXNzZWRNaW51dGVzLmZpbHRlcigobWludXRlKSA9PiBtaW51dGUgPD0gbWF4UGFydHMubWludXRlKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSWYgcmVmIGRheSBpcyBhZnRlciBtaW5pbXVtXG4gICAgICAgKiBkYXkgZG8gbm90IHJlbmRlciBhbnkgaG91cnMvbWludXRlIHZhbHVlc1xuICAgICAgICovXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWZ0ZXIocmVmUGFydHMsIG1heFBhcnRzKSkge1xuICAgICAgcHJvY2Vzc2VkSG91cnMgPSBbXTtcbiAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBbXTtcbiAgICAgIGlzQU1BbGxvd2VkID0gaXNQTUFsbG93ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBob3VyczogcHJvY2Vzc2VkSG91cnMsXG4gICAgbWludXRlczogcHJvY2Vzc2VkTWludXRlcyxcbiAgICBhbTogaXNBTUFsbG93ZWQsXG4gICAgcG06IGlzUE1BbGxvd2VkLFxuICB9O1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIHByZXZpb3VzLFxuICogY3VycmVudCwgYW5kIGFuZCBuZXh0IG1vbnRocy5cbiAqL1xuY29uc3QgZ2VuZXJhdGVNb250aHMgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIFtcbiAgICBnZXRQcmV2aW91c01vbnRoKHJlZlBhcnRzKSxcbiAgICB7IG1vbnRoOiByZWZQYXJ0cy5tb250aCwgeWVhcjogcmVmUGFydHMueWVhciwgZGF5OiByZWZQYXJ0cy5kYXkgfSxcbiAgICBnZXROZXh0TW9udGgocmVmUGFydHMpLFxuICBdO1xufTtcbmNvbnN0IGdldE1vbnRoQ29sdW1uRGF0YSA9IChsb2NhbGUsIHJlZlBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMsIG1vbnRoVmFsdWVzLCBmb3JtYXRPcHRpb25zID0ge1xuICBtb250aDogJ2xvbmcnLFxufSkgPT4ge1xuICBjb25zdCB7IHllYXIgfSA9IHJlZlBhcnRzO1xuICBjb25zdCBtb250aHMgPSBbXTtcbiAgaWYgKG1vbnRoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcHJvY2Vzc2VkTW9udGhzID0gbW9udGhWYWx1ZXM7XG4gICAgaWYgKChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMubW9udGgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2Nlc3NlZE1vbnRocyA9IHByb2Nlc3NlZE1vbnRocy5maWx0ZXIoKG1vbnRoKSA9PiBtb250aCA8PSBtYXhQYXJ0cy5tb250aCk7XG4gICAgfVxuICAgIGlmICgobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLm1vbnRoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9jZXNzZWRNb250aHMgPSBwcm9jZXNzZWRNb250aHMuZmlsdGVyKChtb250aCkgPT4gbW9udGggPj0gbWluUGFydHMubW9udGgpO1xuICAgIH1cbiAgICBwcm9jZXNzZWRNb250aHMuZm9yRWFjaCgocHJvY2Vzc2VkTW9udGgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHtwcm9jZXNzZWRNb250aH0vMS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICBjb25zdCBtb250aFN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgIG1vbnRocy5wdXNoKHsgdGV4dDogbW9udGhTdHJpbmcsIHZhbHVlOiBwcm9jZXNzZWRNb250aCB9KTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb25zdCBtYXhNb250aCA9IG1heFBhcnRzICYmIG1heFBhcnRzLnllYXIgPT09IHllYXIgPyBtYXhQYXJ0cy5tb250aCA6IDEyO1xuICAgIGNvbnN0IG1pbk1vbnRoID0gbWluUGFydHMgJiYgbWluUGFydHMueWVhciA9PT0geWVhciA/IG1pblBhcnRzLm1vbnRoIDogMTtcbiAgICBmb3IgKGxldCBpID0gbWluTW9udGg7IGkgPD0gbWF4TW9udGg7IGkrKykge1xuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogVGhlcmUgaXMgYSBidWcgb24gaU9TIDE0IHdoZXJlXG4gICAgICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IHRha2VzIGludG8gYWNjb3VudFxuICAgICAgICogdGhlIGxvY2FsIHRpbWV6b25lIG9mZnNldCB3aGVuIGZvcm1hdHRpbmcgZGF0ZXMuXG4gICAgICAgKlxuICAgICAgICogRm9yY2luZyB0aGUgdGltZXpvbmUgdG8gJ1VUQycgZml4ZXMgdGhlIGlzc3VlLiBIb3dldmVyLFxuICAgICAgICogd2Ugc2hvdWxkIGtlZXAgdGhpcyB3b3JrYXJvdW5kIGFzIGl0IGlzIHNhZmVyLiBJbiB0aGUgZXZlbnRcbiAgICAgICAqIHRoaXMgYnJlYWtzIGluIGFub3RoZXIgYnJvd3Nlciwgd2Ugd2lsbCBub3QgYmUgaW1wYWN0ZWRcbiAgICAgICAqIGJlY2F1c2UgYWxsIGRhdGVzIHdpbGwgYmUgaW50ZXJwcmV0ZWQgaW4gVVRDLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgKiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7IG1vbnRoOiAnbG9uZycgfSkuZm9ybWF0KG5ldyBEYXRlKCdTYXQgQXByIDAxIDIwMDYgMDA6MDA6MDAgR01ULTA0MDAgKEVEVCknKSkgLy8gXCJNYXJjaFwiXG4gICAgICAgKiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7IG1vbnRoOiAnbG9uZycsIHRpbWVab25lOiAnVVRDJyB9KS5mb3JtYXQobmV3IERhdGUoJ1NhdCBBcHIgMDEgMjAwNiAwMDowMDowMCBHTVQtMDQwMCAoRURUKScpKSAvLyBcIkFwcmlsXCJcbiAgICAgICAqXG4gICAgICAgKiBJbiBjZXJ0YWluIHRpbWV6b25lcywgaU9TIDE0IHNob3dzIHRoZSB3cm9uZ1xuICAgICAgICogZGF0ZSBmb3IgLnRvVVRDU3RyaW5nKCkuIFRvIGNvbWJhdCB0aGlzLCB3ZVxuICAgICAgICogZm9yY2UgYWxsIG9mIHRoZSB0aW1lem9uZXMgdG8gR01UKzAwMDAgKFVUQykuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTpcbiAgICAgICAqIFRpbWUgWm9uZTogQ2VudHJhbCBFdXJvcGVhbiBTdGFuZGFyZCBUaW1lXG4gICAgICAgKiBuZXcgRGF0ZSgnMS8xLzE5OTInKS50b1VUQ1N0cmluZygpIC8vIFwiVHVlLCAzMSBEZWMgMTk5MSAyMzowMDowMCBHTVRcIlxuICAgICAgICogbmV3IERhdGUoJzEvMS8xOTkyIEdNVCswMDAwJykudG9VVENTdHJpbmcoKSAvLyBcIldlZCwgMDEgSmFuIDE5OTIgMDA6MDA6MDAgR01UXCJcbiAgICAgICAqL1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke2l9LzEvJHt5ZWFyfSBHTVQrMDAwMGApO1xuICAgICAgY29uc3QgbW9udGhTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0T3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKS5mb3JtYXQoZGF0ZSk7XG4gICAgICBtb250aHMucHVzaCh7IHRleHQ6IG1vbnRoU3RyaW5nLCB2YWx1ZTogaSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vbnRocztcbn07XG4vKipcbiAqIFJldHVybnMgaW5mb3JtYXRpb24gcmVnYXJkaW5nXG4gKiBzZWxlY3RhYmxlIGRhdGVzIChpLmUgMXN0LCAybmQsIDNyZCwgZXRjKVxuICogd2l0aGluIGEgcmVmZXJlbmNlIG1vbnRoLlxuICogQHBhcmFtIGxvY2FsZSBUaGUgbG9jYWxlIHRvIGZvcm1hdCB0aGUgZGF0ZSB3aXRoXG4gKiBAcGFyYW0gcmVmUGFydHMgVGhlIHJlZmVyZW5jZSBtb250aC95ZWFyIHRvIGdlbmVyYXRlIGRhdGVzIGZvclxuICogQHBhcmFtIG1pblBhcnRzIFRoZSBtaW5pbXVtIGJvdW5kIG9uIHRoZSBkYXRlIHRoYXQgY2FuIGJlIHJldHVybmVkXG4gKiBAcGFyYW0gbWF4UGFydHMgVGhlIG1heGltdW0gYm91bmQgb24gdGhlIGRhdGUgdGhhdCBjYW4gYmUgcmV0dXJuZWRcbiAqIEBwYXJhbSBkYXlWYWx1ZXMgVGhlIGFsbG93ZWQgZGF0ZSB2YWx1ZXNcbiAqIEByZXR1cm5zIERhdGUgZGF0YSB0byBiZSB1c2VkIGluIGlvbi1waWNrZXItY29sdW1uLWludGVybmFsXG4gKi9cbmNvbnN0IGdldERheUNvbHVtbkRhdGEgPSAobG9jYWxlLCByZWZQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCBkYXlWYWx1ZXMsIGZvcm1hdE9wdGlvbnMgPSB7XG4gIGRheTogJ251bWVyaWMnLFxufSkgPT4ge1xuICBjb25zdCB7IG1vbnRoLCB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgY29uc3QgZGF5cyA9IFtdO1xuICAvKipcbiAgICogSWYgd2UgaGF2ZSBtYXgvbWluIGJvdW5kcyB0aGF0IGluIHRoZSBzYW1lXG4gICAqIG1vbnRoL3llYXIgYXMgdGhlIHJlZlBhcnRzLCB3ZSBzaG91bGRcbiAgICogdXNlIHRoZSBkZWZpbmUgZGF5IGFzIHRoZSBtYXgvbWluIGRheS5cbiAgICogT3RoZXJ3aXNlLCBmYWxsYmFjayB0byB0aGUgbWF4L21pbiBkYXlzIGluIGEgbW9udGguXG4gICAqL1xuICBjb25zdCBudW1EYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgY29uc3QgbWF4RGF5ID0gKG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy5kYXkpICE9PSBudWxsICYmIChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMuZGF5KSAhPT0gdW5kZWZpbmVkICYmIG1heFBhcnRzLnllYXIgPT09IHllYXIgJiYgbWF4UGFydHMubW9udGggPT09IG1vbnRoXG4gICAgPyBtYXhQYXJ0cy5kYXlcbiAgICA6IG51bURheXNJbk1vbnRoO1xuICBjb25zdCBtaW5EYXkgPSAobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLmRheSkgIT09IG51bGwgJiYgKG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy5kYXkpICE9PSB1bmRlZmluZWQgJiYgbWluUGFydHMueWVhciA9PT0geWVhciAmJiBtaW5QYXJ0cy5tb250aCA9PT0gbW9udGhcbiAgICA/IG1pblBhcnRzLmRheVxuICAgIDogMTtcbiAgaWYgKGRheVZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IHByb2Nlc3NlZERheXMgPSBkYXlWYWx1ZXM7XG4gICAgcHJvY2Vzc2VkRGF5cyA9IHByb2Nlc3NlZERheXMuZmlsdGVyKChkYXkpID0+IGRheSA+PSBtaW5EYXkgJiYgZGF5IDw9IG1heERheSk7XG4gICAgcHJvY2Vzc2VkRGF5cy5mb3JFYWNoKChwcm9jZXNzZWREYXkpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHttb250aH0vJHtwcm9jZXNzZWREYXl9LyR7eWVhcn0gR01UKzAwMDBgKTtcbiAgICAgIGNvbnN0IGRheVN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgIGRheXMucHVzaCh7IHRleHQ6IGRheVN0cmluZywgdmFsdWU6IHByb2Nlc3NlZERheSB9KTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gbWluRGF5OyBpIDw9IG1heERheTsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7bW9udGh9LyR7aX0vJHt5ZWFyfSBHTVQrMDAwMGApO1xuICAgICAgY29uc3QgZGF5U3RyaW5nID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvcm1hdE9wdGlvbnMpLCB7IHRpbWVab25lOiAnVVRDJyB9KSkuZm9ybWF0KGRhdGUpO1xuICAgICAgZGF5cy5wdXNoKHsgdGV4dDogZGF5U3RyaW5nLCB2YWx1ZTogaSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRheXM7XG59O1xuY29uc3QgZ2V0WWVhckNvbHVtbkRhdGEgPSAobG9jYWxlLCByZWZQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCB5ZWFyVmFsdWVzKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCBwcm9jZXNzZWRZZWFycyA9IFtdO1xuICBpZiAoeWVhclZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJvY2Vzc2VkWWVhcnMgPSB5ZWFyVmFsdWVzO1xuICAgIGlmICgobWF4UGFydHMgPT09IG51bGwgfHwgbWF4UGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heFBhcnRzLnllYXIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2Nlc3NlZFllYXJzID0gcHJvY2Vzc2VkWWVhcnMuZmlsdGVyKCh5ZWFyKSA9PiB5ZWFyIDw9IG1heFBhcnRzLnllYXIpO1xuICAgIH1cbiAgICBpZiAoKG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy55ZWFyKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9jZXNzZWRZZWFycyA9IHByb2Nlc3NlZFllYXJzLmZpbHRlcigoeWVhcikgPT4geWVhciA+PSBtaW5QYXJ0cy55ZWFyKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgY29uc3QgeyB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgICBjb25zdCBtYXhZZWFyID0gKF9hID0gbWF4UGFydHMgPT09IG51bGwgfHwgbWF4UGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heFBhcnRzLnllYXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHllYXI7XG4gICAgY29uc3QgbWluWWVhciA9IChfYiA9IG1pblBhcnRzID09PSBudWxsIHx8IG1pblBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5QYXJ0cy55ZWFyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB5ZWFyIC0gMTAwO1xuICAgIGZvciAobGV0IGkgPSBtYXhZZWFyOyBpID49IG1pblllYXI7IGktLSkge1xuICAgICAgcHJvY2Vzc2VkWWVhcnMucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3NlZFllYXJzLm1hcCgoeWVhcikgPT4gKHtcbiAgICB0ZXh0OiBnZXRZZWFyKGxvY2FsZSwgeyB5ZWFyLCBtb250aDogcmVmUGFydHMubW9udGgsIGRheTogcmVmUGFydHMuZGF5IH0pLFxuICAgIHZhbHVlOiB5ZWFyLFxuICB9KSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIHN0YXJ0aW5nIGRhdGUgYW5kIGFuIHVwcGVyIGJvdW5kLFxuICogdGhpcyBmdW5jdGlvbnMgcmV0dXJucyBhbiBhcnJheSBvZiBhbGxcbiAqIG1vbnRoIG9iamVjdHMgaW4gdGhhdCByYW5nZS5cbiAqL1xuY29uc3QgZ2V0QWxsTW9udGhzSW5SYW5nZSA9IChjdXJyZW50UGFydHMsIG1heFBhcnRzKSA9PiB7XG4gIGlmIChjdXJyZW50UGFydHMubW9udGggPT09IG1heFBhcnRzLm1vbnRoICYmIGN1cnJlbnRQYXJ0cy55ZWFyID09PSBtYXhQYXJ0cy55ZWFyKSB7XG4gICAgcmV0dXJuIFtjdXJyZW50UGFydHNdO1xuICB9XG4gIHJldHVybiBbY3VycmVudFBhcnRzLCAuLi5nZXRBbGxNb250aHNJblJhbmdlKGdldE5leHRNb250aChjdXJyZW50UGFydHMpLCBtYXhQYXJ0cyldO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBwaWNrZXIgaXRlbXNcbiAqIHRoYXQgcmVwcmVzZW50IHRoZSBkYXlzIGluIGEgbW9udGguXG4gKiBFeGFtcGxlOiBcIlRodSwgSnVuIDJcIlxuICovXG5jb25zdCBnZXRDb21iaW5lZERhdGVDb2x1bW5EYXRhID0gKGxvY2FsZSwgdG9kYXlQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCBkYXlWYWx1ZXMsIG1vbnRoVmFsdWVzKSA9PiB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBsZXQgcGFydHMgPSBbXTtcbiAgLyoqXG4gICAqIEdldCBhbGwgbW9udGggb2JqZWN0cyBmcm9tIHRoZSBtaW4gZGF0ZVxuICAgKiB0byB0aGUgbWF4IGRhdGUuIE5vdGU6IERvIG5vdCB1c2UgZ2V0TW9udGhDb2x1bW5EYXRhXG4gICAqIGFzIHRoYXQgZnVuY3Rpb24gb25seSBnZW5lcmF0ZXMgZGF0ZXMgd2l0aGluIGFcbiAgICogc2luZ2xlIHllYXIuXG4gICAqL1xuICBsZXQgbW9udGhzID0gZ2V0QWxsTW9udGhzSW5SYW5nZShtaW5QYXJ0cywgbWF4UGFydHMpO1xuICAvKipcbiAgICogRmlsdGVyIG91dCBhbnkgZGlzYWxsb3dlZCBtb250aCB2YWx1ZXMuXG4gICAqL1xuICBpZiAobW9udGhWYWx1ZXMpIHtcbiAgICBtb250aHMgPSBtb250aHMuZmlsdGVyKCh7IG1vbnRoIH0pID0+IG1vbnRoVmFsdWVzLmluY2x1ZGVzKG1vbnRoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgb2YgdGhlIGRheXMgaW4gdGhlIG1vbnRoLlxuICAgKiBGcm9tIHRoZXJlLCBnZW5lcmF0ZSBhbiBhcnJheSB3aGVyZVxuICAgKiBlYWNoIGl0ZW0gaGFzIHRoZSBtb250aCwgZGF0ZSwgYW5kIGRheVxuICAgKiBvZiB3b3JrIGFzIHRoZSB0ZXh0LlxuICAgKi9cbiAgbW9udGhzLmZvckVhY2goKG1vbnRoT2JqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVmZXJlbmNlTW9udGggPSB7IG1vbnRoOiBtb250aE9iamVjdC5tb250aCwgZGF5OiBudWxsLCB5ZWFyOiBtb250aE9iamVjdC55ZWFyIH07XG4gICAgY29uc3QgbW9udGhEYXlzID0gZ2V0RGF5Q29sdW1uRGF0YShsb2NhbGUsIHJlZmVyZW5jZU1vbnRoLCBtaW5QYXJ0cywgbWF4UGFydHMsIGRheVZhbHVlcywge1xuICAgICAgbW9udGg6ICdzaG9ydCcsXG4gICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgIHdlZWtkYXk6ICdzaG9ydCcsXG4gICAgfSk7XG4gICAgY29uc3QgZGF0ZVBhcnRzID0gW107XG4gICAgY29uc3QgZGF0ZUNvbHVtbkl0ZW1zID0gW107XG4gICAgbW9udGhEYXlzLmZvckVhY2goKGRheU9iamVjdCkgPT4ge1xuICAgICAgY29uc3QgaXNUb2RheSA9IGlzU2FtZURheShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlZmVyZW5jZU1vbnRoKSwgeyBkYXk6IGRheU9iamVjdC52YWx1ZSB9KSwgdG9kYXlQYXJ0cyk7XG4gICAgICAvKipcbiAgICAgICAqIFRvZGF5J3MgZGF0ZSBzaG91bGQgcmVhZCBhcyBcIlRvZGF5XCIgKGxvY2FsaXplZClcbiAgICAgICAqIG5vdCB0aGUgYWN0dWFsIGRhdGUgc3RyaW5nXG4gICAgICAgKi9cbiAgICAgIGRhdGVDb2x1bW5JdGVtcy5wdXNoKHtcbiAgICAgICAgdGV4dDogaXNUb2RheSA/IGdldFRvZGF5TGFiZWwobG9jYWxlKSA6IGRheU9iamVjdC50ZXh0LFxuICAgICAgICB2YWx1ZTogYCR7cmVmZXJlbmNlTW9udGgueWVhcn0tJHtyZWZlcmVuY2VNb250aC5tb250aH0tJHtkYXlPYmplY3QudmFsdWV9YCxcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHNlbGVjdGluZyBhIGRhdGUgaW4gdGhlIHdoZWVsIHBpY2tlclxuICAgICAgICogd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIHJhdyBkYXRldGltZSBwYXJ0cyBkYXRhLlxuICAgICAgICogVGhlIHBpY2tlciBjb2x1bW4gb25seSBhY2NlcHRzIHZhbHVlcyBvZlxuICAgICAgICogdHlwZSBzdHJpbmcgb3IgbnVtYmVyLCBzbyB3ZSBuZWVkIHRvIHJldHVyblxuICAgICAgICogdHdvIHNldHMgb2YgZGF0YTogQSBkYXRhIHNldCB0byBiZSBwYXNzZWRcbiAgICAgICAqIHRvIHRoZSBwaWNrZXIgY29sdW1uLCBhbmQgYSBkYXRhIHNldCB0b1xuICAgICAgICogYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIHJhdyBkYXRhIHdoZW5cbiAgICAgICAqIHVwZGF0aW5nIHRoZSBwaWNrZXIgY29sdW1uIHZhbHVlLlxuICAgICAgICovXG4gICAgICBkYXRlUGFydHMucHVzaCh7XG4gICAgICAgIG1vbnRoOiByZWZlcmVuY2VNb250aC5tb250aCxcbiAgICAgICAgeWVhcjogcmVmZXJlbmNlTW9udGgueWVhcixcbiAgICAgICAgZGF5OiBkYXlPYmplY3QudmFsdWUsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwYXJ0cyA9IFsuLi5wYXJ0cywgLi4uZGF0ZVBhcnRzXTtcbiAgICBpdGVtcyA9IFsuLi5pdGVtcywgLi4uZGF0ZUNvbHVtbkl0ZW1zXTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcGFydHMsXG4gICAgaXRlbXMsXG4gIH07XG59O1xuY29uc3QgZ2V0VGltZUNvbHVtbnNEYXRhID0gKGxvY2FsZSwgcmVmUGFydHMsIGhvdXJDeWNsZSwgbWluUGFydHMsIG1heFBhcnRzLCBhbGxvd2VkSG91clZhbHVlcywgYWxsb3dlZE1pbnV0ZVZhdWVzKSA9PiB7XG4gIGNvbnN0IHVzZTI0SG91ciA9IGlzMjRIb3VyKGxvY2FsZSwgaG91ckN5Y2xlKTtcbiAgY29uc3QgeyBob3VycywgbWludXRlcywgYW0sIHBtIH0gPSBnZW5lcmF0ZVRpbWUocmVmUGFydHMsIHVzZTI0SG91ciA/ICdoMjMnIDogJ2gxMicsIG1pblBhcnRzLCBtYXhQYXJ0cywgYWxsb3dlZEhvdXJWYWx1ZXMsIGFsbG93ZWRNaW51dGVWYXVlcyk7XG4gIGNvbnN0IGhvdXJzSXRlbXMgPSBob3Vycy5tYXAoKGhvdXIpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogZ2V0Rm9ybWF0dGVkSG91cihob3VyLCB1c2UyNEhvdXIpLFxuICAgICAgdmFsdWU6IGdldEludGVybmFsSG91clZhbHVlKGhvdXIsIHVzZTI0SG91ciwgcmVmUGFydHMuYW1wbSksXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IG1pbnV0ZXNJdGVtcyA9IG1pbnV0ZXMubWFwKChtaW51dGUpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogYWRkVGltZVBhZGRpbmcobWludXRlKSxcbiAgICAgIHZhbHVlOiBtaW51dGUsXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IGRheVBlcmlvZEl0ZW1zID0gW107XG4gIGlmIChhbSAmJiAhdXNlMjRIb3VyKSB7XG4gICAgZGF5UGVyaW9kSXRlbXMucHVzaCh7XG4gICAgICB0ZXh0OiBnZXRMb2NhbGl6ZWREYXlQZXJpb2QobG9jYWxlLCAnYW0nKSxcbiAgICAgIHZhbHVlOiAnYW0nLFxuICAgIH0pO1xuICB9XG4gIGlmIChwbSAmJiAhdXNlMjRIb3VyKSB7XG4gICAgZGF5UGVyaW9kSXRlbXMucHVzaCh7XG4gICAgICB0ZXh0OiBnZXRMb2NhbGl6ZWREYXlQZXJpb2QobG9jYWxlLCAncG0nKSxcbiAgICAgIHZhbHVlOiAncG0nLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWludXRlc0RhdGE6IG1pbnV0ZXNJdGVtcyxcbiAgICBob3Vyc0RhdGE6IGhvdXJzSXRlbXMsXG4gICAgZGF5UGVyaW9kRGF0YTogZGF5UGVyaW9kSXRlbXMsXG4gIH07XG59O1xuXG5jb25zdCBJU09fODYwMV9SRUdFWFAgPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuL14oXFxkezR9fFsrXFwtXVxcZHs2fSkoPzotKFxcZHsyfSkoPzotKFxcZHsyfSkpPyk/KD86VChcXGR7Mn0pOihcXGR7Mn0pKD86OihcXGR7Mn0pKD86XFwuKFxcZHszfSkpPyk/KD86KFopfChbK1xcLV0pKFxcZHsyfSkoPzo6KFxcZHsyfSkpPyk/KT8kLztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuY29uc3QgVElNRV9SRUdFWFAgPSAvXigoXFxkezJ9KTooXFxkezJ9KSg/OjooXFxkezJ9KSg/OlxcLihcXGR7M30pKT8pPyg/OihaKXwoWytcXC1dKShcXGR7Mn0pKD86OihcXGR7Mn0pKT8pPyk/JC87XG4vKipcbiAqIFVzZSB0byBjb252ZXJ0IGEgc3RyaW5nIG9mIGNvbW1hIHNlcGFyYXRlZCBudW1iZXJzIG9yXG4gKiBhbiBhcnJheSBvZiBudW1iZXJzLCBhbmQgY2xlYW4gdXAgYW55IHVzZXIgaW5wdXRcbiAqL1xuY29uc3QgY29udmVydFRvQXJyYXlPZk51bWJlcnMgPSAoaW5wdXQpID0+IHtcbiAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHByb2Nlc3NlZElucHV0ID0gaW5wdXQ7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gY29udmVydCB0aGUgc3RyaW5nIHRvIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAvLyBhdXRvIHJlbW92ZSBhbnkgd2hpdGVzcGFjZSBhbmQgW10gY2hhcmFjdGVyc1xuICAgIHByb2Nlc3NlZElucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxbfFxcXXxcXHMvZywgJycpLnNwbGl0KCcsJyk7XG4gIH1cbiAgbGV0IHZhbHVlcztcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvY2Vzc2VkSW5wdXQpKSB7XG4gICAgLy8gZW5zdXJlIGVhY2ggdmFsdWUgaXMgYW4gYWN0dWFsIG51bWJlciBpbiB0aGUgcmV0dXJuZWQgYXJyYXlcbiAgICB2YWx1ZXMgPSBwcm9jZXNzZWRJbnB1dC5tYXAoKG51bSkgPT4gcGFyc2VJbnQobnVtLCAxMCkpLmZpbHRlcihpc0Zpbml0ZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFsdWVzID0gW3Byb2Nlc3NlZElucHV0XTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufTtcbi8qKlxuICogRXh0cmFjdHMgZGF0ZSBpbmZvcm1hdGlvblxuICogZnJvbSBhIC5jYWxlbmRhci1kYXkgZWxlbWVudFxuICogaW50byBEYXRldGltZVBhcnRzLlxuICovXG5jb25zdCBnZXRQYXJ0c0Zyb21DYWxlbmRhckRheSA9IChlbCkgPT4ge1xuICByZXR1cm4ge1xuICAgIG1vbnRoOiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9udGgnKSwgMTApLFxuICAgIGRheTogcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRheScpLCAxMCksXG4gICAgeWVhcjogcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXllYXInKSwgMTApLFxuICAgIGRheU9mV2VlazogcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRheS1vZi13ZWVrJyksIDEwKSxcbiAgfTtcbn07XG5mdW5jdGlvbiBwYXJzZURhdGUodmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLm1hcCgodmFsU3RyKSA9PiBwYXJzZURhdGUodmFsU3RyKSk7XG4gIH1cbiAgLy8gbWFudWFsbHkgcGFyc2UgSVMwIGN1eiBEYXRlLnBhcnNlIGNhbm5vdCBiZSB0cnVzdGVkXG4gIC8vIElTTyA4NjAxIGZvcm1hdDogMTk5NC0xMi0xNVQxMzo0NzoyMFpcbiAgbGV0IHBhcnNlID0gbnVsbDtcbiAgaWYgKHZhbCAhPSBudWxsICYmIHZhbCAhPT0gJycpIHtcbiAgICAvLyB0cnkgcGFyc2luZyBmb3IganVzdCB0aW1lIGZpcnN0LCBISDpNTVxuICAgIHBhcnNlID0gVElNRV9SRUdFWFAuZXhlYyh2YWwpO1xuICAgIGlmIChwYXJzZSkge1xuICAgICAgLy8gYWRqdXN0IHRoZSBhcnJheSBzbyBpdCBmaXRzIG5pY2VseSB3aXRoIHRoZSBkYXRldGltZSBwYXJzZVxuICAgICAgcGFyc2UudW5zaGlmdCh1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICBwYXJzZVsyXSA9IHBhcnNlWzNdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHRyeSBwYXJzaW5nIGZvciBmdWxsIElTTyBkYXRldGltZVxuICAgICAgcGFyc2UgPSBJU09fODYwMV9SRUdFWFAuZXhlYyh2YWwpO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2UgPT09IG51bGwpIHtcbiAgICAvLyB3YXNuJ3QgYWJsZSB0byBwYXJzZSB0aGUgSVNPIGRhdGV0aW1lXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvLyBlbnN1cmUgYWxsIHRoZSBwYXJzZSB2YWx1ZXMgZXhpc3Qgd2l0aCBhdCBsZWFzdCAwXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgcGFyc2VbaV0gPSBwYXJzZVtpXSAhPT0gdW5kZWZpbmVkID8gcGFyc2VJbnQocGFyc2VbaV0sIDEwKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgdHpPZmZzZXQgPSAwO1xuICBpZiAocGFyc2VbOV0gJiYgcGFyc2VbMTBdKSB7XG4gICAgLy8gaG91cnNcbiAgICB0ek9mZnNldCA9IHBhcnNlSW50KHBhcnNlWzEwXSwgMTApICogNjA7XG4gICAgaWYgKHBhcnNlWzExXSkge1xuICAgICAgLy8gbWludXRlc1xuICAgICAgdHpPZmZzZXQgKz0gcGFyc2VJbnQocGFyc2VbMTFdLCAxMCk7XG4gICAgfVxuICAgIGlmIChwYXJzZVs5XSA9PT0gJy0nKSB7XG4gICAgICAvLyArIG9yIC1cbiAgICAgIHR6T2Zmc2V0ICo9IC0xO1xuICAgIH1cbiAgfVxuICAvLyBjYW4gYWxzbyBnZXQgc2Vjb25kIGFuZCBtaWxsaXNlY29uZCBmcm9tIHBhcnNlWzZdIGFuZCBwYXJzZVs3XSBpZiBuZWVkZWRcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBwYXJzZVsxXSxcbiAgICBtb250aDogcGFyc2VbMl0sXG4gICAgZGF5OiBwYXJzZVszXSxcbiAgICBob3VyOiBwYXJzZVs0XSxcbiAgICBtaW51dGU6IHBhcnNlWzVdLFxuICAgIHR6T2Zmc2V0LFxuICAgIGFtcG06IHBhcnNlWzRdIDwgMTIgPyAnYW0nIDogJ3BtJyxcbiAgfTtcbn1cbmNvbnN0IGNsYW1wRGF0ZSA9IChkYXRlUGFydHMsIG1pblBhcnRzLCBtYXhQYXJ0cykgPT4ge1xuICBpZiAobWluUGFydHMgJiYgaXNCZWZvcmUoZGF0ZVBhcnRzLCBtaW5QYXJ0cykpIHtcbiAgICByZXR1cm4gbWluUGFydHM7XG4gIH1cbiAgZWxzZSBpZiAobWF4UGFydHMgJiYgaXNBZnRlcihkYXRlUGFydHMsIG1heFBhcnRzKSkge1xuICAgIHJldHVybiBtYXhQYXJ0cztcbiAgfVxuICByZXR1cm4gZGF0ZVBhcnRzO1xufTtcbi8qKlxuICogUGFyc2VzIGFuIGhvdXIgYW5kIHJldHVybnMgaWYgdGhlIHZhbHVlIGlzIGluIHRoZSBtb3JuaW5nIChhbSkgb3IgYWZ0ZXJub29uIChwbSkuXG4gKiBAcGFyYW0gaG91ciBUaGUgaG91ciB0byBmb3JtYXQsIHNob3VsZCBiZSAwLTIzXG4gKiBAcmV0dXJucyBgcG1gIGlmIHRoZSBob3VyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxMiwgYGFtYCBpZiBsZXNzIHRoYW4gMTIuXG4gKi9cbmNvbnN0IHBhcnNlQW1QbSA9IChob3VyKSA9PiB7XG4gIHJldHVybiBob3VyID49IDEyID8gJ3BtJyA6ICdhbSc7XG59O1xuLyoqXG4gKiBUYWtlcyBhIG1heCBkYXRlIHN0cmluZyBhbmQgY3JlYXRlcyBhIERhdGV0aW1lUGFydHNcbiAqIG9iamVjdCwgZmlsbGluZyBpbiBhbnkgbWlzc2luZyBpbmZvcm1hdGlvbi5cbiAqIEZvciBleGFtcGxlLCBtYXg9XCIyMDEyXCIgd291bGQgZmlsbCBpbiB0aGUgbWlzc2luZ1xuICogbW9udGgsIGRheSwgaG91ciwgYW5kIG1pbnV0ZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgcGFyc2VNYXhQYXJ0cyA9IChtYXgsIHRvZGF5UGFydHMpID0+IHtcbiAgY29uc3QgeyBtb250aCwgZGF5LCB5ZWFyLCBob3VyLCBtaW51dGUgfSA9IHBhcnNlRGF0ZShtYXgpO1xuICAvKipcbiAgICogV2hlbiBwYXNzaW5nIGluIGBtYXhgIG9yIGBtaW5gLCBkZXZlbG9wZXJzXG4gICAqIGNhbiBwYXNzIGluIGFueSBJU08tODYwMSBzdHJpbmcuIFRoaXMgbWVhbnNcbiAgICogdGhhdCBub3QgYWxsIG9mIHRoZSBkYXRlL3RpbWUgZmllbGRzIGFyZSBkZWZpbmVkLlxuICAgKiBGb3IgZXhhbXBsZSwgcGFzc2luZyBtYXg9XCIyMDEyXCIgaXMgdmFsaWQgZXZlbiB0aG91Z2hcbiAgICogdGhlcmUgaXMgbm8gbW9udGgsIGRheSwgaG91ciwgb3IgbWludXRlIGRhdGEuXG4gICAqIEhvd2V2ZXIsIGFsbCBvZiB0aGlzIGRhdGEgaXMgcmVxdWlyZWQgd2hlbiBjbGFtcGluZyB0aGUgZGF0ZVxuICAgKiBzbyB0aGF0IHRoZSBjb3JyZWN0IGluaXRpYWwgdmFsdWUgY2FuIGJlIHNlbGVjdGVkLiBBcyBhIHJlc3VsdCxcbiAgICogd2UgbmVlZCB0byBmaWxsIGluIGFueSBvbWl0dGVkIGRhdGEgd2l0aCB0aGUgbWluIG9yIG1heCB2YWx1ZXMuXG4gICAqL1xuICBjb25zdCB5ZWFyVmFsdWUgPSB5ZWFyICE9PSBudWxsICYmIHllYXIgIT09IHZvaWQgMCA/IHllYXIgOiB0b2RheVBhcnRzLnllYXI7XG4gIGNvbnN0IG1vbnRoVmFsdWUgPSBtb250aCAhPT0gbnVsbCAmJiBtb250aCAhPT0gdm9pZCAwID8gbW9udGggOiAxMjtcbiAgcmV0dXJuIHtcbiAgICBtb250aDogbW9udGhWYWx1ZSxcbiAgICBkYXk6IGRheSAhPT0gbnVsbCAmJiBkYXkgIT09IHZvaWQgMCA/IGRheSA6IGdldE51bURheXNJbk1vbnRoKG1vbnRoVmFsdWUsIHllYXJWYWx1ZSksXG4gICAgLyoqXG4gICAgICogUGFzc2luZyBpbiBcIkhIOm1tXCIgaXMgYSB2YWxpZCBJU08tODYwMVxuICAgICAqIHN0cmluZywgc28gd2UganVzdCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IHllYXJcbiAgICAgKiBpbiB0aGlzIGNhc2UuXG4gICAgICovXG4gICAgeWVhcjogeWVhclZhbHVlLFxuICAgIGhvdXI6IGhvdXIgIT09IG51bGwgJiYgaG91ciAhPT0gdm9pZCAwID8gaG91ciA6IDIzLFxuICAgIG1pbnV0ZTogbWludXRlICE9PSBudWxsICYmIG1pbnV0ZSAhPT0gdm9pZCAwID8gbWludXRlIDogNTksXG4gIH07XG59O1xuLyoqXG4gKiBUYWtlcyBhIG1pbiBkYXRlIHN0cmluZyBhbmQgY3JlYXRlcyBhIERhdGV0aW1lUGFydHNcbiAqIG9iamVjdCwgZmlsbGluZyBpbiBhbnkgbWlzc2luZyBpbmZvcm1hdGlvbi5cbiAqIEZvciBleGFtcGxlLCBtaW49XCIyMDEyXCIgd291bGQgZmlsbCBpbiB0aGUgbWlzc2luZ1xuICogbW9udGgsIGRheSwgaG91ciwgYW5kIG1pbnV0ZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgcGFyc2VNaW5QYXJ0cyA9IChtaW4sIHRvZGF5UGFydHMpID0+IHtcbiAgY29uc3QgeyBtb250aCwgZGF5LCB5ZWFyLCBob3VyLCBtaW51dGUgfSA9IHBhcnNlRGF0ZShtaW4pO1xuICAvKipcbiAgICogV2hlbiBwYXNzaW5nIGluIGBtYXhgIG9yIGBtaW5gLCBkZXZlbG9wZXJzXG4gICAqIGNhbiBwYXNzIGluIGFueSBJU08tODYwMSBzdHJpbmcuIFRoaXMgbWVhbnNcbiAgICogdGhhdCBub3QgYWxsIG9mIHRoZSBkYXRlL3RpbWUgZmllbGRzIGFyZSBkZWZpbmVkLlxuICAgKiBGb3IgZXhhbXBsZSwgcGFzc2luZyBtYXg9XCIyMDEyXCIgaXMgdmFsaWQgZXZlbiB0aG91Z2hcbiAgICogdGhlcmUgaXMgbm8gbW9udGgsIGRheSwgaG91ciwgb3IgbWludXRlIGRhdGEuXG4gICAqIEhvd2V2ZXIsIGFsbCBvZiB0aGlzIGRhdGEgaXMgcmVxdWlyZWQgd2hlbiBjbGFtcGluZyB0aGUgZGF0ZVxuICAgKiBzbyB0aGF0IHRoZSBjb3JyZWN0IGluaXRpYWwgdmFsdWUgY2FuIGJlIHNlbGVjdGVkLiBBcyBhIHJlc3VsdCxcbiAgICogd2UgbmVlZCB0byBmaWxsIGluIGFueSBvbWl0dGVkIGRhdGEgd2l0aCB0aGUgbWluIG9yIG1heCB2YWx1ZXMuXG4gICAqL1xuICByZXR1cm4ge1xuICAgIG1vbnRoOiBtb250aCAhPT0gbnVsbCAmJiBtb250aCAhPT0gdm9pZCAwID8gbW9udGggOiAxLFxuICAgIGRheTogZGF5ICE9PSBudWxsICYmIGRheSAhPT0gdm9pZCAwID8gZGF5IDogMSxcbiAgICAvKipcbiAgICAgKiBQYXNzaW5nIGluIFwiSEg6bW1cIiBpcyBhIHZhbGlkIElTTy04NjAxXG4gICAgICogc3RyaW5nLCBzbyB3ZSBqdXN0IGRlZmF1bHQgdG8gdGhlIGN1cnJlbnQgeWVhclxuICAgICAqIGluIHRoaXMgY2FzZS5cbiAgICAgKi9cbiAgICB5ZWFyOiB5ZWFyICE9PSBudWxsICYmIHllYXIgIT09IHZvaWQgMCA/IHllYXIgOiB0b2RheVBhcnRzLnllYXIsXG4gICAgaG91cjogaG91ciAhPT0gbnVsbCAmJiBob3VyICE9PSB2b2lkIDAgPyBob3VyIDogMCxcbiAgICBtaW51dGU6IG1pbnV0ZSAhPT0gbnVsbCAmJiBtaW51dGUgIT09IHZvaWQgMCA/IG1pbnV0ZSA6IDAsXG4gIH07XG59O1xuXG5leHBvcnQgeyBnZXRZZWFyQ29sdW1uRGF0YSBhcyBBLCBpc01vbnRoRmlyc3RMb2NhbGUgYXMgQiwgZ2V0VGltZUNvbHVtbnNEYXRhIGFzIEMsIGlzTG9jYWxlRGF5UGVyaW9kUlRMIGFzIEQsIGdldERheXNPZldlZWsgYXMgRSwgZ2V0TW9udGhBbmRZZWFyIGFzIEYsIGdldERheXNPZk1vbnRoIGFzIEcsIGdlbmVyYXRlTW9udGhzIGFzIEgsIGlzMjRIb3VyIGFzIEksIGdldExvY2FsaXplZFRpbWUgYXMgSiwgZ2V0TW9udGhBbmREYXkgYXMgSywgZm9ybWF0VmFsdWUgYXMgTCwgZ2V0TmV4dFllYXIgYXMgTSwgZ2V0UHJldmlvdXNZZWFyIGFzIE4sIGNsYW1wRGF0ZSBhcyBPLCBwYXJzZUFtUG0gYXMgUCwgY2FsY3VsYXRlSG91ckZyb21BTVBNIGFzIFEsIGdldExvY2FsaXplZERhdGVUaW1lIGFzIFIsIGdldE1vbnRoRGF5QW5kWWVhciBhcyBTLCBnZXREYXkgYXMgYSwgaXNBZnRlciBhcyBiLCBpc1NhbWVEYXkgYXMgYywgZ2V0UHJldmlvdXNNb250aCBhcyBkLCBnZXROZXh0TW9udGggYXMgZSwgZ2V0VG9kYXkgYXMgZiwgZ2VuZXJhdGVEYXlBcmlhTGFiZWwgYXMgZywgZ2V0UGFydHNGcm9tQ2FsZW5kYXJEYXkgYXMgaCwgaXNCZWZvcmUgYXMgaSwgZ2V0RW5kT2ZXZWVrIGFzIGosIGdldFN0YXJ0T2ZXZWVrIGFzIGssIGdldFByZXZpb3VzRGF5IGFzIGwsIGdldE5leHREYXkgYXMgbSwgZ2V0UHJldmlvdXNXZWVrIGFzIG4sIGdldE5leHRXZWVrIGFzIG8sIHBhcnNlRGF0ZSBhcyBwLCBwYXJzZU1pblBhcnRzIGFzIHEsIHBhcnNlTWF4UGFydHMgYXMgciwgY29udmVydFRvQXJyYXlPZk51bWJlcnMgYXMgcywgY29udmVydERhdGFUb0lTTyBhcyB0LCBnZXROdW1EYXlzSW5Nb250aCBhcyB1LCB2YWxpZGF0ZVBhcnRzIGFzIHYsIHdhcm5JZlZhbHVlT3V0T2ZCb3VuZHMgYXMgdywgZ2V0Q29tYmluZWREYXRlQ29sdW1uRGF0YSBhcyB4LCBnZXRNb250aENvbHVtbkRhdGEgYXMgeSwgZ2V0RGF5Q29sdW1uRGF0YSBhcyB6IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuY29uc3QgaG9zdENvbnRleHQgPSAoc2VsZWN0b3IsIGVsKSA9PiB7XG4gIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKSAhPT0gbnVsbDtcbn07XG4vKipcbiAqIENyZWF0ZSB0aGUgbW9kZSBhbmQgY29sb3IgY2xhc3NlcyBmb3IgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgY2xhc3NlcyBwYXNzZWQgaW5cbiAqL1xuY29uc3QgY3JlYXRlQ29sb3JDbGFzc2VzID0gKGNvbG9yLCBjc3NDbGFzc01hcCkgPT4ge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBjb2xvci5sZW5ndGggPiAwXG4gICAgPyBPYmplY3QuYXNzaWduKHsgJ2lvbi1jb2xvcic6IHRydWUsIFtgaW9uLWNvbG9yLSR7Y29sb3J9YF06IHRydWUgfSwgY3NzQ2xhc3NNYXApIDogY3NzQ2xhc3NNYXA7XG59O1xuY29uc3QgZ2V0Q2xhc3NMaXN0ID0gKGNsYXNzZXMpID0+IHtcbiAgaWYgKGNsYXNzZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheShjbGFzc2VzKSA/IGNsYXNzZXMgOiBjbGFzc2VzLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIGFycmF5XG4gICAgICAuZmlsdGVyKChjKSA9PiBjICE9IG51bGwpXG4gICAgICAubWFwKChjKSA9PiBjLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIoKGMpID0+IGMgIT09ICcnKTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuY29uc3QgZ2V0Q2xhc3NNYXAgPSAoY2xhc3NlcykgPT4ge1xuICBjb25zdCBtYXAgPSB7fTtcbiAgZ2V0Q2xhc3NMaXN0KGNsYXNzZXMpLmZvckVhY2goKGMpID0+IChtYXBbY10gPSB0cnVlKSk7XG4gIHJldHVybiBtYXA7XG59O1xuY29uc3QgU0NIRU1FID0gL15bYS16XVthLXowLTkrXFwtLl0qOi87XG5jb25zdCBvcGVuVVJMID0gYXN5bmMgKHVybCwgZXYsIGRpcmVjdGlvbiwgYW5pbWF0aW9uKSA9PiB7XG4gIGlmICh1cmwgIT0gbnVsbCAmJiB1cmxbMF0gIT09ICcjJyAmJiAhU0NIRU1FLnRlc3QodXJsKSkge1xuICAgIGNvbnN0IHJvdXRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lvbi1yb3V0ZXInKTtcbiAgICBpZiAocm91dGVyKSB7XG4gICAgICBpZiAoZXYgIT0gbnVsbCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdXRlci5wdXNoKHVybCwgZGlyZWN0aW9uLCBhbmltYXRpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVDb2xvckNsYXNzZXMgYXMgYywgZ2V0Q2xhc3NNYXAgYXMgZywgaG9zdENvbnRleHQgYXMgaCwgb3BlblVSTCBhcyBvIH07XG4iXSwibmFtZXMiOlsicHJpbnRJb25XYXJuaW5nIiwibWVzc2FnZSIsInBhcmFtcyIsImNvbnNvbGUiLCJ3YXJuIiwicHJpbnRJb25FcnJvciIsImVycm9yIiwicHJpbnRSZXF1aXJlZEVsZW1lbnRFcnJvciIsImVsIiwidGFyZ2V0U2VsZWN0b3JzIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwiam9pbiIsImEiLCJiIiwicCIsImlzU2FtZURheSIsImJhc2VQYXJ0cyIsImNvbXBhcmVQYXJ0cyIsIm1vbnRoIiwiZGF5IiwieWVhciIsImlzQmVmb3JlIiwiaXNBZnRlciIsIndhcm5JZlZhbHVlT3V0T2ZCb3VuZHMiLCJ2YWx1ZSIsIm1pbiIsIm1heCIsInZhbHVlQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWwiLCJ1bmRlZmluZWQiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNMZWFwWWVhciIsImlzMjRIb3VyIiwibG9jYWxlIiwiaG91ckN5Y2xlIiwiZm9ybWF0dGVkIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiaG91ciIsIm9wdGlvbnMiLCJyZXNvbHZlZE9wdGlvbnMiLCJkYXRlIiwiRGF0ZSIsInBhcnRzIiwiZm9ybWF0VG9QYXJ0cyIsImZpbmQiLCJ0eXBlIiwiRXJyb3IiLCJnZXROdW1EYXlzSW5Nb250aCIsImlzTW9udGhGaXJzdExvY2FsZSIsImZvcm1hdE9wdGlvbnMiLCJpc0xvY2FsZURheVBlcmlvZFJUTCIsInR3b0RpZ2l0IiwiTWF0aCIsImFicyIsInNsaWNlIiwiZm91ckRpZ2l0IiwiY29udmVydERhdGFUb0lTTyIsImRhdGEiLCJtYXAiLCJydG4iLCJtaW51dGUiLCJ0ek9mZnNldCIsImZsb29yIiwiY29udmVydDEySG91clRvMjRIb3VyIiwiYW1wbSIsImdldFN0YXJ0T2ZXZWVrIiwicmVmUGFydHMiLCJkYXlPZldlZWsiLCJzdWJ0cmFjdERheXMiLCJnZXRFbmRPZldlZWsiLCJhZGREYXlzIiwiZ2V0TmV4dERheSIsImdldFByZXZpb3VzRGF5IiwiZ2V0UHJldmlvdXNXZWVrIiwiZ2V0TmV4dFdlZWsiLCJudW1EYXlzIiwid29ya2luZ1BhcnRzIiwiZGF5c0luTW9udGgiLCJnZXRQcmV2aW91c01vbnRoIiwibnVtRGF5c0luTW9udGgiLCJnZXROZXh0TW9udGgiLCJjaGFuZ2VZZWFyIiwieWVhckRlbHRhIiwiZ2V0UHJldmlvdXNZZWFyIiwiZ2V0TmV4dFllYXIiLCJnZXRJbnRlcm5hbEhvdXJWYWx1ZSIsInVzZTI0SG91ciIsImNhbGN1bGF0ZUhvdXJGcm9tQU1QTSIsImN1cnJlbnRQYXJ0cyIsIm5ld0FNUE0iLCJjdXJyZW50QU1QTSIsIm5ld0hvdXIiLCJ2YWxpZGF0ZVBhcnRzIiwibWluUGFydHMiLCJtYXhQYXJ0cyIsInBhcnRzQ29weSIsIk9iamVjdCIsImFzc2lnbiIsImdldEZvcm1hdHRlZERheVBlcmlvZCIsImRheVBlcmlvZCIsInRvVXBwZXJDYXNlIiwiZ2V0TG9jYWxpemVkVGltZSIsInRpbWVab25lIiwiZm9ybWF0IiwiYWRkVGltZVBhZGRpbmciLCJ2YWx1ZVRvU3RyaW5nIiwidG9TdHJpbmciLCJsZW5ndGgiLCJnZXRGb3JtYXR0ZWRIb3VyIiwiZ2VuZXJhdGVEYXlBcmlhTGFiZWwiLCJ0b2RheSIsImxhYmVsU3RyaW5nIiwid2Vla2RheSIsImdldE1vbnRoQW5kRGF5IiwiZ2V0TW9udGhBbmRZZWFyIiwiZ2V0TW9udGhEYXlBbmRZZWFyIiwiZ2V0TG9jYWxpemVkRGF0ZVRpbWUiLCJnZXREYXkiLCJnZXRMb2NhbGl6ZWREYXRlVGltZVBhcnRzIiwib2JqIiwiZ2V0WWVhciIsImdldE5vcm1hbGl6ZWREYXRlIiwidGltZVN0cmluZyIsImdldERhdGVUaW1lRm9ybWF0IiwiZ2V0VG9kYXlMYWJlbCIsImxhYmVsIiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwibnVtZXJpYyIsImNoYXJBdCIsInJlbW92ZURhdGVUek9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2V0TWludXRlcyIsImdldE1pbnV0ZXMiLCJEQVRFX0FNIiwiREFURV9QTSIsImdldExvY2FsaXplZERheVBlcmlvZCIsImxvY2FsaXplZERheVBlcmlvZCIsInBhcnQiLCJmb3JtYXRWYWx1ZSIsImdldFRvZGF5IiwidG9JU09TdHJpbmciLCJtaW51dGVzIiwiaG91cjEyIiwiaG91cjIzIiwiZ2V0RGF5c09mV2VlayIsIm1vZGUiLCJmaXJzdERheU9mV2VlayIsIndlZWtkYXlGb3JtYXQiLCJpbnRsIiwic3RhcnREYXRlIiwiZGF5c09mV2VlayIsImkiLCJjdXJyZW50RGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwicHVzaCIsImdldERheXNPZk1vbnRoIiwiZmlyc3RPZk1vbnRoIiwib2Zmc2V0IiwiZGF5cyIsImdlbmVyYXRlVGltZSIsImhvdXJWYWx1ZXMiLCJtaW51dGVWYWx1ZXMiLCJwcm9jZXNzZWRIb3VycyIsInByb2Nlc3NlZE1pbnV0ZXMiLCJpc0FNQWxsb3dlZCIsImlzUE1BbGxvd2VkIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJjb252ZXJ0ZWRIb3VyIiwiaXNQYXN0TWluSG91ciIsImhvdXJzIiwiYW0iLCJwbSIsImdlbmVyYXRlTW9udGhzIiwiZ2V0TW9udGhDb2x1bW5EYXRhIiwibW9udGhWYWx1ZXMiLCJtb250aHMiLCJwcm9jZXNzZWRNb250aHMiLCJmb3JFYWNoIiwicHJvY2Vzc2VkTW9udGgiLCJtb250aFN0cmluZyIsInRleHQiLCJtYXhNb250aCIsIm1pbk1vbnRoIiwiZ2V0RGF5Q29sdW1uRGF0YSIsImRheVZhbHVlcyIsIm1heERheSIsIm1pbkRheSIsInByb2Nlc3NlZERheXMiLCJwcm9jZXNzZWREYXkiLCJkYXlTdHJpbmciLCJnZXRZZWFyQ29sdW1uRGF0YSIsInllYXJWYWx1ZXMiLCJfYSIsIl9iIiwicHJvY2Vzc2VkWWVhcnMiLCJtYXhZZWFyIiwibWluWWVhciIsImdldEFsbE1vbnRoc0luUmFuZ2UiLCJnZXRDb21iaW5lZERhdGVDb2x1bW5EYXRhIiwidG9kYXlQYXJ0cyIsIml0ZW1zIiwibW9udGhPYmplY3QiLCJyZWZlcmVuY2VNb250aCIsIm1vbnRoRGF5cyIsImRhdGVQYXJ0cyIsImRhdGVDb2x1bW5JdGVtcyIsImRheU9iamVjdCIsImlzVG9kYXkiLCJnZXRUaW1lQ29sdW1uc0RhdGEiLCJhbGxvd2VkSG91clZhbHVlcyIsImFsbG93ZWRNaW51dGVWYXVlcyIsImhvdXJzSXRlbXMiLCJtaW51dGVzSXRlbXMiLCJkYXlQZXJpb2RJdGVtcyIsIm1pbnV0ZXNEYXRhIiwiaG91cnNEYXRhIiwiZGF5UGVyaW9kRGF0YSIsIklTT184NjAxX1JFR0VYUCIsIlRJTUVfUkVHRVhQIiwiY29udmVydFRvQXJyYXlPZk51bWJlcnMiLCJpbnB1dCIsInByb2Nlc3NlZElucHV0IiwicmVwbGFjZSIsInNwbGl0IiwidmFsdWVzIiwibnVtIiwicGFyc2VJbnQiLCJpc0Zpbml0ZSIsImdldFBhcnRzRnJvbUNhbGVuZGFyRGF5IiwiZ2V0QXR0cmlidXRlIiwicGFyc2VEYXRlIiwidmFsU3RyIiwicGFyc2UiLCJleGVjIiwidW5zaGlmdCIsImNsYW1wRGF0ZSIsInBhcnNlQW1QbSIsInBhcnNlTWF4UGFydHMiLCJ5ZWFyVmFsdWUiLCJtb250aFZhbHVlIiwicGFyc2VNaW5QYXJ0cyIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiaG9zdENvbnRleHQiLCJzZWxlY3RvciIsImNsb3Nlc3QiLCJjcmVhdGVDb2xvckNsYXNzZXMiLCJjb2xvciIsImNzc0NsYXNzTWFwIiwiZ2V0Q2xhc3NMaXN0IiwiY2xhc3NlcyIsImFycmF5IiwidHJpbSIsImdldENsYXNzTWFwIiwiU0NIRU1FIiwib3BlblVSTCIsInVybCIsImV2IiwiZGlyZWN0aW9uIiwiYW5pbWF0aW9uIiwidGVzdCIsInJvdXRlciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInByZXZlbnREZWZhdWx0Il0sInNvdXJjZVJvb3QiOiJ3ZWJwYWNrOi8vLyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMl19